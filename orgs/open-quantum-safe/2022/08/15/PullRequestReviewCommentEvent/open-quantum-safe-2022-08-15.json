{"id":"23446465130","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/946087442","pull_request_review_id":1073149014,"id":946087442,"node_id":"PRRC_kwDOA-eq3c44ZCYS","diff_hunk":"@@ -0,0 +1,416 @@\n+// SPDX-License-Identifier: MIT\n+\n+#if defined(_WIN32)\n+#pragma warning(disable : 4244 4293)\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <oqs/oqs.h>\n+\n+#if OQS_USE_PTHREADS_IN_TESTS\n+#include <pthread.h>\n+#endif\n+\n+#ifdef OQS_ENABLE_TEST_CONSTANT_TIME\n+#include <valgrind/memcheck.h>\n+#define OQS_TEST_CT_CLASSIFY(addr, len)  VALGRIND_MAKE_MEM_UNDEFINED(addr, len)\n+#define OQS_TEST_CT_DECLASSIFY(addr, len)  VALGRIND_MAKE_MEM_DEFINED(addr, len)\n+#else\n+#define OQS_TEST_CT_CLASSIFY(addr, len)\n+#define OQS_TEST_CT_DECLASSIFY(addr, len)\n+#endif\n+\n+#include \"system_info.c\"\n+\n+// Useful for mode of operations\n+#define READING 'r'\n+#define SAVING 's'\n+#define NOTHING 'x'\n+#define DIRECTORY_PLUS_PREFIX \"../tests/saved_keys/tmp_\"\n+\n+#define PRIVATE_KEY_EXT \".prv\"\n+#define PUBLIC_KEY_EXT \".pub\"\n+\n+typedef struct magic_s {\n+\tuint8_t val[31];\n+} magic_t;\n+\n+void prepend(char *s, const char *t) {\n+\tsize_t len = strlen(t);\n+\tmemmove(s + len, s, strlen(s) + 1);\n+\tmemcpy(s, t, len);\n+}\n+\n+OQS_STATUS lock_sk_key(OQS_SECRET_KEY *sk) {\n+\tuint8_t ss = *(sk->secret_key);\n+\tss = 0;\n+\treturn ss == 0 ? OQS_SUCCESS : OQS_ERROR;\n+}\n+\n+OQS_STATUS release_sk_key(OQS_SECRET_KEY *sk) {\n+\tuint8_t ss = *(sk->secret_key);\n+\tss = 0;\n+\treturn ss == 0 ? OQS_SUCCESS : OQS_ERROR;\n+}\n+\n+OQS_STATUS do_nothing_save(const OQS_SECRET_KEY *sk) {\n+\tuint8_t ss = *(sk->secret_key);\n+\tss = 0;\n+\treturn ss == 0 ? OQS_SUCCESS : OQS_ERROR;\n+}\n+\n+OQS_STATUS sk_file_write(const OQS_SECRET_KEY *sk) {\n+\tchar filename[64];\n+\tstrcpy(filename, (char *)sk->data);\n+\n+\tstrcat(filename, PRIVATE_KEY_EXT);\n+\tFILE *printer = fopen(filename, \"w+\");\n+\tif (printer == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\t// Write the entire secret key byte array to the specified file.\n+\tfor (unsigned long i = 0; i < sk->length_secret_key; i++) {\n+\t\tif (fputc(sk->secret_key[i], printer) == EOF) {\n+\t\t\treturn OQS_ERROR;\n+\t\t}\n+\t}\n+\tfclose(printer);\n+\treturn OQS_SUCCESS;\n+}\n+\n+static OQS_STATUS sig_stfl_test_correctness(const char *method_name, char mode, const char *filestem) {\n+\n+\tOQS_SIG_STFL *sig = NULL;\n+\tuint8_t *public_key = NULL;\n+\tOQS_SECRET_KEY *secret_key = NULL;\n+\tuint8_t *message = NULL;\n+\tsize_t message_len = 100;\n+\tuint8_t *signature = NULL;\n+\tsize_t signature_len;\n+\tOQS_STATUS rc, ret = OQS_ERROR;\n+\tchar filename[64];\n+\n+\t//The magic numbers are random values.\n+\t//The length of the magic number was chosen to be 31 to break alignment\n+\tmagic_t magic;\n+\tOQS_randombytes(magic.val, sizeof(magic_t));\n+\n+\tsig = OQS_SIG_STFL_new(method_name);\n+\tif (sig == NULL) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_new failed\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\tprintf(\"================================================================================\\n\");\n+\tprintf(\"Sample computation for signature %s\\n\", sig->method_name);\n+\tprintf(\"================================================================================\\n\");\n+\n+\tpublic_key = malloc(sig->length_public_key + 2 * sizeof(magic_t));\n+\tmessage = malloc(message_len + 2 * sizeof(magic_t));\n+\tsignature = malloc(sig->length_signature + 2 * sizeof(magic_t));\n+\tif ((public_key == NULL) || (message == NULL) || (signature == NULL)) {\n+\t\tfprintf(stderr, \"ERROR: malloc failed\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\t// Define the secret key object\n+\tsecret_key = OQS_SECRET_KEY_new(method_name);\n+\tsecret_key->data = (void *)filestem;\n+\tsecret_key->lock_key = lock_sk_key;\n+\tsecret_key->release_key = release_sk_key;\n+\tif (mode == SAVING) {\n+\t\tsecret_key->save_secret_key = sk_file_write;\n+\t} else {\n+\t\tsecret_key->save_secret_key = do_nothing_save;\n+\t}\n+\n+\tif (secret_key == NULL) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SECRET_KEY_new failed\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\t/**\n+\t * Magic numbers are not inserted into the secret key because for we need an\n+\t * OQS_SECRET_KEY object for the secret key. The secret key byte array is an attribute\n+\t * of the object whose size gets assigend when new() is called.\n+\t */\n+\n+\t// Set the magic numbers before\n+\tmemcpy(public_key, magic.val, sizeof(magic_t));\n+\tmemcpy(message, magic.val, sizeof(magic_t));\n+\tmemcpy(signature, magic.val, sizeof(magic_t));\n+\n+\tpublic_key += sizeof(magic_t);\n+\tmessage += sizeof(magic_t);\n+\tsignature += sizeof(magic_t);\n+\n+\t// and after\n+\tmemcpy(public_key + sig->length_public_key, magic.val, sizeof(magic_t));\n+\tmemcpy(message + message_len, magic.val, sizeof(magic_t));\n+\tmemcpy(signature + sig->length_signature, magic.val, sizeof(magic_t));\n+\n+\t// =================================== KEYPAIR / FILE READ =========================================\n+\n+\tOQS_randombytes(message, message_len);\n+\tOQS_TEST_CT_DECLASSIFY(message, message_len);\n+\n+\tif (mode == READING) {\n+\t\tstrcpy(filename, filestem);\n+\t\tprepend(filename, DIRECTORY_PLUS_PREFIX);\n+\n+\t\t// Public Key\n+\t\tstrcat(filename, PUBLIC_KEY_EXT);\n+\t\tFILE *pub_key = fopen(filename, \"rb\");\n+\t\tif (pub_key == NULL) {\n+\t\t\trc = OQS_ERROR;\n+\t\t}\n+\t\tfor (unsigned int i = 0; i < sig->length_public_key; i++) {\n+\t\t\tuint8_t readin;\n+\t\t\tif (fscanf(pub_key, \"%2hhx\", &readin) != 1) {\n+\t\t\t\trc = OQS_ERROR;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tpublic_key[i] = readin;\n+\t\t}\n+\t\tfclose(pub_key);\n+\n+\t\t// Private Key\n+\t\tfilename[strlen(filename) - strlen(PUBLIC_KEY_EXT)] = '\\0';\n+\t\tstrcat(filename, PRIVATE_KEY_EXT);\n+\t\tFILE *prv_key = fopen(filename, \"rb\");\n+\t\tif (prv_key == NULL) {\n+\t\t\trc = OQS_ERROR;\n+\t\t}\n+\t\tfor (unsigned int i = 0; i < secret_key->length_secret_key; i++) {\n+\t\t\tuint8_t readin;\n+\t\t\tif (fscanf(pub_key, \"%2hhx\", &readin) != 1) {\n+\t\t\t\trc = OQS_ERROR;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tsecret_key->secret_key[i] = readin;\n+\t\t}\n+\t\tfclose(prv_key);\n+\t} else {\n+\t\trc = OQS_SIG_STFL_keypair(sig, public_key, secret_key);\n+\t}\n+\tOQS_TEST_CT_DECLASSIFY(&rc, sizeof rc);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tif (mode == READING) {\n+\t\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL read from file failed\\n\");\n+\t\t} else {\n+\t\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_keypair failed\\n\");\n+\t\t}\n+\t\tgoto err;\n+\t}\n+\n+\t// Save the keypair to the specified filestem\n+\tif (mode == SAVING) {\n+\t\t// Private Key\n+\t\tsecret_key->save_secret_key(secret_key);\n+\n+\t\t// Public Key\n+\t\tstrcpy(filename, filestem);\n+\t\tstrcat(filename, PUBLIC_KEY_EXT);\n+\t\tFILE *pub_key = fopen(filename, \"w+\");\n+\t\tif (pub_key == NULL) {\n+\t\t\tfprintf(stderr, \"ERROR: fopen failed.\\n\");\n+\t\t\trc = OQS_ERROR;\n+\t\t\tgoto err;\n+\t\t}\n+\n+\t\tfor (unsigned int i = 0; i < sig->length_public_key; i++) {\n+\t\t\tif (fputc(public_key[i], pub_key) == EOF) {\n+\t\t\t\treturn OQS_ERROR;\n+\t\t\t}\n+\t\t}\n+\t\tfclose(pub_key);\n+\t}\n+\n+\t// ===========================================================================================\n+\n+\n+\t// ====================================== SIGNING =============================================\n+\n+\trc = OQS_SIG_STFL_sign(sig, signature, &signature_len, message, message_len, secret_key);\n+\tOQS_TEST_CT_DECLASSIFY(&rc, sizeof rc);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_sign failed\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\t// ===========================================================================================\n+\n+\n+\t// =================================== VERIFICATION I =========================================\n+\n+\tOQS_TEST_CT_DECLASSIFY(public_key, sig->length_public_key);\n+\tOQS_TEST_CT_DECLASSIFY(signature, signature_len);\n+\trc = OQS_SIG_STFL_verify(sig, message, message_len, signature, signature_len, public_key);\n+\tOQS_TEST_CT_DECLASSIFY(&rc, sizeof rc);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_verify failed\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\t// ===========================================================================================\n+\n+\n+\t// ============================ VERIFICATION II (failure) =====================================\n+\n+\t/* modify the signature to invalidate it */\n+\tOQS_randombytes(signature, signature_len);\n+\tOQS_TEST_CT_DECLASSIFY(signature, signature_len);\n+\trc = OQS_SIG_STFL_verify(sig, message, message_len, signature, signature_len, public_key);\n+\tOQS_TEST_CT_DECLASSIFY(&rc, sizeof rc);\n+\tif (rc != OQS_ERROR) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_verify should have failed!\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\t// ===========================================================================================\n+\n+#ifndef OQS_ENABLE_TEST_CONSTANT_TIME\n+\t/* check magic values */\n+\tint rv = memcmp(public_key + sig->length_public_key, magic.val, sizeof(magic_t));\n+\trv |= memcmp(message + message_len, magic.val, sizeof(magic_t));\n+\trv |= memcmp(signature + sig->length_signature, magic.val, sizeof(magic_t));\n+\trv |= memcmp(public_key - sizeof(magic_t), magic.val, sizeof(magic_t));\n+\trv |= memcmp(message - sizeof(magic_t), magic.val, sizeof(magic_t));\n+\trv |= memcmp(signature - sizeof(magic_t), magic.val, sizeof(magic_t));\n+\tif (rv) {\n+\t\tfprintf(stderr, \"ERROR: Magic numbers do not match\\n\");\n+\t\tgoto err;\n+\t}\n+#endif\n+\n+\tprintf(\"verification passes as expected\\n\");\n+\tret = OQS_SUCCESS;\n+\tgoto cleanup;\n+\n+err:\n+\tret = OQS_ERROR;\n+\n+cleanup:\n+\tif (secret_key != NULL) {\n+\t\tOQS_SECRET_KEY_free(secret_key);\n+\t}\n+\tOQS_MEM_insecure_free(public_key - sizeof(magic_t));\n+\tOQS_MEM_insecure_free(message - sizeof(magic_t));\n+\tOQS_MEM_insecure_free(signature - sizeof(magic_t));\n+\n+\tOQS_SIG_STFL_free(sig);\n+\n+\treturn ret;\n+}\n+\n+#ifdef OQS_ENABLE_TEST_CONSTANT_TIME\n+static void TEST_SIG_randombytes(uint8_t *random_array, size_t bytes_to_read) {\n+\t// We can't make direct calls to the system randombytes on some platforms,\n+\t// so we have to swap out the OQS_randombytes provider.\n+\tOQS_randombytes_switch_algorithm(\"system\");\n+\tOQS_randombytes(random_array, bytes_to_read);\n+\tOQS_randombytes_custom_algorithm(&TEST_SIG_randombytes);\n+\n+\t// OQS_TEST_CT_CLASSIFY tells Valgrind's memcheck tool to issue a warning if\n+\t// the program branches on any byte that depends on random_array. This helps us\n+\t// identify timing side-channels, as these bytes often contain secret data.\n+\tOQS_TEST_CT_CLASSIFY(random_array, bytes_to_read);\n+}\n+#endif\n+\n+#if OQS_USE_PTHREADS_IN_TESTS\n+struct thread_data {\n+\tchar *alg_name;\n+\tchar mode_of_operation;\n+\tconst char *filestem;\n+\tOQS_STATUS rc;\n+};\n+\n+void *test_wrapper(void *arg) {\n+\tstruct thread_data *td = arg;\n+\ttd->rc = sig_stfl_test_correctness(td->alg_name, td->mode_of_operation, td->filestem);\n+\treturn NULL;\n+}\n+#endif\n+\n+int main(int argc, char **argv) {\n+\n+\tif (argc < 2) {\n+\t\tfprintf(stderr, \"Usage: test_sig_stfl algname [optional arguments]\\n\");\n+\t\tfprintf(stderr, \"  algname: \");\n+\t\tfor (size_t i = 0; i < OQS_SIG_STFL_algs_length; i++) {\n+\t\t\tif (i > 0) {\n+\t\t\t\tfprintf(stderr, \", \");\n+\t\t\t}\n+\t\t\tfprintf(stderr, \"%s\", OQS_SIG_STFL_alg_identifier(i));\n+\t\t}\n+\t\tfprintf(stderr, \"\\n\");\n+\t\tfprintf(stderr, \"  optional arguments:\\n\");\n+\t\tfprintf(stderr, \"    --save_key_to=<filestem_name> saves the keypair to a .pub/.prv pair in tests/saved_keys\\n\");\n+\t\tfprintf(stderr, \"    --read_key_from=<filestem_name> reads the keypair from a *.pub/*.prv pair in tests/saved_keys\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t}\n+\n+\tprint_system_info();\n+\n+\t// Check if the algorithm is supported\n+\tchar *alg_name = argv[1];\n+\tif (!OQS_SIG_STFL_alg_is_enabled(alg_name)) {\n+\t\tprintf(\"Signature algorithm %s not enabled!\\n\", alg_name);\n+\t\treturn EXIT_FAILURE;\n+\t}\n+\n+\t// Extract the mode of operation from the command line arguments\n+\tchar mode_of_operation = 'x';\n+\tchar *filestem = NULL;\n+\tif (argc > 2) {\n+\t\tchar argument[8];\n+\t\tstrncpy(argument, argv[2], 6);","path":"tests/test_sig_stfl.c","position":365,"original_position":372,"commit_id":"a603f1ab562feaacd11ce3a1fd0e47a95677e5ed","original_commit_id":"192efcaf43d1fb7a70de4dcb26f51513fa6bafcd","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"This may be why we are getting weird behaviour on 32 bit ubuntu. Right now you only copy 6 characters, but c strings need to include the null terminator.\r\n\r\nFrom the strncpy man page:\r\n```\r\nstrncpy() functions copy at most len characters from src into dst.  If src is less than len characters long, the remainder of dst is filled with ‘\\0’ characters.  Otherwise, dst is not terminated.\r\n```\r\n\r\nSo right now I think `argument` isn't null terminated so strcmp is probably going further along than you think it is thus causing all comparisons to be false.","created_at":"2022-08-15T20:11:41Z","updated_at":"2022-08-15T20:11:41Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1275#discussion_r946087442","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/946087442"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1275#discussion_r946087442"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/946087442/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":365,"original_line":372,"side":"RIGHT","in_reply_to_id":944530238},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275","id":1016544887,"node_id":"PR_kwDOA-eq3c48lz53","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1275","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1275.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1275.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1275","number":1275,"state":"open","locked":false,"title":"Addition of stateful hash-based signatures","user":{"login":"kj3moraes","id":25700338,"node_id":"MDQ6VXNlcjI1NzAwMzM4","avatar_url":"https://avatars.githubusercontent.com/u/25700338?v=4","gravatar_id":"","url":"https://api.github.com/users/kj3moraes","html_url":"https://github.com/kj3moraes","followers_url":"https://api.github.com/users/kj3moraes/followers","following_url":"https://api.github.com/users/kj3moraes/following{/other_user}","gists_url":"https://api.github.com/users/kj3moraes/gists{/gist_id}","starred_url":"https://api.github.com/users/kj3moraes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kj3moraes/subscriptions","organizations_url":"https://api.github.com/users/kj3moraes/orgs","repos_url":"https://api.github.com/users/kj3moraes/repos","events_url":"https://api.github.com/users/kj3moraes/events{/privacy}","received_events_url":"https://api.github.com/users/kj3moraes/received_events","type":"User","site_admin":false},"body":" ## Addition of XMSS to the codebase\r\n\r\nI have added code for ![XMSS](https://datatracker.ietf.org/doc/html/rfc8391) into the `src/sig_stateful` directory. The algorithm variants supported are :- \r\n* all the XMSS variants (SHA256, SHA512, SHAKE256, SHAKE512)\r\n* all the RFC recommended ![XMSS^MT variants](https://datatracker.ietf.org/doc/html/rfc8391#section-8). \r\n\r\nThe continuous integration tests pass and I have made the respective test files for testing the SIG_STFL API.\r\n","created_at":"2022-08-03T16:14:21Z","updated_at":"2022-08-15T20:11:41Z","closed_at":null,"merged_at":null,"merge_commit_sha":"e64671c17ebd5d20e9341248c7739f1f9673825e","assignee":null,"assignees":[],"requested_reviewers":[{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1275/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/a603f1ab562feaacd11ce3a1fd0e47a95677e5ed","head":{"label":"open-quantum-safe:km-stateful-hashbased-signatures","ref":"km-stateful-hashbased-signatures","sha":"a603f1ab562feaacd11ce3a1fd0e47a95677e5ed","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2022-08-14T20:51:09Z","pushed_at":"2022-08-15T17:22:36Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":139326,"stargazers_count":1017,"watchers_count":1017,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":283,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":24,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["cryptography","isogenies","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":283,"open_issues":24,"watchers":1017,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"42f36c2a1bf94d35afe8e0ca52cd3ffd187eb222","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2022-08-14T20:51:09Z","pushed_at":"2022-08-15T17:22:36Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":139326,"stargazers_count":1017,"watchers_count":1017,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":283,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":24,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["cryptography","isogenies","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":283,"open_issues":24,"watchers":1017,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1275"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1275"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1275/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1275/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/a603f1ab562feaacd11ce3a1fd0e47a95677e5ed"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2022-08-15T20:11:41Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
