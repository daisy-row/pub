{"id":"24832841305","type":"PushEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":218087071,"name":"open-quantum-safe/oqs-demos","url":"https://api.github.com/repos/open-quantum-safe/oqs-demos"},"payload":{"push_id":11451342313,"size":1,"distinct_size":1,"ref":"refs/heads/main","head":"471a84da29b5f6e5294fe1f3e489a20d70fb3821","before":"43d48f9e87aac74f0f5a65b1055ccaeedc35fba1","commits":[{"sha":"471a84da29b5f6e5294fe1f3e489a20d70fb3821","author":{"email":"57787676+baentsch@users.noreply.github.com","name":"Michael Baentsch"},"message":"adding CI for ngtcp2 (#160)","distinct":true,"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/commits/471a84da29b5f6e5294fe1f3e489a20d70fb3821"}]},"public":true,"created_at":"2022-10-26T06:07:16Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"24833737433","type":"PushEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"push_id":11451795924,"size":1,"distinct_size":1,"ref":"refs/heads/main","head":"f88e6237c53d481200f9bf80c7c5fe9cde5f6a74","before":"222374e0676a2b941e2f912a2a7d9ce5845c83a3","commits":[{"sha":"f88e6237c53d481200f9bf80c7c5fe9cde5f6a74","author":{"email":"jmschanck@gmail.com","name":"John Schanck"},"message":"Integer overflow leading to incorrect computation of sha3 (#1312)\n\nSuppose a user of the incremental SHA3 API absorbs 10 bytes, and then\r\nabsorbs 2^64 - 10 bytes. At the beginning of the second\r\n`keccak_inc_absorb` call, the 25th element of the Keccak state is equal\r\nto 10, and there is a uint64_t overflow in\r\n```\r\nif (s[25] && mlen + s[25] >= r)\r\n```\r\nwhich causes the branch to be skipped. Later code assumes that mlen >= r\r\nimplies that s[25] = 0, and calls\r\n```\r\n(*Keccak_AddBytes_ptr)(s, m, 0, r);\r\n```\r\nwith third argument 0 instead of s[25]. This call modifies the wrong\r\nelements of the Keccak state, which leads to an incorrect result.\r\n\r\nI went looking for bugs of this form because of CVE-2022-37454, but this\r\none is not a security concern. It is also largely theoretical since it\r\ninvolves processing close to 2^64 bytes.","distinct":true,"url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits/f88e6237c53d481200f9bf80c7c5fe9cde5f6a74"}]},"public":true,"created_at":"2022-10-26T07:05:07Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
