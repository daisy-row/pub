{"id":"37834765843","type":"PullRequestReviewCommentEvent","actor":{"id":39264796,"login":"SWilson4","display_login":"SWilson4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","avatar_url":"https://avatars.githubusercontent.com/u/39264796?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293300","pull_request_review_id":2023837364,"id":1580293300,"node_id":"PRRC_kwDOA-eq3c5eMVy0","diff_hunk":"@@ -0,0 +1,177 @@\n+// SPDX-License-Identifier: (Apache-2.0 OR MIT) AND CC0-1.0\n+\n+#include <oqs/oqs.h>\n+#include <string.h>\n+#include <stdbool.h>\n+#include \"sig_stfl_xmss.h\"\n+\n+#if defined(__GNUC__) || defined(__clang__)\n+#define XMSS_UNUSED_ATT __attribute__((unused))\n+#else\n+#define XMSS_UNUSED_ATT\n+#endif\n+\n+extern inline OQS_SIG_STFL_SECRET_KEY *OQS_SECRET_KEY_XMSS_new(size_t length_secret_key) {\n+\n+\t// Initialize the secret key in the heap with adequate memory\n+\tOQS_SIG_STFL_SECRET_KEY *sk = malloc(sizeof(OQS_SIG_STFL_SECRET_KEY));\n+\tif (sk == NULL) {\n+\t\treturn NULL;\n+\t}\n+\tmemset(sk, 0, sizeof(OQS_SIG_STFL_SECRET_KEY));\n+\n+\tsk->length_secret_key = length_secret_key;\n+\n+\t// Secret serialize/deserialize function\n+\tsk->serialize_key = OQS_SECRET_KEY_XMSS_serialize_key;\n+\tsk->deserialize_key = OQS_SECRET_KEY_XMSS_deserialize_key;\n+\n+\t// Initialize the key with length_secret_key amount of bytes.\n+\tsk->secret_key_data = (uint8_t *)malloc(sk->length_secret_key * sizeof(uint8_t));\n+\n+\tif (sk->secret_key_data == NULL) {\n+\t\tOQS_MEM_insecure_free(sk);\n+\t\treturn NULL;\n+\t}\n+\n+\tmemset(sk->secret_key_data, 0, sk->length_secret_key);\n+\n+\t// Set application specific context\n+\tsk->context = NULL;\n+\n+\t// Point to associated OQS_SIG_STFL object\n+\tsk->sig = NULL;","path":"src/sig_stfl/xmss/sig_stfl_xmss_secret_key_functions.c","commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","original_commit_id":"af1077034a34cd7f2173a4bb6b9c79a9328e07e5","user":{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},"body":"I've removed the `sig` member with the latest commit.","created_at":"2024-04-26T00:40:17Z","updated_at":"2024-04-26T00:40:18Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293300","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293300"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293300"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293300/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":43,"side":"RIGHT","in_reply_to_id":1566429804,"original_position":43,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T00:40:18Z","closed_at":null,"merged_at":null,"merge_commit_sha":"857ee284b0c312b2552d7ac09acda372277265d4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T00:40:17Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37834776790","type":"PullRequestReviewCommentEvent","actor":{"id":39264796,"login":"SWilson4","display_login":"SWilson4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","avatar_url":"https://avatars.githubusercontent.com/u/39264796?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293638","pull_request_review_id":2023837768,"id":1580293638,"node_id":"PRRC_kwDOA-eq3c5eMV4G","diff_hunk":"@@ -0,0 +1,813 @@\n+// SPDX-License-Identifier: MIT\n+\n+#include <string.h>\n+#include <oqs/oqs.h>\n+#include \"sig_stfl_lms.h\"\n+#include \"external/config.h\"\n+#include \"external/hss_verify_inc.h\"\n+#include \"external/hss_sign_inc.h\"\n+#include \"external/hss.h\"\n+#include \"external/endian.h\"\n+#include \"external/hss_internal.h\"\n+#include \"sig_stfl_lms_wrap.h\"\n+\n+#ifdef __GNUC__\n+#define UNUSED __attribute__((unused))\n+#else\n+#define UNUSED\n+#endif\n+\n+#define DEFAULT_AUX_DATA 10916   /* Use 10+k of aux data (which works well */\n+/* with the above default parameter set)  */\n+/**\n+ * @brief OQS_LMS_KEY object for HSS key pair\n+ */\n+\n+typedef struct OQS_LMS_KEY_DATA {\n+\n+\t/* Tree levels. */\n+\tuint32_t levels;\n+\n+\t/* Array, 8 levels max, of LMS types */\n+\tparam_set_t lm_type[8];\n+\n+\t/* Array, 8 levels max, of LM OTS types */\n+\tparam_set_t lm_ots_type[8];\n+\n+\t/* LMS public key */\n+\tuint8_t public_key[60];\n+\n+\t/* Length of aux data */\n+\tsize_t len_aux_data;\n+\t/* internal nodes info of the Merkle tree */\n+\tuint8_t *aux_data;\n+\n+\t/* Length of sec_key */\n+\tsize_t len_sec_key;\n+\n+\t/* secret key data */\n+\tuint8_t *sec_key;\n+\n+\t/* app specific */\n+\tvoid *context;\n+} oqs_lms_key_data;\n+\n+#ifndef OQS_ALLOW_LMS_KEY_AND_SIG_GEN\n+OQS_API OQS_STATUS OQS_SIG_STFL_alg_lms_sign(UNUSED uint8_t *signature, UNUSED size_t *signature_length, UNUSED const uint8_t *message,\n+        UNUSED size_t message_len, UNUSED OQS_SIG_STFL_SECRET_KEY *secret_key) {\n+\treturn OQS_ERROR;\n+}\n+#else\n+OQS_API OQS_STATUS OQS_SIG_STFL_alg_lms_sign(uint8_t *signature, size_t *signature_length, const uint8_t *message,\n+        size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key) {\n+\tOQS_STATUS status = OQS_ERROR;\n+\tOQS_STATUS rc_keyupdate = OQS_ERROR;\n+\toqs_lms_key_data *lms_key_data = NULL;\n+\tuint8_t *sk_key_buf = NULL;\n+\tsize_t sk_key_buf_len = 0;\n+\tvoid *context;\n+\n+\tif (secret_key == NULL || message == NULL || signature == NULL || signature_length == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\t/* Lock secret to ensure OTS use */\n+\tif ((secret_key->lock_key) && (secret_key->mutex)) {\n+\t\tsecret_key->lock_key(secret_key->mutex);\n+\t}\n+\n+\t/*\n+\t * Don't even attempt signing without a way to safe the updated private key\n+\t */\n+\tif (secret_key->secure_store_scrt_key == NULL) {\n+\t\tfprintf(stderr, \"No Secure-store set for secret key.\\n.\");\n+\t\tgoto err;\n+\t}\n+\n+\tlms_key_data = (oqs_lms_key_data *)secret_key->secret_key_data;\n+\tif (lms_key_data == NULL) {\n+\t\tgoto err;\n+\t}\n+\n+\tif (oqs_sig_stfl_lms_sign(secret_key, signature,\n+\t                          signature_length,\n+\t                          message, message_len) != 0) {\n+\t\tgoto err;\n+\t}\n+\n+\t/*\n+\t * serialize and securely store the updated private key\n+\t * but, delete signature and the serialized key other wise\n+\t */\n+\n+\trc_keyupdate = oqs_serialize_lms_key(&sk_key_buf, &sk_key_buf_len, secret_key);\n+\tif (rc_keyupdate != OQS_SUCCESS) {\n+\t\tgoto err;\n+\t}\n+\n+\tcontext = secret_key->context;\n+\trc_keyupdate = secret_key->secure_store_scrt_key(sk_key_buf, sk_key_buf_len, context);\n+\tif (rc_keyupdate != OQS_SUCCESS) {\n+\t\tgoto err;\n+\t}\n+\n+\tstatus = OQS_SUCCESS;\n+\tgoto passed;\n+\n+err:\n+\tif (*signature_length) {\n+\t\tmemset(signature, 0, *signature_length);\n+\t}\n+\t*signature_length = 0;\n+\n+passed:\n+\tOQS_MEM_secure_free(sk_key_buf, sk_key_buf_len);\n+\n+\t/* Unlock secret to ensure OTS use */\n+\tif ((secret_key->unlock_key) && (secret_key->mutex)) {\n+\t\tsecret_key->unlock_key(secret_key->mutex);\n+\t}\n+\treturn status;\n+}\n+#endif\n+\n+OQS_API OQS_STATUS OQS_SIG_STFL_alg_lms_verify(const uint8_t *message, size_t message_len,\n+        const uint8_t *signature, size_t signature_len, const uint8_t *public_key) {\n+\n+\tif (message == NULL || signature == NULL || public_key == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tif (oqs_sig_stfl_lms_verify(message, message_len,\n+\t                            signature, signature_len,\n+\t                            public_key) != 0 ) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\treturn OQS_SUCCESS;\n+}\n+\n+OQS_API OQS_STATUS OQS_SIG_STFL_lms_sigs_left(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key) {\n+\tOQS_STATUS status;\n+\tuint8_t *priv_key = NULL;\n+\tunsigned long long total_sigs = 0;\n+\tsequence_t current_count = 0;\n+\toqs_lms_key_data *oqs_key_data = NULL;\n+\n+\tif (remain == NULL  || secret_key == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tstatus = OQS_SIG_STFL_lms_sigs_total(&total_sigs, secret_key);\n+\tif (status != OQS_SUCCESS) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\t/* Lock secret key to ensure data integrity use */\n+\tif ((secret_key->lock_key) && (secret_key->mutex)) {\n+\t\tsecret_key->lock_key(secret_key->mutex);\n+\t}\n+\n+\toqs_key_data = secret_key->secret_key_data;\n+\tif (oqs_key_data == NULL) {\n+\t\tgoto err;\n+\t}\n+\tpriv_key = oqs_key_data->sec_key;\n+\tif (priv_key == NULL) {\n+\t\tgoto err;\n+\t}\n+\n+\tcurrent_count = get_bigendian(priv_key + PRIVATE_KEY_INDEX, PRIVATE_KEY_INDEX_LEN /*0, 8 */);\n+\t*remain =  (total_sigs - (unsigned long long)current_count);\n+\n+err:\n+\t/* Unlock secret key */\n+\tif ((secret_key->unlock_key) && (secret_key->mutex)) {\n+\t\tsecret_key->unlock_key(secret_key->mutex);\n+\t}\n+\treturn OQS_SUCCESS;\n+}\n+\n+OQS_API OQS_STATUS OQS_SIG_STFL_lms_sigs_total(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key) {\n+\n+\tuint8_t *priv_key = NULL;\n+\toqs_lms_key_data *oqs_key_data = NULL;\n+\tstruct hss_working_key *working_key = NULL;\n+\n+\tif (total == NULL  || secret_key == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\toqs_key_data = secret_key->secret_key_data;\n+\tif (!oqs_key_data) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tpriv_key = oqs_key_data->sec_key;\n+\tif (!priv_key) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tworking_key = hss_load_private_key(NULL, priv_key,\n+\t                                   0,\n+\t                                   NULL,\n+\t                                   0,\n+\t                                   0);\n+\tif (!working_key) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\t*total = (unsigned long long)working_key->max_count;\n+\thss_free_working_key(working_key);\n+\treturn OQS_SUCCESS;\n+}\n+\n+/* LMS wrapper functions use internal OIDs to\n+ * identify the parameter set to be used\n+ */\n+\n+bool LMS_randombytes(void *buffer, size_t length) {\n+\n+\tOQS_randombytes((uint8_t *)buffer, length);\n+\treturn true;\n+}\n+\n+#ifndef OQS_ALLOW_LMS_KEY_AND_SIG_GEN\n+int oqs_sig_stfl_lms_keypair(UNUSED uint8_t *pk, UNUSED OQS_SIG_STFL_SECRET_KEY *sk, UNUSED const uint32_t oid) {\n+\treturn -1;\n+}\n+#else\n+int oqs_sig_stfl_lms_keypair(uint8_t *pk, OQS_SIG_STFL_SECRET_KEY *sk, const uint32_t oid) {\n+\n+\tint ret = -1;\n+\tbool b_ret;\n+\tint parse_err = 0;\n+\n+\tsize_t len_public_key = 60;\n+\toqs_lms_key_data *oqs_key_data = NULL;\n+\n+\tif (!pk || !sk || !oid) {\n+\t\treturn -1;\n+\t}\n+\n+\tif (sk->secret_key_data) {\n+\t\t//this means a key pair has already been recreated\n+\t\t//TODO log error.\n+\t\treturn -1;\n+\t}\n+\n+\toqs_key_data = malloc(sizeof(oqs_lms_key_data));\n+\tif (oqs_key_data == NULL) {\n+\t\treturn -1;\n+\t}\n+\n+\tmemset(oqs_key_data, 0, sizeof(oqs_lms_key_data));\n+\tif (sk->length_secret_key == 0) {\n+\t\tOQS_MEM_insecure_free(oqs_key_data);\n+\t\toqs_key_data = NULL;\n+\t\treturn -1;\n+\t}\n+\n+\toqs_key_data->levels = 1;\n+\toqs_key_data->len_sec_key = sk->length_secret_key;\n+\toqs_key_data->sec_key = (uint8_t *)malloc(sk->length_secret_key * sizeof(uint8_t));\n+\tif (oqs_key_data->sec_key == NULL) {\n+\t\tOQS_MEM_insecure_free(oqs_key_data);\n+\t\toqs_key_data = NULL;\n+\t\treturn -1;\n+\t}\n+\n+\tmemset(oqs_key_data->sec_key, 0, sk->length_secret_key);\n+\n+\t//Aux Data\n+\tsize_t len_aux_data = DEFAULT_AUX_DATA;\n+\tuint8_t *aux_data =  malloc(sizeof(uint8_t) * len_aux_data);\n+\tif (aux_data == NULL) {\n+\t\tOQS_MEM_insecure_free( oqs_key_data->sec_key);\n+\t\tOQS_MEM_insecure_free(oqs_key_data);\n+\t\treturn -1;\n+\t}\n+\n+\toqs_key_data->aux_data = aux_data;\n+\toqs_key_data->len_aux_data = len_aux_data;\n+\toqs_key_data->context = sk->context;\n+\n+\t/* Set lms param set */\n+\tswitch (oid) {\n+\tcase OQS_LMS_ID_sha256_h5_w1:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W1;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h5_w2:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h5_w4:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h5_w8:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\n+\tcase OQS_LMS_ID_sha256_h10_w1:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W1;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w2:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w4:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w8:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\n+\tcase OQS_LMS_ID_sha256_h15_w1:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W1;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w2:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w4:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w8:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\n+\tcase OQS_LMS_ID_sha256_h20_w1:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W1;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w2:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w4:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w8:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\n+\tcase OQS_LMS_ID_sha256_h25_w1:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H25;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W1;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h25_w2:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H25;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h25_w4:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H25;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h25_w8:\n+\t\toqs_key_data->lm_type[0] = LMS_SHA256_N32_H25;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h5_w8_h5_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w8_h5_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w2_h10_w2:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W2;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W2;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w4_h5_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w4_h10_w4:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W4;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W4;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h10_w8_h10_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w8_h5_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w8_h10_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h15_w8_h15_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w8_h5_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H5;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w8_h10_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H10;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w8_h15_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H15;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tcase OQS_LMS_ID_sha256_h20_w8_h20_w8:\n+\t\toqs_key_data->levels = 2;\n+\t\toqs_key_data->lm_type[0]     = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[0] = LMOTS_SHA256_N32_W8;\n+\t\toqs_key_data->lm_type[1]     = LMS_SHA256_N32_H20;\n+\t\toqs_key_data->lm_ots_type[1] = LMOTS_SHA256_N32_W8;\n+\t\tbreak;\n+\tdefault:\n+\t\toqs_key_data->lm_type[0] = 0;\n+\t\toqs_key_data->lm_ots_type[0] = 0;\n+\t\tparse_err = 1;\n+\t\tbreak;\n+\t}\n+\n+\tif (parse_err) {\n+\t\tOQS_MEM_insecure_free(oqs_key_data->sec_key);\n+\t\tOQS_MEM_insecure_free(oqs_key_data->aux_data);\n+\t\tOQS_MEM_insecure_free(oqs_key_data);\n+\t\toqs_key_data = NULL;\n+\t\treturn -1;\n+\t}\n+\n+\t/*\n+\t * This creates a private key (and the correspond public key, and optionally\n+\t * the aux data for that key)\n+\t * Parameters:\n+\t * generate_random - the function to be called to generate randomness.  This\n+\t *       is assumed to be a pointer to a cryptographically secure rng,\n+\t *       otherwise all security is lost.  This function is expected to fill\n+\t *       output with 'length' uniformly distributed bits, and return 1 on\n+\t *       success, 0 if something went wrong\n+\t * levels - the number of levels for the key pair (2-8)\n+\t * lm_type - an array of the LM registry entries for the various levels;\n+\t *      entry 0 is the topmost\n+\t * lm_ots_type - an array of the LM-OTS registry entries for the various\n+\t *      levels; again, entry 0 is the topmost\n+\t * update_private_key, context - the function that is called when the\n+\t *      private key is generated; it is expected to store it to secure NVRAM\n+\t *      If this is NULL, then the context pointer is reinterpretted to mean\n+\t *      where in RAM the private key is expected to be placed\n+\t * public_key - where to store the public key\n+\t * len_public_key - length of the above buffer; see hss_get_public_key_len\n+\t *      if you need a hint.\n+\t * aux_data - where to store the optional aux data.  This is not required, but\n+\t *      if provided, can be used to speed up the hss_generate_working_key\n+\t *      process;\n+\t * len_aux_data - the length of the above buffer.  This is not fixed length;\n+\t *      the function will run different time/memory trade-offs based on the\n+\t *      length provided\n+\t *\n+\t * This returns true on success, false on failure\n+\t */\n+\tb_ret = hss_generate_private_key(\n+\t            LMS_randombytes,\n+\t            oqs_key_data->levels,\n+\t            oqs_key_data->lm_type,\n+\t            oqs_key_data->lm_ots_type,\n+\t            NULL, //File handler function?\n+\t            oqs_key_data->sec_key,\n+\t            oqs_key_data->public_key, len_public_key,\n+\t            oqs_key_data->aux_data, oqs_key_data->len_aux_data,\n+\t            NULL);\n+\tif (b_ret) {\n+\t\tmemcpy(pk, oqs_key_data->public_key, len_public_key);\n+\t\tsk->secret_key_data = oqs_key_data;\n+\t} else {\n+\t\tOQS_MEM_secure_free(oqs_key_data->sec_key, sk->length_secret_key * sizeof(uint8_t));\n+\t\tOQS_MEM_insecure_free(oqs_key_data->aux_data);\n+\t\tOQS_MEM_insecure_free(oqs_key_data);\n+\t\toqs_key_data = NULL;\n+\t\treturn -1;\n+\t}\n+\n+\t/* TODO: store key pair, file handler */\n+\n+\tret = 0;\n+\treturn ret;\n+}\n+#endif\n+\n+#ifndef OQS_ALLOW_LMS_KEY_AND_SIG_GEN\n+int oqs_sig_stfl_lms_sign(UNUSED OQS_SIG_STFL_SECRET_KEY *sk, UNUSED uint8_t *sm, UNUSED size_t *smlen,\n+                          UNUSED const uint8_t *m, UNUSED size_t mlen) {\n+\treturn -1;\n+}\n+#else\n+int oqs_sig_stfl_lms_sign(OQS_SIG_STFL_SECRET_KEY *sk,\n+                          uint8_t *sm, size_t *smlen,\n+                          const uint8_t *m, size_t mlen) {\n+\n+\tsize_t sig_len;\n+\tbool status;\n+\tuint8_t *sig = NULL;\n+\tuint8_t *priv_key = NULL;\n+\toqs_lms_key_data *oqs_key_data = NULL;\n+\tstruct hss_working_key *w = NULL;\n+\tstruct hss_sign_inc ctx;\n+\tif (sk) {\n+\t\toqs_key_data = sk->secret_key_data;\n+\t\tpriv_key = oqs_key_data->sec_key;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+\tw = hss_load_private_key(NULL, priv_key,\n+\t                         0,\n+\t                         NULL,\n+\t                         0,\n+\t                         0);\n+\tif (!w) {\n+\t\thss_free_working_key(w);\n+\t\treturn 0;\n+\t}\n+\n+\t/* Now, go through the file list, and generate the signatures for each */\n+\n+\t/* Look up the signature length */\n+\n+\tsig_len = hss_get_signature_len_from_working_key(w);\n+\tif (sig_len == 0) {\n+\t\thss_free_working_key(w);\n+\t\treturn 0;\n+\t}\n+\n+\tsig = malloc(sig_len);\n+\tif (!sig) {\n+\t\thss_free_working_key(w);\n+\t\treturn -1;\n+\t}\n+\n+\t(void)hss_sign_init(\n+\t    &ctx,                 /* Incremental signing context */\n+\t    w,                    /* Working key */\n+\t    NULL,                 /* Routine to update the */\n+\t    priv_key,       /* private key */\n+\t    sig, sig_len,         /* Where to place the signature */\n+\t    0);\n+\n+\t(void)hss_sign_update(\n+\t    &ctx,           /* Incremental signing context */\n+\t    m,         /* Next piece of the message */\n+\t    mlen);             /* Length of this piece */\n+\n+\tstatus = hss_sign_finalize(\n+\t             &ctx,               /* Incremental signing context */\n+\t             w,                  /* Working key */\n+\t             sig,                /* Signature */\n+\t             0);\n+\n+\tif (!status) {\n+\t\thss_free_working_key(w);\n+\t\tOQS_MEM_insecure_free(sig);\n+\t\treturn -1;\n+\t}\n+\n+\t*smlen = sig_len;\n+\tmemcpy(sm, sig, sig_len);\n+\tOQS_MEM_insecure_free(sig);\n+\thss_free_working_key(w);\n+\n+\treturn 0;\n+}\n+#endif\n+\n+int oqs_sig_stfl_lms_verify(const uint8_t *m, size_t mlen,\n+                            const uint8_t *sm, size_t smlen,\n+                            const uint8_t *pk) {\n+\n+\tstruct hss_validate_inc ctx;\n+\t(void)hss_validate_signature_init(\n+\t    &ctx,               /* Incremental validate context */\n+\t    (const unsigned char *)pk,                /* Public key */\n+\t    (const unsigned char *)sm,\n+\t    (size_t)smlen,       /* Signature */\n+\t    0);                 /* Use the defaults for extra info */\n+\n+\t(void)hss_validate_signature_update(\n+\t    &ctx,           /* Incremental validate context */\n+\t    (const void *) m,        /* Next piece of the message */\n+\t    (size_t)mlen);             /* Length of this piece */\n+\n+\tbool status = hss_validate_signature_finalize(\n+\t                  &ctx,               /* Incremental validate context */\n+\t                  (const unsigned char *)sm,                /* Signature */\n+\t                  0);                 /* Use the defaults for extra info */\n+\n+\tif (status) {\n+\t\t/* Signature verified */\n+\t\treturn 0;\n+\t} else {\n+\t\t/* signature NOT verified */\n+\t\treturn -1;\n+\t}\n+}\n+\n+void oqs_secret_lms_key_free(OQS_SIG_STFL_SECRET_KEY *sk) {\n+\tif (sk == NULL) {\n+\t\treturn;\n+\t}\n+\n+\t//TODO: cleanup lock_key\n+\n+\tif (sk->secret_key_data) {\n+\t\toqs_lms_key_data *key_data = (oqs_lms_key_data *)sk->secret_key_data;\n+\t\tif (key_data) {\n+\t\t\tOQS_MEM_secure_free(key_data->sec_key, key_data->len_sec_key);\n+\t\t\tkey_data->sec_key = NULL;\n+\n+\t\t\tOQS_MEM_secure_free(key_data->aux_data, key_data->len_aux_data);\n+\t\t}\n+\n+\t\tOQS_MEM_insecure_free(key_data);\n+\t\tsk->secret_key_data = NULL;\n+\t}\n+}\n+\n+/*\n+ * Convert LMS secret key object to byte string\n+ * Writes secret key + aux data if present\n+ */\n+OQS_STATUS oqs_serialize_lms_key(uint8_t **sk_key, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk) {\n+\n+\tif (sk == NULL || sk_len == NULL || sk_key == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\toqs_lms_key_data *lms_key_data = sk->secret_key_data;\n+\n+\tif (lms_key_data == NULL || lms_key_data->sec_key == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tsize_t key_len = lms_key_data->len_aux_data + lms_key_data->len_sec_key;\n+\n+\tif (key_len == 0) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tuint8_t *sk_key_buf = malloc(key_len * sizeof(uint8_t));\n+\n+\tif (sk_key_buf == NULL) {\n+\t\treturn OQS_ERROR;\n+\t}\n+\t/* pass back serialized data */\n+\t/*\n+\t * Serialized data is sec_key followed by aux data\n+\t * So aux data begins after buffer top + sec_key length\n+\t */\n+\tif (lms_key_data->len_sec_key != 0) {\n+\t\tmemcpy(sk_key_buf, lms_key_data->sec_key, lms_key_data->len_sec_key);\n+\t}\n+\n+\tif (lms_key_data->len_aux_data != 0) {\n+\t\tmemcpy(sk_key_buf + lms_key_data->len_sec_key, lms_key_data->aux_data, lms_key_data->len_aux_data);\n+\t}\n+\n+\t*sk_key = sk_key_buf;\n+\t*sk_len = sk->length_secret_key + lms_key_data->len_aux_data;\n+\n+\treturn OQS_SUCCESS;\n+}\n+\n+/*\n+ * Convert LMS byte string to secret key object\n+ * Writes secret key + aux data if present\n+ * key_len is priv key length + aux length\n+ */\n+OQS_STATUS oqs_deserialize_lms_key(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context) {","path":"src/sig_stfl/lms/sig_stfl_lms_functions.c","commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","original_commit_id":"af1077034a34cd7f2173a4bb6b9c79a9328e07e5","user":{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},"body":"We never actually used `sk->sig` anywhere, so I just removed it.","created_at":"2024-04-26T00:40:59Z","updated_at":"2024-04-26T00:40:59Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293638","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293638"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293638"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293638/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":731,"original_line":731,"side":"RIGHT","in_reply_to_id":1566492997,"original_position":731,"position":731,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T00:40:59Z","closed_at":null,"merged_at":null,"merge_commit_sha":"857ee284b0c312b2552d7ac09acda372277265d4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T00:40:59Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37834784276","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293808","pull_request_review_id":2023838045,"id":1580293808,"node_id":"PRRC_kwDOA-eq3c5eMV6w","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);","path":"src/sig_stfl/sig_stfl.h","commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"Should this actually be\r\n`OQS_SIG_STFL_SECRET_KEY_serialize`?","created_at":"2024-04-26T00:41:29Z","updated_at":"2024-04-26T00:41:29Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293808","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293808"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580293808"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580293808/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":637,"original_line":637,"side":"RIGHT","original_position":637,"position":637,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T00:41:29Z","closed_at":null,"merged_at":null,"merge_commit_sha":"857ee284b0c312b2552d7ac09acda372277265d4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T00:41:29Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37834794012","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580294069","pull_request_review_id":2023838415,"id":1580294069,"node_id":"PRRC_kwDOA-eq3c5eMV-1","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"Same as above. Shouldn't this be:\r\n`OQS_SIG_STFL_SECRET_KEY_deserialize`","created_at":"2024-04-26T00:42:08Z","updated_at":"2024-04-26T00:42:08Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580294069","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580294069"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1580294069"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1580294069/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":653,"original_line":653,"side":"RIGHT","original_position":653,"position":653,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T00:42:08Z","closed_at":null,"merged_at":null,"merge_commit_sha":"857ee284b0c312b2552d7ac09acda372277265d4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T00:39:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143340,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":47,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":47,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/528f2d851c8184b9f8d0f52c1099a7d70ac91b7b"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T00:42:08Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37844162426","type":"PullRequestReviewCommentEvent","actor":{"id":15230534,"login":"iyanmv","display_login":"iyanmv","gravatar_id":"","url":"https://api.github.com/users/iyanmv","avatar_url":"https://avatars.githubusercontent.com/u/15230534?"},"repo":{"id":334511511,"name":"open-quantum-safe/oqs-provider","url":"https://api.github.com/repos/open-quantum-safe/oqs-provider"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580669896","pull_request_review_id":2024426047,"id":1580669896,"node_id":"PRRC_kwDOE_A9l85eNxvI","diff_hunk":"@@ -0,0 +1,411 @@\n+#","path":"scripts/openssl-ca-no-oqsprovider.cnf","commit_id":"07cc236f8473a0d44aed237e47f84173eed464ca","original_commit_id":"9e25bd82cadea04bbedf3e1060df1ef457f36f20","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"body":"Yes, that is correct. [Last commit](https://github.com/open-quantum-safe/oqs-provider/pull/400/commits/07cc236f8473a0d44aed237e47f84173eed464ca) does that. Should I squash both commits into just one?","created_at":"2024-04-26T08:27:01Z","updated_at":"2024-04-26T08:27:01Z","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580669896","pull_request_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580669896"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580669896"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580669896/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":1,"side":"RIGHT","in_reply_to_id":1580605741,"original_position":1,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","id":1829920321,"node_id":"PR_kwDOE_A9l85tEl5B","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400","diff_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.diff","patch_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400","number":400,"state":"open","locked":false,"title":"Add PKCS#12 test","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"body":"OpenSSL supports PKCS#12 and can be used to store in a single encrypted file the private key and certificate.\r\n\r\nThis PR adds a new test that tries to generate `.p12` files for all the supported algorithms. ~~Unfortunately, when `oqsprovider` is not enabled and `-provider oqsprovider` is used instead, this generation fails. OpenSSL still returns 0, so I don't know how to catch this issue. Ideas are welcome.~~\r\n\r\nWhen `oqsprovider` is not enabled in the config file, errors are printed in the terminal, but the `.p12` files are still generated and `openssl` exits with 0.\r\n\r\nSee also: https://github.com/open-quantum-safe/oqs-provider/discussions/398\r\n\r\n","created_at":"2024-04-18T16:17:18Z","updated_at":"2024-04-26T08:27:01Z","closed_at":null,"merged_at":null,"merge_commit_sha":"2d134b24955c6fcbd502582c374e9e55bc7d2b86","assignee":null,"assignees":[],"requested_reviewers":[],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/07cc236f8473a0d44aed237e47f84173eed464ca","head":{"label":"iyanmv:add-pkcs12-test","ref":"add-pkcs12-test","sha":"07cc236f8473a0d44aed237e47f84173eed464ca","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"repo":{"id":788532180,"node_id":"R_kgDOLwAL1A","name":"oqs-provider","full_name":"iyanmv/oqs-provider","private":false,"owner":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"html_url":"https://github.com/iyanmv/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":true,"url":"https://api.github.com/repos/iyanmv/oqs-provider","forks_url":"https://api.github.com/repos/iyanmv/oqs-provider/forks","keys_url":"https://api.github.com/repos/iyanmv/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/iyanmv/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/iyanmv/oqs-provider/teams","hooks_url":"https://api.github.com/repos/iyanmv/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/iyanmv/oqs-provider/events","assignees_url":"https://api.github.com/repos/iyanmv/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/iyanmv/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/tags","blobs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/iyanmv/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/iyanmv/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/iyanmv/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/iyanmv/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscription","commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/iyanmv/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/iyanmv/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/iyanmv/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/iyanmv/oqs-provider/merges","archive_url":"https://api.github.com/repos/iyanmv/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/iyanmv/oqs-provider/downloads","issues_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/iyanmv/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/iyanmv/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/iyanmv/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/iyanmv/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/iyanmv/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/iyanmv/oqs-provider/deployments","created_at":"2024-04-18T15:44:08Z","updated_at":"2024-04-18T15:44:08Z","pushed_at":"2024-04-26T08:26:10Z","git_url":"git://github.com/iyanmv/oqs-provider.git","ssh_url":"git@github.com:iyanmv/oqs-provider.git","clone_url":"https://github.com/iyanmv/oqs-provider.git","svn_url":"https://github.com/iyanmv/oqs-provider","homepage":"https://openquantumsafe.org","size":661,"stargazers_count":0,"watchers_count":0,"language":null,"has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":0,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":0,"open_issues":0,"watchers":0,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"d7e7f19fd8dfe214e420c5da01c43672eb2a4722","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":334511511,"node_id":"MDEwOlJlcG9zaXRvcnkzMzQ1MTE1MTE=","name":"oqs-provider","full_name":"open-quantum-safe/oqs-provider","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider","forks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/deployments","created_at":"2021-01-30T21:07:15Z","updated_at":"2024-04-25T17:04:32Z","pushed_at":"2024-04-26T08:26:12Z","git_url":"git://github.com/open-quantum-safe/oqs-provider.git","ssh_url":"git@github.com:open-quantum-safe/oqs-provider.git","clone_url":"https://github.com/open-quantum-safe/oqs-provider.git","svn_url":"https://github.com/open-quantum-safe/oqs-provider","homepage":"https://openquantumsafe.org","size":715,"stargazers_count":149,"watchers_count":149,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":65,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":35,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","openssl","post-quantum","provider"],"visibility":"public","forks":65,"open_issues":35,"watchers":149,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/07cc236f8473a0d44aed237e47f84173eed464ca"}},"author_association":"NONE","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T08:27:01Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37845009607","type":"PullRequestReviewCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":334511511,"name":"open-quantum-safe/oqs-provider","url":"https://api.github.com/repos/open-quantum-safe/oqs-provider"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580705517","pull_request_review_id":2024486557,"id":1580705517,"node_id":"PRRC_kwDOE_A9l85eN6bt","diff_hunk":"@@ -14,6 +14,7 @@ test/oqs_test_groups\n # test artifacts\n tmp\n interop.log\n+scripts/openssl-ca-no-oqsprovider.cnf","path":".gitignore","commit_id":"8a427c2d7c94a6753c668985163b729e8b6ad5cc","original_commit_id":"8a427c2d7c94a6753c668985163b729e8b6ad5cc","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"body":"This also could be avoided by `rm`ing the temp cnf file in/at the end of the test script (or creating it in the tmp folder).","created_at":"2024-04-26T08:52:52Z","updated_at":"2024-04-26T08:52:52Z","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580705517","pull_request_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580705517"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580705517"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580705517/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":17,"original_line":17,"side":"RIGHT","original_position":4,"position":4,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","id":1829920321,"node_id":"PR_kwDOE_A9l85tEl5B","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400","diff_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.diff","patch_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400","number":400,"state":"open","locked":false,"title":"Add PKCS#12 test","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"body":"OpenSSL supports PKCS#12 and can be used to store in a single encrypted file the private key and certificate.\r\n\r\nThis PR adds a new test that tries to generate `.p12` files for all the supported algorithms. ~~Unfortunately, when `oqsprovider` is not enabled and `-provider oqsprovider` is used instead, this generation fails. OpenSSL still returns 0, so I don't know how to catch this issue. Ideas are welcome.~~\r\n\r\nWhen `oqsprovider` is not enabled in the config file, errors are printed in the terminal, but the `.p12` files are still generated and `openssl` exits with 0.\r\n\r\nSee also: https://github.com/open-quantum-safe/oqs-provider/discussions/398\r\n\r\n","created_at":"2024-04-18T16:17:18Z","updated_at":"2024-04-26T08:52:52Z","closed_at":null,"merged_at":null,"merge_commit_sha":"cb13649be99e31f86d225cf55818db2a29ad47be","assignee":null,"assignees":[],"requested_reviewers":[],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/8a427c2d7c94a6753c668985163b729e8b6ad5cc","head":{"label":"iyanmv:add-pkcs12-test","ref":"add-pkcs12-test","sha":"8a427c2d7c94a6753c668985163b729e8b6ad5cc","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"repo":{"id":788532180,"node_id":"R_kgDOLwAL1A","name":"oqs-provider","full_name":"iyanmv/oqs-provider","private":false,"owner":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"html_url":"https://github.com/iyanmv/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":true,"url":"https://api.github.com/repos/iyanmv/oqs-provider","forks_url":"https://api.github.com/repos/iyanmv/oqs-provider/forks","keys_url":"https://api.github.com/repos/iyanmv/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/iyanmv/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/iyanmv/oqs-provider/teams","hooks_url":"https://api.github.com/repos/iyanmv/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/iyanmv/oqs-provider/events","assignees_url":"https://api.github.com/repos/iyanmv/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/iyanmv/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/tags","blobs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/iyanmv/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/iyanmv/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/iyanmv/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/iyanmv/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscription","commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/iyanmv/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/iyanmv/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/iyanmv/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/iyanmv/oqs-provider/merges","archive_url":"https://api.github.com/repos/iyanmv/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/iyanmv/oqs-provider/downloads","issues_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/iyanmv/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/iyanmv/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/iyanmv/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/iyanmv/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/iyanmv/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/iyanmv/oqs-provider/deployments","created_at":"2024-04-18T15:44:08Z","updated_at":"2024-04-18T15:44:08Z","pushed_at":"2024-04-26T08:27:51Z","git_url":"git://github.com/iyanmv/oqs-provider.git","ssh_url":"git@github.com:iyanmv/oqs-provider.git","clone_url":"https://github.com/iyanmv/oqs-provider.git","svn_url":"https://github.com/iyanmv/oqs-provider","homepage":"https://openquantumsafe.org","size":661,"stargazers_count":0,"watchers_count":0,"language":null,"has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":0,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":0,"open_issues":0,"watchers":0,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"d7e7f19fd8dfe214e420c5da01c43672eb2a4722","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":334511511,"node_id":"MDEwOlJlcG9zaXRvcnkzMzQ1MTE1MTE=","name":"oqs-provider","full_name":"open-quantum-safe/oqs-provider","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider","forks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/deployments","created_at":"2021-01-30T21:07:15Z","updated_at":"2024-04-25T17:04:32Z","pushed_at":"2024-04-26T08:27:53Z","git_url":"git://github.com/open-quantum-safe/oqs-provider.git","ssh_url":"git@github.com:open-quantum-safe/oqs-provider.git","clone_url":"https://github.com/open-quantum-safe/oqs-provider.git","svn_url":"https://github.com/open-quantum-safe/oqs-provider","homepage":"https://openquantumsafe.org","size":715,"stargazers_count":149,"watchers_count":149,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":65,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":35,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","openssl","post-quantum","provider"],"visibility":"public","forks":65,"open_issues":35,"watchers":149,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/8a427c2d7c94a6753c668985163b729e8b6ad5cc"}},"author_association":"NONE","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T08:52:52Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37845906343","type":"PullRequestReviewCommentEvent","actor":{"id":15230534,"login":"iyanmv","display_login":"iyanmv","gravatar_id":"","url":"https://api.github.com/users/iyanmv","avatar_url":"https://avatars.githubusercontent.com/u/15230534?"},"repo":{"id":334511511,"name":"open-quantum-safe/oqs-provider","url":"https://api.github.com/repos/open-quantum-safe/oqs-provider"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580738142","pull_request_review_id":2024538283,"id":1580738142,"node_id":"PRRC_kwDOE_A9l85eOCZe","diff_hunk":"@@ -14,6 +14,7 @@ test/oqs_test_groups\n # test artifacts\n tmp\n interop.log\n+scripts/openssl-ca-no-oqsprovider.cnf","path":".gitignore","commit_id":"eb258ff01ca95c5a7341e67625da72699cea5156","original_commit_id":"8a427c2d7c94a6753c668985163b729e8b6ad5cc","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"body":"Oh, sure. Changed now.","created_at":"2024-04-26T09:19:34Z","updated_at":"2024-04-26T09:19:35Z","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580738142","pull_request_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580738142"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400#discussion_r1580738142"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments/1580738142/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":17,"side":"RIGHT","in_reply_to_id":1580705517,"original_position":4,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400","id":1829920321,"node_id":"PR_kwDOE_A9l85tEl5B","html_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400","diff_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.diff","patch_url":"https://github.com/open-quantum-safe/oqs-provider/pull/400.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400","number":400,"state":"open","locked":false,"title":"Add PKCS#12 test","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"body":"OpenSSL supports PKCS#12 and can be used to store in a single encrypted file the private key and certificate.\r\n\r\nThis PR adds a new test that tries to generate `.p12` files for all the supported algorithms. ~~Unfortunately, when `oqsprovider` is not enabled and `-provider oqsprovider` is used instead, this generation fails. OpenSSL still returns 0, so I don't know how to catch this issue. Ideas are welcome.~~\r\n\r\nWhen `oqsprovider` is not enabled in the config file, errors are printed in the terminal, but the `.p12` files are still generated and `openssl` exits with 0.\r\n\r\nSee also: https://github.com/open-quantum-safe/oqs-provider/discussions/398\r\n\r\n","created_at":"2024-04-18T16:17:18Z","updated_at":"2024-04-26T09:19:35Z","closed_at":null,"merged_at":null,"merge_commit_sha":"4049e939fe0d51d817a2a54a308451a7848b3552","assignee":null,"assignees":[],"requested_reviewers":[],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/eb258ff01ca95c5a7341e67625da72699cea5156","head":{"label":"iyanmv:add-pkcs12-test","ref":"add-pkcs12-test","sha":"eb258ff01ca95c5a7341e67625da72699cea5156","user":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"repo":{"id":788532180,"node_id":"R_kgDOLwAL1A","name":"oqs-provider","full_name":"iyanmv/oqs-provider","private":false,"owner":{"login":"iyanmv","id":15230534,"node_id":"MDQ6VXNlcjE1MjMwNTM0","avatar_url":"https://avatars.githubusercontent.com/u/15230534?v=4","gravatar_id":"","url":"https://api.github.com/users/iyanmv","html_url":"https://github.com/iyanmv","followers_url":"https://api.github.com/users/iyanmv/followers","following_url":"https://api.github.com/users/iyanmv/following{/other_user}","gists_url":"https://api.github.com/users/iyanmv/gists{/gist_id}","starred_url":"https://api.github.com/users/iyanmv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iyanmv/subscriptions","organizations_url":"https://api.github.com/users/iyanmv/orgs","repos_url":"https://api.github.com/users/iyanmv/repos","events_url":"https://api.github.com/users/iyanmv/events{/privacy}","received_events_url":"https://api.github.com/users/iyanmv/received_events","type":"User","site_admin":false},"html_url":"https://github.com/iyanmv/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":true,"url":"https://api.github.com/repos/iyanmv/oqs-provider","forks_url":"https://api.github.com/repos/iyanmv/oqs-provider/forks","keys_url":"https://api.github.com/repos/iyanmv/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/iyanmv/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/iyanmv/oqs-provider/teams","hooks_url":"https://api.github.com/repos/iyanmv/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/iyanmv/oqs-provider/events","assignees_url":"https://api.github.com/repos/iyanmv/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/iyanmv/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/tags","blobs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/iyanmv/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/iyanmv/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/iyanmv/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/iyanmv/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/iyanmv/oqs-provider/subscription","commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/iyanmv/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/iyanmv/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/iyanmv/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/iyanmv/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/iyanmv/oqs-provider/merges","archive_url":"https://api.github.com/repos/iyanmv/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/iyanmv/oqs-provider/downloads","issues_url":"https://api.github.com/repos/iyanmv/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/iyanmv/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/iyanmv/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/iyanmv/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/iyanmv/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/iyanmv/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/iyanmv/oqs-provider/deployments","created_at":"2024-04-18T15:44:08Z","updated_at":"2024-04-18T15:44:08Z","pushed_at":"2024-04-26T09:18:15Z","git_url":"git://github.com/iyanmv/oqs-provider.git","ssh_url":"git@github.com:iyanmv/oqs-provider.git","clone_url":"https://github.com/iyanmv/oqs-provider.git","svn_url":"https://github.com/iyanmv/oqs-provider","homepage":"https://openquantumsafe.org","size":661,"stargazers_count":0,"watchers_count":0,"language":null,"has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":0,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":0,"open_issues":0,"watchers":0,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"d7e7f19fd8dfe214e420c5da01c43672eb2a4722","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":334511511,"node_id":"MDEwOlJlcG9zaXRvcnkzMzQ1MTE1MTE=","name":"oqs-provider","full_name":"open-quantum-safe/oqs-provider","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/oqs-provider","description":"OpenSSL 3 provider containing post-quantum algorithms","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/oqs-provider","forks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/oqs-provider/deployments","created_at":"2021-01-30T21:07:15Z","updated_at":"2024-04-25T17:04:32Z","pushed_at":"2024-04-26T09:18:17Z","git_url":"git://github.com/open-quantum-safe/oqs-provider.git","ssh_url":"git@github.com:open-quantum-safe/oqs-provider.git","clone_url":"https://github.com/open-quantum-safe/oqs-provider.git","svn_url":"https://github.com/open-quantum-safe/oqs-provider","homepage":"https://openquantumsafe.org","size":715,"stargazers_count":149,"watchers_count":149,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":65,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":35,"license":{"key":"mit","name":"MIT License","spdx_id":"MIT","url":"https://api.github.com/licenses/mit","node_id":"MDc6TGljZW5zZTEz"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","openssl","post-quantum","provider"],"visibility":"public","forks":65,"open_issues":35,"watchers":149,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400"},"html":{"href":"https://github.com/open-quantum-safe/oqs-provider/pull/400"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/issues/400/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/pulls/400/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/oqs-provider/statuses/eb258ff01ca95c5a7341e67625da72699cea5156"}},"author_association":"NONE","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T09:19:34Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37854572451","type":"PullRequestReviewCommentEvent","actor":{"id":39264796,"login":"SWilson4","display_login":"SWilson4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","avatar_url":"https://avatars.githubusercontent.com/u/39264796?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581066508","pull_request_review_id":2025102718,"id":1581066508,"node_id":"PRRC_kwDOA-eq3c5ePSkM","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);","path":"src/sig_stfl/sig_stfl.h","commit_id":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},"body":"Good catch!","created_at":"2024-04-26T13:48:47Z","updated_at":"2024-04-26T13:48:47Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581066508","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581066508"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581066508"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581066508/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":637,"side":"RIGHT","in_reply_to_id":1580293808,"original_position":637,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T13:48:47Z","closed_at":null,"merged_at":null,"merge_commit_sha":"3e28bb162803ca431e6a670924ba28a233bb4ab4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T13:48:47Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37854743166","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581072703","pull_request_review_id":2025113292,"id":1581072703,"node_id":"PRRC_kwDOA-eq3c5ePUE_","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"@SWilson4 one last nit, then I'll approve. What are your thoughts on `key_len` and `sk_buf` getting swapped in order and renamed so they are closer to `serialize`?\r\n\r\n```suggestion\r\nOQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, const uint8_t *sk_buf, size_t sk_len, void *context);\r\n```","created_at":"2024-04-26T13:53:38Z","updated_at":"2024-04-26T13:53:38Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581072703","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581072703"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581072703"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581072703/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":653,"side":"RIGHT","original_position":653,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T13:53:38Z","closed_at":null,"merged_at":null,"merge_commit_sha":"3e28bb162803ca431e6a670924ba28a233bb4ab4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T13:53:38Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37855975276","type":"PullRequestReviewCommentEvent","actor":{"id":39264796,"login":"SWilson4","display_login":"SWilson4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","avatar_url":"https://avatars.githubusercontent.com/u/39264796?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581117402","pull_request_review_id":2025187836,"id":1581117402,"node_id":"PRRC_kwDOA-eq3c5ePe_a","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},"body":"Makes sense to me.","created_at":"2024-04-26T14:27:05Z","updated_at":"2024-04-26T14:27:05Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581117402","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581117402"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581117402"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581117402/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":653,"side":"RIGHT","in_reply_to_id":1581072703,"original_position":653,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T14:27:05Z","closed_at":null,"merged_at":null,"merge_commit_sha":"3e28bb162803ca431e6a670924ba28a233bb4ab4","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"ab42c83ea2e0ffc56372ea4b2fd13c85098a038f","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T13:48:45Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/ab42c83ea2e0ffc56372ea4b2fd13c85098a038f"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T14:27:05Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37856184607","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581124571","pull_request_review_id":2025202062,"id":1581124571,"node_id":"PRRC_kwDOA-eq3c5ePgvb","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"74d4c58bef0ded6d54c995b0aad15a08c98257af","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"Can we rename `key_len` to `sk_len`? `key` is 'undefined' atm. Or even if we rename it to `sk_buf_len` or something. :)","created_at":"2024-04-26T14:32:43Z","updated_at":"2024-04-26T14:32:44Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581124571","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581124571"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581124571"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581124571/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":653,"side":"RIGHT","in_reply_to_id":1581072703,"original_position":653,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T14:32:44Z","closed_at":null,"merged_at":null,"merge_commit_sha":"ea16f70748de8db3486912ebef06acaba354d949","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/74d4c58bef0ded6d54c995b0aad15a08c98257af","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"74d4c58bef0ded6d54c995b0aad15a08c98257af","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T14:28:09Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T14:28:09Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/74d4c58bef0ded6d54c995b0aad15a08c98257af"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T14:32:43Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37856208928","type":"PullRequestReviewCommentEvent","actor":{"id":6541356,"login":"Martyrshot","display_login":"Martyrshot","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","avatar_url":"https://avatars.githubusercontent.com/u/6541356?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581125380","pull_request_review_id":2025204340,"id":1581125380,"node_id":"PRRC_kwDOA-eq3c5ePg8E","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"74d4c58bef0ded6d54c995b0aad15a08c98257af","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"Martyrshot","id":6541356,"node_id":"MDQ6VXNlcjY1NDEzNTY=","avatar_url":"https://avatars.githubusercontent.com/u/6541356?v=4","gravatar_id":"","url":"https://api.github.com/users/Martyrshot","html_url":"https://github.com/Martyrshot","followers_url":"https://api.github.com/users/Martyrshot/followers","following_url":"https://api.github.com/users/Martyrshot/following{/other_user}","gists_url":"https://api.github.com/users/Martyrshot/gists{/gist_id}","starred_url":"https://api.github.com/users/Martyrshot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Martyrshot/subscriptions","organizations_url":"https://api.github.com/users/Martyrshot/orgs","repos_url":"https://api.github.com/users/Martyrshot/repos","events_url":"https://api.github.com/users/Martyrshot/events{/privacy}","received_events_url":"https://api.github.com/users/Martyrshot/received_events","type":"User","site_admin":false},"body":"But I prefer `sk_len` because that's what it's called in `serialize`","created_at":"2024-04-26T14:33:23Z","updated_at":"2024-04-26T14:33:23Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581125380","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"COLLABORATOR","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581125380"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581125380"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581125380/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":653,"side":"RIGHT","in_reply_to_id":1581072703,"original_position":653,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T14:33:23Z","closed_at":null,"merged_at":null,"merge_commit_sha":"ea16f70748de8db3486912ebef06acaba354d949","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/74d4c58bef0ded6d54c995b0aad15a08c98257af","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"74d4c58bef0ded6d54c995b0aad15a08c98257af","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T14:28:09Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T14:28:09Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143346,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/74d4c58bef0ded6d54c995b0aad15a08c98257af"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T14:33:23Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37857480632","type":"PullRequestReviewCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":746904584,"name":"open-quantum-safe/tsc","url":"https://api.github.com/repos/open-quantum-safe/tsc"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581170661","pull_request_review_id":2025284802,"id":1581170661,"node_id":"PRRC_kwDOLITcCM5ePr_l","diff_hunk":"@@ -4,36 +4,102 @@\n \n TSC members\n \n-- [ ] [Norman Ashley (Cisco)](https://github.com/ashman-p)\n-- [ ] [Michael Baentsch (independent contributor)](https://github.com/baentsch)\n-- [ ] [Thomas Bailleux (SandboxAQ)](https://github.com/)\n-- [ ] [Basil Hess (IBM Research)](https://github.com/bhess)\n-- [ ] [Brian Jarvis (AWS)](https://github.com/brian-jarvis-aws)\n-- [ ] [Christian Paquin (Microsoft Research)](https://github.com/christianpaquin)\n-- [ ] [Douglas Stebila (University of Waterloo)](https://github.com/dstebila)\n+- [X] [Norman Ashley (Cisco)](https://github.com/ashman-p)\n+- [X] [Michael Baentsch (independent contributor)](https://github.com/baentsch)\n+- [X] [Thomas Bailleux (SandboxAQ)](https://github.com/)\n+- [X] [Basil Hess (IBM Research)](https://github.com/bhess)\n+- [X] [Brian Jarvis (AWS)](https://github.com/brian-jarvis-aws)\n+- [X] [Christian Paquin (Microsoft Research)](https://github.com/christianpaquin)\n+- [X] [Douglas Stebila (University of Waterloo)](https://github.com/dstebila)\n \n Other attendees\n \n+ - [x] [Nigel Jones (IBM)](https://github.com/planetf1)\n+ - [x] [Alex Bozarth (IBM)](https://github.com/ajbozarth)\n+ - [x] [Michael (Max)imilien, IBM](https://github.com/maximilien)\n+ - [x] [Ry Jones (Linux Foundation)](https://github.com/ryjones)\n+ - [x] [Hart Montgomery, Linux Foundation](https://github.com/hartm)\n+\n+\n ## 1. Chair's introduction\n+ - The chair thanks members for being patient as we get up and running\n+ - TSC aims to be consensus driven & friendly\n+ - TSC will discuss & make strategic decisions on technical matters. Developer call handlers regular operational matters\n \n ## 2. Approve agenda\n \n+ - Agreed\n+\n ## 3. Appoint minute-taker\n \n+ - Nigel will take this week's notes. Agreed that we would ask at the beginning of each meeting & do in rotation.\n+\n ## 4. Approval of minutes of last meeting\n \n+- Last meeting's notes are open as [PR #14](https://github.com/open-quantum-safe/tsc/pull/14). Comments/reviewers invited. TSC members asked to approve. \n+- will use direct links to recordings in future minutes - portal not available to all (has been requested)\n+\n ## 5. Voting procedure\n \n+- [Issue #12](https://github.com/open-quantum-safe/tsc/issues/12) open for discussion\n+- online/async voting to allow broadest engagement\n+- open votes for technical matters\n+- differing opinions on whether personal matters (including voting such as ranking) should be public or secret, or referred up to the board.\n+- noted that most decisions consensus driven in any case\n+- mechanism - git (simple), [gitvote](https://github.com/cncf/gitvote), [Helios](https://vote.heliosvoting.org/) are possible options\n+- discussion to continue in [issue 12](https://github.com/open-quantum-safe/tsc/issues/12)\n+\n+\n ## 6. Addition of Vlad Gheorghiu to TSC\n \n+- Vlad is maintainer of language wrappers \n+- Intent had been he was in the TSC from launch\n+- Christan proposed, Basil seconded motion to add Vlad. Agreed by verbal vote of TSC members with no objections\n+\n ## 7. Meeting cadence\n \n+- Monthly still seems appropriate - lots of topics\n+- Two suggestions:\n+  - in PQCA TAC timeslot (alt. weeks) in off-week\n+  - offline poll to accommodate most TSC members, and consider time rotation to handle differing timezones. This may require a higher frequency than monthly\n+- Agreed poll will be conducted\n+\n ## 8. Report from TAC representative (Thomas)\n \n+- Project Lifecycle. \n+  - [Early draft](https://docs.google.com/document/d/1NV-0vNgXWdc81oqT0jv0C-9Funb8dySS06u90ghF-X4/edit)\n+  - PQCA TAC suggests oqs tsc review and develop as most active project.\n+  - objective is clarity for consumers as to what state the code is in - production, experimental, how good is security, maintenance - don't want to set wrong expectations. \n+  - Also covers adoption of new projects. Similar to apache incubation approach\n+  - may apply at sub-project or component level\n+  - should map existing oqs subprojects/components to proposal for validation\n+  - clear separation may require feature flags, restructuring of liboqs, additional projects etc\n+  - should delegate to OQS dev meeting to decide/discuss in github issues\n+  - Issue will be opened for followup\n+- Security\n+  - PQCA [setting up security workgroup](https://github.com/PQCA/TAC/issues/2)\n+  - Hoping to arrange presentation from [OSSF](https://openssf.org/) around [scorecard](https://securityscorecards.dev/) & other best practices. TSC members will be invited\n+  - Also Use of sigstore, CBOMs, SBOMs, vulnerability reporting process\n+\n ## 9. Does OQS-BoringSSL repository require a license exemption?\n \n+- [Issue #13](https://github.com/open-quantum-safe/tsc/issues/13) has background\n+- Current project charter requires contributions under MIT license\n+- Discussed allowing Apache 2.0 as an exception for this work, or changing charter to allow generally\n+- [Issue #17](https://github.com/open-quantum-safe/tsc/pull/17) for TSC members to vote on exception\n+","path":"meetings/2024-04-10/minutes.md","commit_id":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","original_commit_id":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"body":"Well, that was the context in which IBM/LF (think MM, but am not sure) made the remark. As I did not find another place in the minutes in which this was captured, I commented here.","created_at":"2024-04-26T15:09:23Z","updated_at":"2024-04-26T15:09:23Z","html_url":"https://github.com/open-quantum-safe/tsc/pull/18#discussion_r1581170661","pull_request_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581170661"},"html":{"href":"https://github.com/open-quantum-safe/tsc/pull/18#discussion_r1581170661"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581170661/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":90,"original_line":90,"side":"RIGHT","in_reply_to_id":1573263672,"original_position":94,"position":94,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18","id":1817599710,"node_id":"PR_kwDOLITcCM5sVl7e","html_url":"https://github.com/open-quantum-safe/tsc/pull/18","diff_url":"https://github.com/open-quantum-safe/tsc/pull/18.diff","patch_url":"https://github.com/open-quantum-safe/tsc/pull/18.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18","number":18,"state":"open","locked":false,"title":"Add 20240410 minutes","user":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"body":"Adds an initial version of the minutes from 2024-04-10\r\n\r\n@ryjones @dstebila can you point me to/share the meeting recording/transcript & I'll update with any omissions.","created_at":"2024-04-11T09:30:58Z","updated_at":"2024-04-26T15:09:23Z","closed_at":null,"merged_at":null,"merge_commit_sha":"c3fdbfd0e7a0616b2bde8f5dc372f7c45ad56636","assignee":null,"assignees":[],"requested_reviewers":[{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},{"login":"vsoftco","id":6188943,"node_id":"MDQ6VXNlcjYxODg5NDM=","avatar_url":"https://avatars.githubusercontent.com/u/6188943?v=4","gravatar_id":"","url":"https://api.github.com/users/vsoftco","html_url":"https://github.com/vsoftco","followers_url":"https://api.github.com/users/vsoftco/followers","following_url":"https://api.github.com/users/vsoftco/following{/other_user}","gists_url":"https://api.github.com/users/vsoftco/gists{/gist_id}","starred_url":"https://api.github.com/users/vsoftco/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vsoftco/subscriptions","organizations_url":"https://api.github.com/users/vsoftco/orgs","repos_url":"https://api.github.com/users/vsoftco/repos","events_url":"https://api.github.com/users/vsoftco/events{/privacy}","received_events_url":"https://api.github.com/users/vsoftco/received_events","type":"User","site_admin":false},{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},{"login":"brian-jarvis-aws","id":92757966,"node_id":"U_kgDOBYdfzg","avatar_url":"https://avatars.githubusercontent.com/u/92757966?v=4","gravatar_id":"","url":"https://api.github.com/users/brian-jarvis-aws","html_url":"https://github.com/brian-jarvis-aws","followers_url":"https://api.github.com/users/brian-jarvis-aws/followers","following_url":"https://api.github.com/users/brian-jarvis-aws/following{/other_user}","gists_url":"https://api.github.com/users/brian-jarvis-aws/gists{/gist_id}","starred_url":"https://api.github.com/users/brian-jarvis-aws/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/brian-jarvis-aws/subscriptions","organizations_url":"https://api.github.com/users/brian-jarvis-aws/orgs","repos_url":"https://api.github.com/users/brian-jarvis-aws/repos","events_url":"https://api.github.com/users/brian-jarvis-aws/events{/privacy}","received_events_url":"https://api.github.com/users/brian-jarvis-aws/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","head":{"label":"planetf1:minutes20240410","ref":"minutes20240410","sha":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","user":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"repo":{"id":785118643,"node_id":"R_kgDOLsv1sw","name":"oqstsc","full_name":"planetf1/oqstsc","private":false,"owner":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"html_url":"https://github.com/planetf1/oqstsc","description":"OQS Technical Steering Committee resources","fork":true,"url":"https://api.github.com/repos/planetf1/oqstsc","forks_url":"https://api.github.com/repos/planetf1/oqstsc/forks","keys_url":"https://api.github.com/repos/planetf1/oqstsc/keys{/key_id}","collaborators_url":"https://api.github.com/repos/planetf1/oqstsc/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/planetf1/oqstsc/teams","hooks_url":"https://api.github.com/repos/planetf1/oqstsc/hooks","issue_events_url":"https://api.github.com/repos/planetf1/oqstsc/issues/events{/number}","events_url":"https://api.github.com/repos/planetf1/oqstsc/events","assignees_url":"https://api.github.com/repos/planetf1/oqstsc/assignees{/user}","branches_url":"https://api.github.com/repos/planetf1/oqstsc/branches{/branch}","tags_url":"https://api.github.com/repos/planetf1/oqstsc/tags","blobs_url":"https://api.github.com/repos/planetf1/oqstsc/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/planetf1/oqstsc/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/planetf1/oqstsc/git/refs{/sha}","trees_url":"https://api.github.com/repos/planetf1/oqstsc/git/trees{/sha}","statuses_url":"https://api.github.com/repos/planetf1/oqstsc/statuses/{sha}","languages_url":"https://api.github.com/repos/planetf1/oqstsc/languages","stargazers_url":"https://api.github.com/repos/planetf1/oqstsc/stargazers","contributors_url":"https://api.github.com/repos/planetf1/oqstsc/contributors","subscribers_url":"https://api.github.com/repos/planetf1/oqstsc/subscribers","subscription_url":"https://api.github.com/repos/planetf1/oqstsc/subscription","commits_url":"https://api.github.com/repos/planetf1/oqstsc/commits{/sha}","git_commits_url":"https://api.github.com/repos/planetf1/oqstsc/git/commits{/sha}","comments_url":"https://api.github.com/repos/planetf1/oqstsc/comments{/number}","issue_comment_url":"https://api.github.com/repos/planetf1/oqstsc/issues/comments{/number}","contents_url":"https://api.github.com/repos/planetf1/oqstsc/contents/{+path}","compare_url":"https://api.github.com/repos/planetf1/oqstsc/compare/{base}...{head}","merges_url":"https://api.github.com/repos/planetf1/oqstsc/merges","archive_url":"https://api.github.com/repos/planetf1/oqstsc/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/planetf1/oqstsc/downloads","issues_url":"https://api.github.com/repos/planetf1/oqstsc/issues{/number}","pulls_url":"https://api.github.com/repos/planetf1/oqstsc/pulls{/number}","milestones_url":"https://api.github.com/repos/planetf1/oqstsc/milestones{/number}","notifications_url":"https://api.github.com/repos/planetf1/oqstsc/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/planetf1/oqstsc/labels{/name}","releases_url":"https://api.github.com/repos/planetf1/oqstsc/releases{/id}","deployments_url":"https://api.github.com/repos/planetf1/oqstsc/deployments","created_at":"2024-04-11T08:28:24Z","updated_at":"2024-04-11T08:28:24Z","pushed_at":"2024-04-25T15:46:25Z","git_url":"git://github.com/planetf1/oqstsc.git","ssh_url":"git@github.com:planetf1/oqstsc.git","clone_url":"https://github.com/planetf1/oqstsc.git","svn_url":"https://github.com/planetf1/oqstsc","homepage":"https://openquantumsafe.org/","size":119,"stargazers_count":0,"watchers_count":0,"language":null,"has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":0,"license":{"key":"cc-by-4.0","name":"Creative Commons Attribution 4.0 International","spdx_id":"CC-BY-4.0","url":"https://api.github.com/licenses/cc-by-4.0","node_id":"MDc6TGljZW5zZTI1"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":0,"open_issues":0,"watchers":0,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"af24ebe4b38b37729dff4217b0f82ff6659a3122","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":746904584,"node_id":"R_kgDOLITcCA","name":"tsc","full_name":"open-quantum-safe/tsc","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/tsc","description":"OQS Technical Steering Committee resources","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/tsc","forks_url":"https://api.github.com/repos/open-quantum-safe/tsc/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/tsc/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/tsc/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/tsc/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/tsc/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/tsc/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/tsc/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/tsc/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/tsc/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/tsc/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/tsc/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/tsc/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/tsc/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/tsc/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/tsc/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/tsc/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/tsc/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/tsc/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/tsc/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/tsc/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/tsc/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/tsc/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/tsc/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/tsc/deployments","created_at":"2024-01-22T22:27:14Z","updated_at":"2024-04-25T17:39:01Z","pushed_at":"2024-04-25T17:38:57Z","git_url":"git://github.com/open-quantum-safe/tsc.git","ssh_url":"git@github.com:open-quantum-safe/tsc.git","clone_url":"https://github.com/open-quantum-safe/tsc.git","svn_url":"https://github.com/open-quantum-safe/tsc","homepage":"https://openquantumsafe.org/","size":117,"stargazers_count":2,"watchers_count":2,"language":null,"has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":2,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":9,"license":{"key":"cc-by-4.0","name":"Creative Commons Attribution 4.0 International","spdx_id":"CC-BY-4.0","url":"https://api.github.com/licenses/cc-by-4.0","node_id":"MDc6TGljZW5zZTI1"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":2,"open_issues":9,"watchers":2,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18"},"html":{"href":"https://github.com/open-quantum-safe/tsc/pull/18"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b"}},"author_association":"CONTRIBUTOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T15:09:23Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37857648511","type":"PullRequestReviewCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":746904584,"name":"open-quantum-safe/tsc","url":"https://api.github.com/repos/open-quantum-safe/tsc"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581179431","pull_request_review_id":2025295309,"id":1581179431,"node_id":"PRRC_kwDOLITcCM5ePuIn","diff_hunk":"@@ -4,36 +4,102 @@\n \n TSC members\n \n-- [ ] [Norman Ashley (Cisco)](https://github.com/ashman-p)\n-- [ ] [Michael Baentsch (independent contributor)](https://github.com/baentsch)\n-- [ ] [Thomas Bailleux (SandboxAQ)](https://github.com/)\n-- [ ] [Basil Hess (IBM Research)](https://github.com/bhess)\n-- [ ] [Brian Jarvis (AWS)](https://github.com/brian-jarvis-aws)\n-- [ ] [Christian Paquin (Microsoft Research)](https://github.com/christianpaquin)\n-- [ ] [Douglas Stebila (University of Waterloo)](https://github.com/dstebila)\n+- [X] [Norman Ashley (Cisco)](https://github.com/ashman-p)\n+- [X] [Michael Baentsch (independent contributor)](https://github.com/baentsch)\n+- [X] [Thomas Bailleux (SandboxAQ)](https://github.com/)\n+- [X] [Basil Hess (IBM Research)](https://github.com/bhess)\n+- [X] [Brian Jarvis (AWS)](https://github.com/brian-jarvis-aws)\n+- [X] [Christian Paquin (Microsoft Research)](https://github.com/christianpaquin)\n+- [X] [Douglas Stebila (University of Waterloo)](https://github.com/dstebila)\n \n Other attendees\n \n+ - [x] [Nigel Jones (IBM)](https://github.com/planetf1)\n+ - [x] [Alex Bozarth (IBM)](https://github.com/ajbozarth)\n+ - [x] [Michael (Max)imilien, IBM](https://github.com/maximilien)\n+ - [x] [Ry Jones (Linux Foundation)](https://github.com/ryjones)\n+ - [x] [Hart Montgomery, Linux Foundation](https://github.com/hartm)\n+\n+\n ## 1. Chair's introduction\n+ - The chair thanks members for being patient as we get up and running\n+ - TSC aims to be consensus driven & friendly\n+ - TSC will discuss & make strategic decisions on technical matters. Developer call handlers regular operational matters\n \n ## 2. Approve agenda\n \n+ - Agreed\n+\n ## 3. Appoint minute-taker\n \n+ - Nigel will take this week's notes. Agreed that we would ask at the beginning of each meeting & do in rotation.\n+\n ## 4. Approval of minutes of last meeting\n \n+- Last meeting's notes are open as [PR #14](https://github.com/open-quantum-safe/tsc/pull/14). Comments/reviewers invited. TSC members asked to approve. \n+- will use direct links to recordings in future minutes - portal not available to all (has been requested)\n+\n ## 5. Voting procedure\n \n+- [Issue #12](https://github.com/open-quantum-safe/tsc/issues/12) open for discussion\n+- online/async voting to allow broadest engagement\n+- open votes for technical matters\n+- differing opinions on whether personal matters (including voting such as ranking) should be public or secret, or referred up to the board.\n+- noted that most decisions consensus driven in any case\n+- mechanism - git (simple), [gitvote](https://github.com/cncf/gitvote), [Helios](https://vote.heliosvoting.org/) are possible options\n+- discussion to continue in [issue 12](https://github.com/open-quantum-safe/tsc/issues/12)\n+\n+\n ## 6. Addition of Vlad Gheorghiu to TSC\n \n+- Vlad is maintainer of language wrappers \n+- Intent had been he was in the TSC from launch\n+- Christan proposed, Basil seconded motion to add Vlad. Agreed by verbal vote of TSC members with no objections\n+\n ## 7. Meeting cadence\n \n+- Monthly still seems appropriate - lots of topics\n+- Two suggestions:\n+  - in PQCA TAC timeslot (alt. weeks) in off-week\n+  - offline poll to accommodate most TSC members, and consider time rotation to handle differing timezones. This may require a higher frequency than monthly\n+- Agreed poll will be conducted\n+\n ## 8. Report from TAC representative (Thomas)\n \n+- Project Lifecycle. \n+  - [Early draft](https://docs.google.com/document/d/1NV-0vNgXWdc81oqT0jv0C-9Funb8dySS06u90ghF-X4/edit)\n+  - PQCA TAC suggests oqs tsc review and develop as most active project.\n+  - objective is clarity for consumers as to what state the code is in - production, experimental, how good is security, maintenance - don't want to set wrong expectations. \n+  - Also covers adoption of new projects. Similar to apache incubation approach\n+  - may apply at sub-project or component level","path":"meetings/2024-04-10/minutes.md","commit_id":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","original_commit_id":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"body":"\"must\" or \"needs to\" seems to be more suitable than \"will\" given the original word was \"may\". Anyway, the core of the matter is: What designations should be applied to which projects or components is unclear to me.","created_at":"2024-04-26T15:14:09Z","updated_at":"2024-04-26T15:14:09Z","html_url":"https://github.com/open-quantum-safe/tsc/pull/18#discussion_r1581179431","pull_request_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581179431"},"html":{"href":"https://github.com/open-quantum-safe/tsc/pull/18#discussion_r1581179431"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments/1581179431/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":74,"original_line":74,"side":"RIGHT","in_reply_to_id":1569261706,"original_position":78,"position":78,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18","id":1817599710,"node_id":"PR_kwDOLITcCM5sVl7e","html_url":"https://github.com/open-quantum-safe/tsc/pull/18","diff_url":"https://github.com/open-quantum-safe/tsc/pull/18.diff","patch_url":"https://github.com/open-quantum-safe/tsc/pull/18.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18","number":18,"state":"open","locked":false,"title":"Add 20240410 minutes","user":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"body":"Adds an initial version of the minutes from 2024-04-10\r\n\r\n@ryjones @dstebila can you point me to/share the meeting recording/transcript & I'll update with any omissions.","created_at":"2024-04-11T09:30:58Z","updated_at":"2024-04-26T15:14:09Z","closed_at":null,"merged_at":null,"merge_commit_sha":"c3fdbfd0e7a0616b2bde8f5dc372f7c45ad56636","assignee":null,"assignees":[],"requested_reviewers":[{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},{"login":"vsoftco","id":6188943,"node_id":"MDQ6VXNlcjYxODg5NDM=","avatar_url":"https://avatars.githubusercontent.com/u/6188943?v=4","gravatar_id":"","url":"https://api.github.com/users/vsoftco","html_url":"https://github.com/vsoftco","followers_url":"https://api.github.com/users/vsoftco/followers","following_url":"https://api.github.com/users/vsoftco/following{/other_user}","gists_url":"https://api.github.com/users/vsoftco/gists{/gist_id}","starred_url":"https://api.github.com/users/vsoftco/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vsoftco/subscriptions","organizations_url":"https://api.github.com/users/vsoftco/orgs","repos_url":"https://api.github.com/users/vsoftco/repos","events_url":"https://api.github.com/users/vsoftco/events{/privacy}","received_events_url":"https://api.github.com/users/vsoftco/received_events","type":"User","site_admin":false},{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},{"login":"brian-jarvis-aws","id":92757966,"node_id":"U_kgDOBYdfzg","avatar_url":"https://avatars.githubusercontent.com/u/92757966?v=4","gravatar_id":"","url":"https://api.github.com/users/brian-jarvis-aws","html_url":"https://github.com/brian-jarvis-aws","followers_url":"https://api.github.com/users/brian-jarvis-aws/followers","following_url":"https://api.github.com/users/brian-jarvis-aws/following{/other_user}","gists_url":"https://api.github.com/users/brian-jarvis-aws/gists{/gist_id}","starred_url":"https://api.github.com/users/brian-jarvis-aws/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/brian-jarvis-aws/subscriptions","organizations_url":"https://api.github.com/users/brian-jarvis-aws/orgs","repos_url":"https://api.github.com/users/brian-jarvis-aws/repos","events_url":"https://api.github.com/users/brian-jarvis-aws/events{/privacy}","received_events_url":"https://api.github.com/users/brian-jarvis-aws/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":null,"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","head":{"label":"planetf1:minutes20240410","ref":"minutes20240410","sha":"f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b","user":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"repo":{"id":785118643,"node_id":"R_kgDOLsv1sw","name":"oqstsc","full_name":"planetf1/oqstsc","private":false,"owner":{"login":"planetf1","id":7292002,"node_id":"MDQ6VXNlcjcyOTIwMDI=","avatar_url":"https://avatars.githubusercontent.com/u/7292002?v=4","gravatar_id":"","url":"https://api.github.com/users/planetf1","html_url":"https://github.com/planetf1","followers_url":"https://api.github.com/users/planetf1/followers","following_url":"https://api.github.com/users/planetf1/following{/other_user}","gists_url":"https://api.github.com/users/planetf1/gists{/gist_id}","starred_url":"https://api.github.com/users/planetf1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/planetf1/subscriptions","organizations_url":"https://api.github.com/users/planetf1/orgs","repos_url":"https://api.github.com/users/planetf1/repos","events_url":"https://api.github.com/users/planetf1/events{/privacy}","received_events_url":"https://api.github.com/users/planetf1/received_events","type":"User","site_admin":false},"html_url":"https://github.com/planetf1/oqstsc","description":"OQS Technical Steering Committee resources","fork":true,"url":"https://api.github.com/repos/planetf1/oqstsc","forks_url":"https://api.github.com/repos/planetf1/oqstsc/forks","keys_url":"https://api.github.com/repos/planetf1/oqstsc/keys{/key_id}","collaborators_url":"https://api.github.com/repos/planetf1/oqstsc/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/planetf1/oqstsc/teams","hooks_url":"https://api.github.com/repos/planetf1/oqstsc/hooks","issue_events_url":"https://api.github.com/repos/planetf1/oqstsc/issues/events{/number}","events_url":"https://api.github.com/repos/planetf1/oqstsc/events","assignees_url":"https://api.github.com/repos/planetf1/oqstsc/assignees{/user}","branches_url":"https://api.github.com/repos/planetf1/oqstsc/branches{/branch}","tags_url":"https://api.github.com/repos/planetf1/oqstsc/tags","blobs_url":"https://api.github.com/repos/planetf1/oqstsc/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/planetf1/oqstsc/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/planetf1/oqstsc/git/refs{/sha}","trees_url":"https://api.github.com/repos/planetf1/oqstsc/git/trees{/sha}","statuses_url":"https://api.github.com/repos/planetf1/oqstsc/statuses/{sha}","languages_url":"https://api.github.com/repos/planetf1/oqstsc/languages","stargazers_url":"https://api.github.com/repos/planetf1/oqstsc/stargazers","contributors_url":"https://api.github.com/repos/planetf1/oqstsc/contributors","subscribers_url":"https://api.github.com/repos/planetf1/oqstsc/subscribers","subscription_url":"https://api.github.com/repos/planetf1/oqstsc/subscription","commits_url":"https://api.github.com/repos/planetf1/oqstsc/commits{/sha}","git_commits_url":"https://api.github.com/repos/planetf1/oqstsc/git/commits{/sha}","comments_url":"https://api.github.com/repos/planetf1/oqstsc/comments{/number}","issue_comment_url":"https://api.github.com/repos/planetf1/oqstsc/issues/comments{/number}","contents_url":"https://api.github.com/repos/planetf1/oqstsc/contents/{+path}","compare_url":"https://api.github.com/repos/planetf1/oqstsc/compare/{base}...{head}","merges_url":"https://api.github.com/repos/planetf1/oqstsc/merges","archive_url":"https://api.github.com/repos/planetf1/oqstsc/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/planetf1/oqstsc/downloads","issues_url":"https://api.github.com/repos/planetf1/oqstsc/issues{/number}","pulls_url":"https://api.github.com/repos/planetf1/oqstsc/pulls{/number}","milestones_url":"https://api.github.com/repos/planetf1/oqstsc/milestones{/number}","notifications_url":"https://api.github.com/repos/planetf1/oqstsc/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/planetf1/oqstsc/labels{/name}","releases_url":"https://api.github.com/repos/planetf1/oqstsc/releases{/id}","deployments_url":"https://api.github.com/repos/planetf1/oqstsc/deployments","created_at":"2024-04-11T08:28:24Z","updated_at":"2024-04-11T08:28:24Z","pushed_at":"2024-04-25T15:46:25Z","git_url":"git://github.com/planetf1/oqstsc.git","ssh_url":"git@github.com:planetf1/oqstsc.git","clone_url":"https://github.com/planetf1/oqstsc.git","svn_url":"https://github.com/planetf1/oqstsc","homepage":"https://openquantumsafe.org/","size":119,"stargazers_count":0,"watchers_count":0,"language":null,"has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":0,"license":{"key":"cc-by-4.0","name":"Creative Commons Attribution 4.0 International","spdx_id":"CC-BY-4.0","url":"https://api.github.com/licenses/cc-by-4.0","node_id":"MDc6TGljZW5zZTI1"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":0,"open_issues":0,"watchers":0,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"af24ebe4b38b37729dff4217b0f82ff6659a3122","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":746904584,"node_id":"R_kgDOLITcCA","name":"tsc","full_name":"open-quantum-safe/tsc","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/tsc","description":"OQS Technical Steering Committee resources","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/tsc","forks_url":"https://api.github.com/repos/open-quantum-safe/tsc/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/tsc/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/tsc/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/tsc/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/tsc/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/tsc/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/tsc/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/tsc/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/tsc/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/tsc/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/tsc/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/tsc/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/tsc/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/tsc/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/tsc/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/tsc/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/tsc/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/tsc/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/tsc/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/tsc/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/tsc/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/tsc/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/tsc/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/tsc/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/tsc/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/tsc/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/tsc/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/tsc/deployments","created_at":"2024-01-22T22:27:14Z","updated_at":"2024-04-25T17:39:01Z","pushed_at":"2024-04-25T17:38:57Z","git_url":"git://github.com/open-quantum-safe/tsc.git","ssh_url":"git@github.com:open-quantum-safe/tsc.git","clone_url":"https://github.com/open-quantum-safe/tsc.git","svn_url":"https://github.com/open-quantum-safe/tsc","homepage":"https://openquantumsafe.org/","size":117,"stargazers_count":2,"watchers_count":2,"language":null,"has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":2,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":9,"license":{"key":"cc-by-4.0","name":"Creative Commons Attribution 4.0 International","spdx_id":"CC-BY-4.0","url":"https://api.github.com/licenses/cc-by-4.0","node_id":"MDc6TGljZW5zZTI1"},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":[],"visibility":"public","forks":2,"open_issues":9,"watchers":2,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18"},"html":{"href":"https://github.com/open-quantum-safe/tsc/pull/18"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/issues/18/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/pulls/18/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/tsc/statuses/f9ed9fe4d1e45e4769ec1ee54a4703d41baf654b"}},"author_association":"CONTRIBUTOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T15:14:09Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"37858070451","type":"PullRequestReviewCommentEvent","actor":{"id":39264796,"login":"SWilson4","display_login":"SWilson4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","avatar_url":"https://avatars.githubusercontent.com/u/39264796?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581195964","pull_request_review_id":2025320400,"id":1581195964,"node_id":"PRRC_kwDOA-eq3c5ePyK8","diff_hunk":"@@ -0,0 +1,659 @@\n+/**\n+ * \\file sig_stfl.h\n+ * \\brief Stateful Signature schemes\n+ *\n+ * The file `tests/example_sig_stfl.c` contains an example on using the OQS_SIG_STFL API.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#ifndef OQS_SIG_STATEFUL_H\n+#define OQS_SIG_STATEFUL_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include <oqs/oqs.h>\n+\n+/*\n+ * Developer's Notes:\n+ * Stateful signatures are based on the one-time use of a secret key. A pool of secret keys is created for this purpose.\n+ * The state of these keys is tracked to ensure that they are used only once to generate a signature.\n+ *\n+ * As such, product-specific environments do play a role in ensuring the safety of the keys.\n+ * Secret keys must be stored securely.\n+ * The key index/counter must be updated after each signature generation.\n+ * The secret key must be protected in a thread-safe manner.\n+ *\n+ * Applications therefore are required to provide environment-specific callback functions to\n+ *  - store private key\n+ *  - lock/unlock private key\n+ *\n+ *  See below for details\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_lock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_unlock\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_mutex\n+ *  OQS_SIG_STFL_SECRET_KEY_SET_store_cb\n+ *\n+ */\n+\n+#if defined(__cplusplus)\n+extern \"C\"\n+{\n+#endif\n+\n+/* Algorithm identifier for XMSS-SHA2_10_256 */\n+#define OQS_SIG_STFL_alg_xmss_sha256_h10 \"XMSS-SHA2_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h16 \"XMSS-SHA2_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha256_h20 \"XMSS-SHA2_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h10 \"XMSS-SHAKE_10_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h16 \"XMSS-SHAKE_16_256\"\n+#define OQS_SIG_STFL_alg_xmss_shake128_h20 \"XMSS-SHAKE_20_256\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h10 \"XMSS-SHA2_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h16 \"XMSS-SHA2_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_sha512_h20 \"XMSS-SHA2_20_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h10 \"XMSS-SHAKE_10_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h16 \"XMSS-SHAKE_16_512\"\n+#define OQS_SIG_STFL_alg_xmss_shake256_h20 \"XMSS-SHAKE_20_512\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_2 \"XMSSMT-SHA2_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h20_4 \"XMSSMT-SHA2_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_2 \"XMSSMT-SHA2_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_4 \"XMSSMT-SHA2_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h40_8 \"XMSSMT-SHA2_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_3 \"XMSSMT-SHA2_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_6 \"XMSSMT-SHA2_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_sha256_h60_12 \"XMSSMT-SHA2_60/12_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_2 \"XMSSMT-SHAKE_20/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h20_4 \"XMSSMT-SHAKE_20/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_2 \"XMSSMT-SHAKE_40/2_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_4 \"XMSSMT-SHAKE_40/4_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h40_8 \"XMSSMT-SHAKE_40/8_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_3 \"XMSSMT-SHAKE_60/3_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_6 \"XMSSMT-SHAKE_60/6_256\"\n+#define OQS_SIG_STFL_alg_xmssmt_shake128_h60_12 \"XMSSMT-SHAKE_60/12_256\"\n+\n+/* Defined LMS parameter identifiers */\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w1 \"LMS_SHA256_H5_W1\" //\"5/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w2 \"LMS_SHA256_H5_W2\" //\"5/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w4 \"LMS_SHA256_H5_W4\" //\"5/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8 \"LMS_SHA256_H5_W8\" //\"5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w1 \"LMS_SHA256_H10_W1\" //\"10/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2 \"LMS_SHA256_H10_W2\" //\"10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4 \"LMS_SHA256_H10_W4\" //\"10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8 \"LMS_SHA256_H10_W8\" //\"10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w1 \"LMS_SHA256_H15_W1\" //\"15/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w2 \"LMS_SHA256_H15_W2\" //\"15/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w4 \"LMS_SHA256_H15_W4\" //\"15/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8 \"LMS_SHA256_H15_W8\" //\"15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w1 \"LMS_SHA256_H20_W1\" //\"20/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w2 \"LMS_SHA256_H20_W2\" //\"20/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w4 \"LMS_SHA256_H20_W4\" //\"20/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8 \"LMS_SHA256_H20_W8\" //\"20/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w1 \"LMS_SHA256_H25_W1\" //\"25/1\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w2 \"LMS_SHA256_H25_W2\" //\"25/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w4 \"LMS_SHA256_H25_W4\" //\"25/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h25_w8 \"LMS_SHA256_H25_W8\" //\"25/8\"\n+\n+// 2-Level LMS\n+#define OQS_SIG_STFL_alg_lms_sha256_h5_w8_h5_w8 \"LMS_SHA256_H5_W8_H5_W8\" //\"5/8, 5/8\"\n+\n+// RFC 6554\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h5_w8 \"LMS_SHA256_H10_W4_H5_W8\" //\"10/4, 5/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h5_w8 \"LMS_SHA256_H10_W8_H5_W8\"   //\"10/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w2_h10_w2 \"LMS_SHA256_H10_W2_H10_W2\" //\"10/2, 10/2\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w4_h10_w4 \"LMS_SHA256_H10_W4_H10_W4\" //\"10/4, 10/4\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h10_w8_h10_w8 \"LMS_SHA256_H10_W8_H10_W8\" //\"10/8, 10/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h5_w8 \"LMS_SHA256_H15_W8_H5_W8\"   //\"15/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h10_w8 \"LMS_SHA256_H15_W8_H10_W8\" //\"15/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h15_w8_h15_w8 \"LMS_SHA256_H15_W8_H15_W8\" //\"15/8, 15/8\"\n+\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h5_w8 \"LMS_SHA256_H20_W8_H5_W8\"   //\"20/8, 5/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h10_w8 \"LMS_SHA256_H20_W8_H10_W8\" //\"20/8, 10/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h15_w8 \"LMS_SHA256_H20_W8_H15_W8\" //\"20/8, 15/8\"\n+#define OQS_SIG_STFL_alg_lms_sha256_h20_w8_h20_w8 \"LMS_SHA256_H20_W8_H20_W8\" //\"20/8, 20/8\"\n+\n+/*\n+ * Total number of stateful variants defined above, used to create the tracking array\n+ */\n+#define OQS_SIG_STFL_algs_length 61\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Application provided function to securely store data\n+ * @param[in] sk_buf pointer to the data to be saved\n+ * @param[in] buf_len length of the data to be stored\n+ * @param[out] context pass back application data related to secret key data storage.\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*secure_store_sk)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+/**\n+ * Application provided function to lock secret key object serialize access\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*lock_key)(void *mutex);\n+\n+/**\n+ * Application provided function to unlock secret key object\n+ * @param[in] mutex pointer to mutex struct\n+ * return OQS_SUCCESS if successful, otherwise OQS_ERROR\n+ */\n+typedef OQS_STATUS (*unlock_key)(void *mutex);\n+\n+/**\n+ * Returns identifiers for available signature schemes in liboqs.  Used with `OQS_SIG_STFL_new`.\n+ *\n+ * Note that algorithm identifiers are present in this list even when the algorithm is disabled\n+ * at compile time.\n+ *\n+ * @param[in] i Index of the algorithm identifier to return, 0 <= i < OQS_SIG_algs_length\n+ * @return Algorithm identifier as a string, or NULL.\n+ */\n+OQS_API const char *OQS_SIG_STFL_alg_identifier(size_t i);\n+\n+/**\n+ * Returns the number of stateful signature mechanisms in liboqs.  They can be enumerated with\n+ * OQS_SIG_STFL_alg_identifier.\n+ *\n+ * Note that some mechanisms may be disabled at compile time.\n+ *\n+ * @return The number of stateful signature mechanisms.\n+ */\n+OQS_API int OQS_SIG_STFL_alg_count(void);\n+\n+/**\n+ * Indicates whether the specified algorithm was enabled at compile-time or not.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return 1 if enabled, 0 if disabled or not found\n+ */\n+OQS_API int OQS_SIG_STFL_alg_is_enabled(const char *method_name);\n+\n+#ifndef OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+#define OQS_SIG_STFL OQS_SIG\n+#else\n+/**\n+ * Stateful signature scheme object\n+ */\n+typedef struct OQS_SIG_STFL {\n+\n+\t/**\n+\t * A local ordinal representing the LMS/XMSS OID parameter of the signature scheme.\n+\t * This OID is unrelated to ASN.1 OID, it's only for LMS/XMSS internal usage.\n+\t */\n+\tuint32_t oid;\n+\n+\t/** Printable string representing the name of the signature scheme. */\n+\tconst char *method_name;\n+\n+\t/**\n+\t * Printable string representing the version of the cryptographic algorithm.\n+\t *\n+\t * Implementations with the same method_name and same alg_version will be interoperable.\n+\t * See README.md for information about algorithm compatibility.\n+\t */\n+\tconst char *alg_version;\n+\n+\t/** Whether the signature offers EUF-CMA security (TRUE) or not (FALSE). */\n+\tbool euf_cma;\n+\n+\t/** The (maximum) length, in bytes, of public keys for this signature scheme. */\n+\tsize_t length_public_key;\n+\t/** The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\t/** The (maximum) length, in bytes, of signatures for this signature scheme. */\n+\tsize_t length_signature;\n+\n+\t/**\n+\t * Keypair generation algorithm.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `public_key`\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] public_key The public key is represented as a byte string.\n+\t * @param[out] secret_key The secret key object\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*keypair)(uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature generation algorithm.\n+\t *\n+\t * For stateful signatures, there is always a limited number of signatures that can be used,\n+\t * The private key signature counter is increased by one once a signature is successfully generated,\n+\t * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+\t *\n+\t * Caller is responsible for allocating sufficient memory for `signature`,\n+\t * based on the `length_*` members in this object or the per-scheme\n+\t * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+\t *\n+\t * @param[out] signature The signature on the message is represented as a byte string.\n+\t * @param[out] signature_len The length of the signature.\n+\t * @param[in] message The message to sign is represented as a byte string.\n+\t * @param[in] message_len The length of the message to sign.\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t *\n+\t * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+\t *       the private key after the Signing operation is completed.\n+\t */\n+\tOQS_STATUS (*sign)(uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Signature verification algorithm.\n+\t *\n+\t * @param[in] message The message is represented as a byte string.\n+\t * @param[in] message_len The length of the message.\n+\t * @param[in] signature The signature on the message is represented as a byte string.\n+\t * @param[in] signature_len The length of the signature.\n+\t * @param[in] public_key The public key is represented as a byte string.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*verify)(const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+\t/**\n+\t * Query the number of remaining signatures.\n+\t *\n+\t * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+\t *\n+\t * @param[out] remain The number of remaining signatures\n+\t * @param[in] secret_key The secret key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_remaining)(unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+\t/**\n+\t * Query the total number of signatures.\n+\t *\n+\t * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+\t *\n+\t * @param[out] total The total number of signatures\n+\t * @param[in] secret_key The secret key key object pointer.\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*sigs_total)(unsigned long long *total, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+} OQS_SIG_STFL;\n+#endif //OQS_ALLOW_STFL_KEY_AND_SIG_GEN\n+\n+/**\n+ * @brief OQS_SIG_STFL_SECRET_KEY object for stateful signature schemes\n+ */\n+\n+typedef struct OQS_SIG_STFL_SECRET_KEY {\n+\n+\t/* The (maximum) length, in bytes, of secret keys for this signature scheme. */\n+\tsize_t length_secret_key;\n+\n+\t/* The variant-specific secret key data must be allocated at the initialization. */\n+\tvoid *secret_key_data;\n+\n+\t/* The mutual exclusion struct */\n+\tvoid *mutex;\n+\n+\t/* Application-managed data related to secure storage of secret key data */\n+\tvoid *context;\n+\n+\t/**\n+\t * Serialize the stateful secret key.\n+\t *\n+\t * This function encodes the stateful secret key represented by `sk` into a byte stream\n+\t * for storage or transfer. The `sk_buf_ptr` will point to the allocated memory containing\n+\t * the byte stream. Users must free the `sk_buf_ptr` using `OQS_MEM_secure_free` after use.\n+\t * The `sk_len` will contain the length of the byte stream.\n+\t *\n+\t * @param[out] sk_buf_ptr Pointer to the byte stream representing the serialized secret key.\n+\t * @param[out] sk_len Pointer to the length of the serialized byte stream.\n+\t * @param[in] sk Pointer to the `OQS_SIG_STFL_SECRET_KEY` object to serialize.\n+\t * @return The number of bytes in the serialized byte stream upon success, or an OQS error code on failure.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk` is a valid object before calling this function.\n+\t */\n+\tOQS_STATUS (*serialize_key)(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Deserialize a byte stream into the internal representation of a stateful secret key.\n+\t *\n+\t * This function takes a series of bytes representing a stateful secret key and initializes\n+\t * the internal `OQS_SIG_STFL_SECRET_KEY` object with the key material. This is particularly\n+\t * useful for reconstructing key objects from persisted or transmitted state.\n+\t *\n+\t * @param[out] sk Pointer to an uninitialized `OQS_SIG_STFL_SECRET_KEY` object to hold the secret key.\n+\t * @param[in] sk_len The length of the secret key byte stream.\n+\t * @param[in] sk_buf Pointer to the byte stream containing the serialized secret key data.\n+\t * @param[in] context Pointer to application-specific data, handled externally, associated with the key.\n+\t * @returns OQS_SUCCESS if the deserialization succeeds, with the `sk` object populated with the key material.\n+\t *\n+\t * @attention The caller is responsible for ensuring that `sk_buf` is securely deallocated when it's no longer needed.\n+\t */\n+\tOQS_STATUS (*deserialize_key)(OQS_SIG_STFL_SECRET_KEY *sk, const size_t sk_len, const uint8_t *sk_buf, void *context);\n+\n+\t/**\n+\t * Secret Key Locking Function\n+\t *\n+\t * @param[in] mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*lock_key)(void *mutex);\n+\n+\t/**\n+\t * Secret Key Unlocking / Releasing Function\n+\t *\n+\t * @param[in]  mutex application defined mutex\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t */\n+\tOQS_STATUS (*unlock_key)(void *mutex);\n+\n+\t/**\n+\t * Store Secret Key Function\n+\t *\n+\t * Callback function used to securely store key data after a signature generation.\n+\t * When populated, this pointer points to the application-supplied secure storage function.\n+\t * @param[in] sk_buf The serialized secret key data to secure store\n+\t * @param[in] buf_len length of data to secure\n+\t * @param[in] context application supplied data used to locate where this secret key\n+\t *            is stored (passed in at the time the function pointer was set).\n+\t *\n+\t * @return OQS_SUCCESS or OQS_ERROR\n+\t * Ideally written to a secure device.\n+\t */\n+\tOQS_STATUS (*secure_store_scrt_key)(uint8_t *sk_buf, size_t buf_len, void *context);\n+\n+\t/**\n+\t * Free internal variant-specific data\n+\t *\n+\t * @param[in] sk The secret key represented as OQS_SIG_STFL_SECRET_KEY object.\n+\t * @return None.\n+\t */\n+\tvoid (*free_key)(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+\t/**\n+\t * Set Secret Key Store Callback Function\n+\t *\n+\t * This function is used to establish a callback mechanism for secure storage\n+\t * of private keys involved in stateful signature Signing operation. The secure storage\n+\t * and the management of private keys is the responsibility of the adopting application.\n+\t * Therefore, before invoking stateful signature generation, a callback function and\n+\t * associated context data must be provided by the application to manage the storage.\n+\t *\n+\t * The `context` argument is designed to hold information requisite for private key storage,\n+\t * such as a hardware security module (HSM) context, a file path, or other relevant data.\n+\t * This context is passed to the libOQS when the callback function is registered.\n+\t *\n+\t * @param[in] sk A pointer to the secret key object that requires secure storage management\n+\t *               after signature Signing operations.\n+\t * @param[in] store_cb A pointer to the callback function provided by the application\n+\t *                     for storing and updating the private key securely.\n+\t * @param[in] context Application-specific context information for the private key storage,\n+\t *                    furnished when setting the callback function via\n+\t *                    OQS_SIG_STFL_SECRET_KEY_set_store_cb().\n+\t * @return None.\n+\t */\n+\tvoid (*set_scrt_key_store_cb)(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+} OQS_SIG_STFL_SECRET_KEY;\n+\n+/**\n+ * Constructs an OQS_SIG_STFL object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL *OQS_SIG_STFL_new(const char *method_name);\n+\n+/**\n+ * Keypair generation algorithm.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `public_key` based\n+ * on the `length_*` members in this object or the per-scheme compile-time macros\n+ * `OQS_SIG_STFL_*_length_*`. The caller is also responsible for initializing\n+ * `secret_key` using the OQS_SIG_STFL_SECRET_KEY(*) function.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] public_key The public key is represented as a byte string.\n+ * @param[out] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_keypair(const OQS_SIG_STFL *sig, uint8_t *public_key, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature generation algorithm.\n+ *\n+ * For stateful signatures, there is always a limited number of signatures that can be used,\n+ * The private key signature counter is increased by one once a signature is successfully generated,\n+ * When the signature counter reaches the maximum number of available signatures, the signature generation always fails.\n+ *\n+ * Caller is responsible for allocating sufficient memory for `signature`,\n+ * based on the `length_*` members in this object or the per-scheme\n+ * compile-time macros `OQS_SIG_STFL_*_length_*`.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] signature The signature on the message is represented as a byte string.\n+ * @param[out] signature_len The length of the signature.\n+ * @param[in] message The message to sign is represented as a byte string.\n+ * @param[in] message_len The length of the message to sign.\n+ * @param[in] secret_key The secret key object pointer.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ *\n+ * @note Internally, if `lock/unlock` functions and `mutex` are set, it will attempt to lock the private key and unlock\n+ *       the private key after the Signing operation is completed.\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sign(const OQS_SIG_STFL *sig, uint8_t *signature, size_t *signature_len, const uint8_t *message, size_t message_len, OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Signature verification algorithm.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] message The message is represented as a byte string.\n+ * @param[in] message_len The length of the message.\n+ * @param[in] signature The signature on the message is represented as a byte string.\n+ * @param[in] signature_len The length of the signature.\n+ * @param[in] public_key The public key is represented as a byte string.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_verify(const OQS_SIG_STFL *sig, const uint8_t *message, size_t message_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key);\n+\n+/**\n+ * Query the number of remaining signatures.\n+ *\n+ * The remaining signatures are the number of signatures available before the private key runs out of its total signature and expires.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_remaining(const OQS_SIG_STFL *sig, unsigned long long *remain, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Query the total number of signatures.\n+ *\n+ * The total number of signatures is the constant number present in how many signatures can be generated from a private key.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL object representing the signature scheme.\n+ * @param[out] max The number of remaining signatures\n+ * @param[in] secret_key The secret key object.\n+ * @return OQS_SUCCESS or OQS_ERROR\n+ */\n+OQS_API OQS_STATUS OQS_SIG_STFL_sigs_total(const OQS_SIG_STFL *sig, unsigned long long *max, const OQS_SIG_STFL_SECRET_KEY *secret_key);\n+\n+/**\n+ * Free an OQS_SIG_STFL object that was constructed by OQS_SIG_STFL_new.\n+ *\n+ */\n+OQS_API void OQS_SIG_STFL_free(OQS_SIG_STFL *sig);\n+\n+/**\n+ * Construct an OQS_SIG_STFL_SECRET_KEY object for a particular algorithm.\n+ *\n+ * Callers should always check whether the return value is `NULL`, which indicates either than an\n+ * invalid algorithm name was provided, or that the requested algorithm was disabled at compile-time.\n+ *\n+ * @param[in] method_name Name of the desired algorithm; one of the names in `OQS_SIG_STFL_algs`.\n+ * @return An OQS_SIG_STFL_SECRET_KEY for the particular algorithm, or `NULL` if the algorithm has been disabled at compile-time.\n+ */\n+OQS_API OQS_SIG_STFL_SECRET_KEY *OQS_SIG_STFL_SECRET_KEY_new(const char *method_name);\n+\n+/**\n+ * Free an OQS_SIG_STFL_SECRET_KEY object that was constructed by OQS_SECRET_KEY_new.\n+ *\n+ * @param[in] sig The OQS_SIG_STFL_SECRET_KEY object to free.\n+ * @return OQS_SUCCESS if successful, or OQS_ERROR if the object cannot be freed.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_free(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Attach a locking mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose lock function is to be set.\n+ * @param[in] lock Function pointer to the locking routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `lock` function is set, users must also set the `mutex` and `unlock` functions.\n+ *\n+ * @note By default, the internal value of `sk->lock` is NULL, which does nothing to lock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_lock(OQS_SIG_STFL_SECRET_KEY *sk, lock_key lock);\n+\n+/**\n+ * Attach an unlock mechanism to a secret key object.\n+ *\n+ * This allows for proper synchronization in a multi-threaded or multi-process environment,\n+ * by ensuring that a secret key is not used concurrently by multiple entities, which could otherwise lead to security issues.\n+ *\n+ * @param[in] sk Pointer to the secret key object whose unlock function is to be set.\n+ * @param[in] unlock Function pointer to the unlock routine provided by the application.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note Once the `unlock` function is set, users must also set the `mutex` and `lock` functions.\n+ *\n+ * @note By default, the internal value of `sk->unlock` is NULL, which does nothing to unlock the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_unlock(OQS_SIG_STFL_SECRET_KEY *sk, unlock_key unlock);\n+\n+/**\n+ * Assign a mutex function to handle concurrency control over the secret key.\n+ *\n+ * This is to ensure that only one process can access or modify the key at any given time.\n+ *\n+ * @param[in] sk A pointer to the secret key that the mutex functionality will protect.\n+ * @param[in] mutex A function pointer to the desired concurrency control mechanism.\n+ * @return None.\n+ *\n+ * @note It's not required to set the lock and unlock functions in a single-threaded environment.\n+ *\n+ * @note By default, the internal value of `sk->mutex` is NULL, it must be set to be used in `lock` or `unlock` the private key.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_mutex(OQS_SIG_STFL_SECRET_KEY *sk, void *mutex);\n+\n+/**\n+ * Lock the secret key to ensure exclusive access in a concurrent environment.\n+ *\n+ * If the `mutex` is not set, this lock operation will fail.\n+ * This lock operation is essential in multi-threaded or multi-process contexts\n+ * to prevent simultaneous Signing operations that could compromise the stateful signature security.\n+ *\n+ * @warning If the `lock` function is set and `mutex` is not set, this lock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key to be locked.\n+ * @return OQS_SUCCESS if the lock is successfully applied; OQS_ERROR otherwise.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `lock` function and `mutex` are both set, proceed to lock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_lock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Unlock the secret key, making it accessible to other processes.\n+ *\n+ * This function is crucial in environments where multiple processes need to coordinate access to\n+ * the secret key, as it allows a process to signal that it has finished using the key, so\n+ * others can safely use it.\n+ *\n+ * @warning If the `unlock` function is set and `mutex` is not set, this unlock operation will fail.\n+ *\n+ * @param[in] sk Pointer to the secret key whose lock should be released.\n+ * @return OQS_SUCCESS if the lock was successfully released; otherwise, OQS_ERROR.\n+ *\n+ * @note It's not necessary to use this function in either Keygen or Verifying operations.\n+ *       In a concurrent environment, the user is responsible for locking and unlocking the private key,\n+ *       to make sure that only one thread can access the private key during a Signing operation.\n+ *\n+ * @note If the `unlock` function and `mutex` are both set, proceed to unlock the private key.\n+ */\n+OQS_STATUS OQS_SIG_STFL_SECRET_KEY_unlock(OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Set the callback and context for securely storing a stateful secret key.\n+ *\n+ * This function is designed to be called after a new stateful secret key\n+ * has been generated. It enables the library to securely store secret key\n+ * and update it every time a Signing operation occurs.\n+ * Without properly setting this callback and context, signature generation\n+ * will not succeed as the updated state of the secret key cannot be preserved.\n+ *\n+ * @param[in] sk Pointer to the stateful secret key to be managed.\n+ * @param[in] store_cb Callback function that handles the secure storage of the key.\n+ * @param[in] context Application-specific context that assists in the storage of secret key data.\n+ *                    This context is managed by the application, which allocates it, keeps track of it,\n+ *                    and deallocates it as necessary.\n+ * @return None.\n+ */\n+OQS_API void OQS_SIG_STFL_SECRET_KEY_SET_store_cb(OQS_SIG_STFL_SECRET_KEY *sk, secure_store_sk store_cb, void *context);\n+\n+/**\n+ * Serialize the stateful secret key data into a byte array.\n+ *\n+ * Converts an OQS_SIG_STFL_SECRET_KEY object into a byte array for storage or transmission.\n+ *\n+ * @param[out] sk_buf_ptr Pointer to the allocated byte array containing the serialized key.\n+ * @param[out] sk_len Length of the serialized key byte array.\n+ * @param[in] sk Pointer to the OQS_SIG_STFL_SECRET_KEY object to be serialized.\n+ * @return OQS_SUCCESS on success, or an OQS error code on failure.\n+ *\n+ * @note The function allocates memory for the byte array, and it is the caller's responsibility to free this memory after use.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_serialize_key(uint8_t **sk_buf_ptr, size_t *sk_len, const OQS_SIG_STFL_SECRET_KEY *sk);\n+\n+/**\n+ * Deserialize a byte array into an OQS_SIG_STFL_SECRET_KEY object.\n+ *\n+ * Transforms a binary representation of a secret key into an OQS_SIG_STFL_SECRET_KEY structure.\n+ * After deserialization, the secret key object can be used for subsequent cryptographic operations.\n+ *\n+ * @param[out] sk A pointer to the secret key object that will be populated from the binary data.\n+ * @param[in] key_len The length of the binary secret key data in bytes.\n+ * @param[in] sk_buf The buffer containing the serialized secret key data.\n+ * @param[in] context Application-specific data used to maintain context about the secret key.\n+ * @return OQS_SUCCESS if deserialization was successful; otherwise, OQS_ERROR.\n+ *\n+ * @attention The caller is responsible for freeing the `sk_buf` memory when it is no longer needed.\n+ */\n+OQS_API OQS_STATUS OQS_SECRET_KEY_STFL_deserialize_key(OQS_SIG_STFL_SECRET_KEY *sk, size_t key_len, const uint8_t *sk_buf, void *context);","path":"src/sig_stfl/sig_stfl.h","commit_id":"62d788c31f7aabd8f6003485df6232ac94d49619","original_commit_id":"528f2d851c8184b9f8d0f52c1099a7d70ac91b7b","user":{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},"body":"Whoops, sorry I missed that half of the comment. I've updated the code to use `sk_buf_len` in all public APIs to make it explicit that the length refers to the buffer and not the secret key object.","created_at":"2024-04-26T15:26:48Z","updated_at":"2024-04-26T15:26:48Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581195964","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581195964"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1581195964"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1581195964/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":653,"side":"RIGHT","in_reply_to_id":1581072703,"original_position":653,"position":null,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-04-26T15:26:48Z","closed_at":null,"merged_at":null,"merge_commit_sha":"a3b34d1911e52c63aec3179261995b52e1ddda95","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":4,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-04-16T00:08:11Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/62d788c31f7aabd8f6003485df6232ac94d49619","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"62d788c31f7aabd8f6003485df6232ac94d49619","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T15:25:44Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143361,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-04-25T15:33:43Z","pushed_at":"2024-04-26T15:25:44Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143361,"stargazers_count":1615,"watchers_count":1615,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":401,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":46,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":401,"open_issues":46,"watchers":1615,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/62d788c31f7aabd8f6003485df6232ac94d49619"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-04-26T15:26:48Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
