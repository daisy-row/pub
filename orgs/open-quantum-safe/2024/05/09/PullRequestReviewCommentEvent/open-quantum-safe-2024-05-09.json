{"id":"38250032807","type":"PullRequestReviewCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596108719","pull_request_review_id":2049028325,"id":1596108719,"node_id":"PRRC_kwDOA-eq3c5fIq-v","diff_hunk":"@@ -0,0 +1,1099 @@\n+// SPDX-License-Identifier: (Apache-2.0 OR MIT) AND CC0-1.0\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <oqs/rand.h>\n+\n+#include \"hash.h\"\n+#include \"hash_address.h\"\n+#include \"params.h\"\n+#include \"wots.h\"\n+#include \"utils.h\"\n+#include \"xmss_commons.h\"\n+#include \"xmss_core.h\"\n+\n+typedef struct{\n+    unsigned char h;\n+    unsigned long long next_idx;\n+    unsigned char stackusage;\n+    unsigned char completed;\n+    unsigned char *node;\n+} treehash_inst;\n+\n+typedef struct {\n+    unsigned char *stack;\n+    unsigned int stackoffset;\n+    unsigned char *stacklevels;\n+    unsigned char *auth;\n+    unsigned char *keep;\n+    treehash_inst *treehash;\n+    unsigned char *retain;\n+    unsigned long long next_leaf;\n+} bds_state;\n+\n+/* These serialization functions provide a transition between the current\n+   way of storing the state in an exposed struct, and storing it as part of the\n+   byte array that is the secret key.\n+   They will probably be refactored in a non-backwards-compatible way, soon. */\n+\n+static void xmssmt_serialize_state(const xmss_params *params,\n+                                   unsigned char *sk, bds_state *states)\n+{\n+    unsigned int i, j;\n+\n+    /* Skip past the 'regular' sk */\n+    sk += params->index_bytes + 4*params->n;\n+\n+    for (i = 0; i < 2*params->d - 1; i++) {\n+        sk += (params->tree_height + 1) * params->n; /* stack */\n+\n+        ull_to_bytes(sk, 4, states[i].stackoffset);\n+        sk += 4;\n+\n+        sk += params->tree_height + 1; /* stacklevels */\n+        sk += params->tree_height * params->n; /* auth */\n+        sk += (params->tree_height >> 1) * params->n; /* keep */\n+\n+        for (j = 0; j < params->tree_height - params->bds_k; j++) {\n+            ull_to_bytes(sk, 1, states[i].treehash[j].h);\n+            sk += 1;\n+\n+            ull_to_bytes(sk, 4, states[i].treehash[j].next_idx);\n+            sk += 4;\n+\n+            ull_to_bytes(sk, 1, states[i].treehash[j].stackusage);\n+            sk += 1;\n+\n+            ull_to_bytes(sk, 1, states[i].treehash[j].completed);\n+            sk += 1;\n+\n+            sk += params->n; /* node */\n+        }\n+\n+        /* retain */\n+        sk += ((1 << params->bds_k) - params->bds_k - 1) * params->n;\n+\n+        ull_to_bytes(sk, 4, states[i].next_leaf);\n+        sk += 4;\n+    }\n+}\n+\n+static void xmssmt_deserialize_state(const xmss_params *params,\n+                                     bds_state *states,\n+                                     unsigned char **wots_sigs,\n+                                     unsigned char *sk)\n+{\n+    unsigned int i, j;\n+\n+    /* Skip past the 'regular' sk */\n+    sk += params->index_bytes + 4*params->n;\n+\n+    // TODO (from upstream) These data sizes follow from the (former) test xmss_core_fast.c\n+    // TODO (from upstream) They should be reconsidered / motivated more explicitly\n+\n+    for (i = 0; i < 2*params->d - 1; i++) {\n+        states[i].stack = sk;\n+        sk += (params->tree_height + 1) * params->n;\n+\n+        states[i].stackoffset = (unsigned int)bytes_to_ull(sk, 4);\n+        sk += 4;\n+\n+        states[i].stacklevels = sk;\n+        sk += params->tree_height + 1;\n+\n+        states[i].auth = sk;\n+        sk += params->tree_height * params->n;\n+\n+        states[i].keep = sk;\n+        sk += (params->tree_height >> 1) * params->n;\n+\n+        for (j = 0; j < params->tree_height - params->bds_k; j++) {\n+            states[i].treehash[j].h = (unsigned char)bytes_to_ull(sk, 1);\n+            sk += 1;\n+\n+            states[i].treehash[j].next_idx = (unsigned long long)bytes_to_ull(sk, 4);\n+            sk += 4;\n+\n+            states[i].treehash[j].stackusage = (unsigned char)bytes_to_ull(sk, 1);\n+            sk += 1;\n+\n+            states[i].treehash[j].completed = (unsigned char)bytes_to_ull(sk, 1);\n+            sk += 1;\n+\n+            states[i].treehash[j].node = sk;\n+            sk += params->n;\n+        }\n+\n+        states[i].retain = sk;\n+        sk += ((1 << params->bds_k) - params->bds_k - 1) * params->n;\n+\n+        states[i].next_leaf = (unsigned long long)bytes_to_ull(sk, 4);\n+        sk += 4;\n+    }\n+\n+    if (params->d > 1) {\n+        *wots_sigs = sk;\n+    }\n+}\n+\n+static void xmss_serialize_state(const xmss_params *params,\n+                                 unsigned char *sk, bds_state *state)\n+{\n+    xmssmt_serialize_state(params, sk, state);\n+}\n+\n+static void xmss_deserialize_state(const xmss_params *params,\n+                                   bds_state *state, unsigned char *sk)\n+{\n+    xmssmt_deserialize_state(params, state, NULL, sk);\n+}\n+\n+static void memswap(void *a, void *b, void *t, unsigned long long len)\n+{\n+    memcpy(t, a, (size_t)len);\n+    memcpy(a, b, (size_t)len);\n+    memcpy(b, t, (size_t)len);\n+}\n+\n+/**\n+ * Swaps the content of two bds_state objects, swapping actual memory rather\n+ * than pointers.\n+ * As we're mapping memory chunks in the secret key to bds state objects,\n+ * it is now necessary to make swaps 'real swaps'. This could be done in the\n+ * serialization function as well, but that causes more overhead\n+ */\n+// TODO (from upstream) this should not be necessary if we keep better track of the states\n+static void deep_state_swap(const xmss_params *params,\n+                            bds_state *a, bds_state *b)\n+{\n+    if (a->stack == NULL || b->stack == NULL) {\n+        return;\n+    }\n+    // TODO (from upstream) this is extremely ugly and should be refactored\n+    // TODO (from upstream) right now, this ensures that both 'stack' and 'retain' fit\n+    unsigned char *t = malloc(\n+        ((params->tree_height + 1) > ((1 << params->bds_k) - params->bds_k - 1)\n+         ? (params->tree_height + 1)\n+         : ((1 << params->bds_k) - params->bds_k - 1))\n+        * params->n);\n+    if (t == NULL) {\n+        return;\n+    }\n+    unsigned int i;\n+\n+    memswap(a->stack, b->stack, t, (params->tree_height + 1) * params->n);\n+    memswap(&a->stackoffset, &b->stackoffset, t, sizeof(a->stackoffset));\n+    memswap(a->stacklevels, b->stacklevels, t, params->tree_height + 1);\n+    memswap(a->auth, b->auth, t, params->tree_height * params->n);\n+    memswap(a->keep, b->keep, t, (params->tree_height >> 1) * params->n);\n+\n+    for (i = 0; i < params->tree_height - params->bds_k; i++) {\n+        memswap(&a->treehash[i].h, &b->treehash[i].h, t, sizeof(a->treehash[i].h));\n+        memswap(&a->treehash[i].next_idx, &b->treehash[i].next_idx, t, sizeof(a->treehash[i].next_idx));\n+        memswap(&a->treehash[i].stackusage, &b->treehash[i].stackusage, t, sizeof(a->treehash[i].stackusage));\n+        memswap(&a->treehash[i].completed, &b->treehash[i].completed, t, sizeof(a->treehash[i].completed));\n+        memswap(a->treehash[i].node, b->treehash[i].node, t, params->n);\n+    }\n+\n+    memswap(a->retain, b->retain, t, ((1 << params->bds_k) - params->bds_k - 1) * params->n);\n+    memswap(&a->next_leaf, &b->next_leaf, t, sizeof(a->next_leaf));\n+\n+    OQS_MEM_insecure_free(t);\n+}\n+\n+static int treehash_minheight_on_stack(const xmss_params *params,\n+                                       bds_state *state,\n+                                       const treehash_inst *treehash)\n+{\n+    unsigned int r = params->tree_height, i;\n+\n+    for (i = 0; i < treehash->stackusage; i++) {\n+        if (state->stacklevels[state->stackoffset - i - 1] < r) {\n+            r = state->stacklevels[state->stackoffset - i - 1];\n+        }\n+    }\n+    return r;\n+}\n+\n+/**\n+ * Merkle's TreeHash algorithm. The address only needs to initialize the first 78 bits of addr. Everything else will be set by treehash.\n+ * Currently only used for key generation.\n+ *\n+ */\n+static void treehash_init(const xmss_params *params,\n+                          unsigned char *node, int height, int index,\n+                          bds_state *state, const unsigned char *sk_seed,\n+                          const unsigned char *pub_seed, const uint32_t addr[8])\n+{\n+    // use three different addresses because at this point we use all three formats in parallel\n+    uint32_t ots_addr[8] = {0};\n+    uint32_t ltree_addr[8] = {0};\n+    uint32_t node_addr[8] = {0};\n+    // only copy layer and tree address parts\n+    copy_subtree_addr(ots_addr, addr);\n+    // type = ots\n+    set_type(ots_addr, 0);\n+    copy_subtree_addr(ltree_addr, addr);\n+    set_type(ltree_addr, 1);\n+    copy_subtree_addr(node_addr, addr);\n+    set_type(node_addr, 2);\n+\n+    /* The subtree has at most 2^20 leafs, so uint32_t suffices. */\n+    uint32_t idx = index;\n+    uint32_t lastnode = index +(1<<height), i;\n+    unsigned char *stack = calloc((height+1)*params->n, sizeof(unsigned char));\n+    unsigned int *stacklevels = malloc((height + 1)*sizeof(unsigned int));\n+    unsigned char *thash_buf = malloc(2 * params->padding_len + 6 * params->n + 32);\n+\n+    if (stack == NULL || stacklevels == NULL || thash_buf == NULL) {\n+        return;\n+    }\n+\n+    unsigned int stackoffset=0;\n+    unsigned int nodeh;\n+\n+    for (i = 0; i < params->tree_height-params->bds_k; i++) {\n+        state->treehash[i].h = i;\n+        state->treehash[i].completed = 1;\n+        state->treehash[i].stackusage = 0;\n+    }\n+\n+    i = 0;\n+    for (; idx < lastnode; idx++) {\n+        set_ltree_addr(ltree_addr, idx);\n+        set_ots_addr(ots_addr, idx);\n+        gen_leaf_wots(params, stack+stackoffset*params->n, sk_seed, pub_seed, ltree_addr, ots_addr);\n+        stacklevels[stackoffset] = 0;\n+        stackoffset++;\n+        if (params->tree_height - params->bds_k > 0 && i == 3) {\n+            memcpy(state->treehash[0].node, stack+stackoffset*params->n, params->n);\n+        }\n+        while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2]) {\n+            nodeh = stacklevels[stackoffset-1];\n+            if (i >> nodeh == 1) {\n+                memcpy(state->auth + nodeh*params->n, stack+(stackoffset-1)*params->n, params->n);\n+            }\n+            else {\n+                if (nodeh < params->tree_height - params->bds_k && i >> nodeh == 3) {\n+                    memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*params->n, params->n);\n+                }\n+                else if (nodeh >= params->tree_height - params->bds_k) {\n+                    memcpy(state->retain + ((1 << (params->tree_height - 1 - nodeh)) + nodeh - params->tree_height + (((i >> nodeh) - 3) >> 1)) * params->n, stack+(stackoffset-1)*params->n, params->n);\n+                }\n+            }\n+            set_tree_height(node_addr, stacklevels[stackoffset-1]);\n+            set_tree_index(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n+            thash_h(params, stack+(stackoffset-2)*params->n, stack+(stackoffset-2)*params->n, pub_seed, node_addr, thash_buf);\n+            stacklevels[stackoffset-2]++;\n+            stackoffset--;\n+        }\n+        i++;\n+    }\n+\n+    memcpy(node, stack, params->n);\n+\n+    OQS_MEM_insecure_free(stacklevels);\n+    OQS_MEM_insecure_free(stack);\n+    OQS_MEM_insecure_free(thash_buf);\n+}\n+\n+static void treehash_update(const xmss_params *params,\n+                            treehash_inst *treehash, bds_state *state,\n+                            const unsigned char *sk_seed,\n+                            const unsigned char *pub_seed,\n+                            const uint32_t addr[8])\n+{\n+    uint32_t ots_addr[8] = {0};\n+    uint32_t ltree_addr[8] = {0};\n+    uint32_t node_addr[8] = {0};\n+    // only copy layer and tree address parts\n+    copy_subtree_addr(ots_addr, addr);\n+    // type = ots\n+    set_type(ots_addr, 0);\n+    copy_subtree_addr(ltree_addr, addr);\n+    set_type(ltree_addr, 1);\n+    copy_subtree_addr(node_addr, addr);\n+    set_type(node_addr, 2);\n+\n+    set_ltree_addr(ltree_addr, treehash->next_idx);\n+    set_ots_addr(ots_addr, treehash->next_idx);\n+\n+    unsigned char *nodebuffer = malloc(2 * params->n);\n+    unsigned char *thash_buf = malloc(2 * params->padding_len + 6 * params->n + 32);\n+    if (nodebuffer == NULL || thash_buf == NULL) {\n+        return;\n+    }\n+\n+    unsigned int nodeheight = 0;\n+    gen_leaf_wots(params, nodebuffer, sk_seed, pub_seed, ltree_addr, ots_addr);\n+    while (treehash->stackusage > 0 && state->stacklevels[state->stackoffset-1] == nodeheight) {\n+        memcpy(nodebuffer + params->n, nodebuffer, params->n);\n+        memcpy(nodebuffer, state->stack + (state->stackoffset-1)*params->n, params->n);\n+        set_tree_height(node_addr, nodeheight);\n+        set_tree_index(node_addr, (treehash->next_idx >> (nodeheight+1)));\n+        thash_h(params, nodebuffer, nodebuffer, pub_seed, node_addr, thash_buf);\n+        nodeheight++;\n+        treehash->stackusage--;\n+        state->stackoffset--;\n+    }\n+    if (nodeheight == treehash->h) { // this also implies stackusage == 0\n+        memcpy(treehash->node, nodebuffer, params->n);\n+        treehash->completed = 1;\n+    }\n+    else {\n+        memcpy(state->stack + state->stackoffset*params->n, nodebuffer, params->n);\n+        treehash->stackusage++;\n+        state->stacklevels[state->stackoffset] = nodeheight;\n+        state->stackoffset++;\n+        treehash->next_idx++;\n+    }\n+\n+    OQS_MEM_insecure_free(nodebuffer);\n+    OQS_MEM_insecure_free(thash_buf);\n+}\n+\n+/**\n+ * Performs treehash updates on the instance that needs it the most.\n+ * Returns the updated number of available updates.\n+ **/\n+static char bds_treehash_update(const xmss_params *params,\n+                                bds_state *state, unsigned int updates,\n+                                const unsigned char *sk_seed,\n+                                unsigned char *pub_seed,\n+                                const uint32_t addr[8])\n+{\n+    uint32_t i, j;\n+    unsigned int level, l_min, low;\n+    unsigned int used = 0;\n+\n+    for (j = 0; j < updates; j++) {\n+        l_min = params->tree_height;\n+        level = params->tree_height - params->bds_k;\n+        for (i = 0; i < params->tree_height - params->bds_k; i++) {\n+            if (state->treehash[i].completed) {\n+                low = params->tree_height;\n+            }\n+            else if (state->treehash[i].stackusage == 0) {\n+                low = i;\n+            }\n+            else {\n+                low = treehash_minheight_on_stack(params, state, &(state->treehash[i]));\n+            }\n+            if (low < l_min) {\n+                level = i;\n+                l_min = low;\n+            }\n+        }\n+        if (level == params->tree_height - params->bds_k) {\n+            break;\n+        }\n+        treehash_update(params, &(state->treehash[level]), state, sk_seed, pub_seed, addr);\n+        used++;\n+    }\n+    return updates - used;\n+}\n+\n+/**\n+ * Updates the state (typically NEXT_i) by adding a leaf and updating the stack\n+ * Returns -1 if all leaf nodes have already been processed\n+ **/\n+static char bds_state_update(const xmss_params *params,\n+                             bds_state *state, const unsigned char *sk_seed,\n+                             const unsigned char *pub_seed,\n+                             const uint32_t addr[8])\n+{\n+    if (state == NULL || state->stacklevels == NULL) {\n+        return -1;\n+    }\n+\n+    uint32_t ltree_addr[8] = {0};\n+    uint32_t node_addr[8] = {0};\n+    uint32_t ots_addr[8] = {0};\n+    unsigned char *thash_buf = malloc(2 * params->padding_len + 6 * params->n + 32);\n+    if (thash_buf == NULL)\n+    {\n+        return -1;\n+    }\n+\n+    unsigned int nodeh;\n+    int idx = state->next_leaf;\n+    if (idx == 1 << params->tree_height) {\n+        return -1;\n+    }\n+\n+    // only copy layer and tree address parts\n+    copy_subtree_addr(ots_addr, addr);\n+    // type = ots\n+    set_type(ots_addr, 0);\n+    copy_subtree_addr(ltree_addr, addr);\n+    set_type(ltree_addr, 1);\n+    copy_subtree_addr(node_addr, addr);\n+    set_type(node_addr, 2);\n+\n+    set_ots_addr(ots_addr, idx);\n+    set_ltree_addr(ltree_addr, idx);\n+\n+    gen_leaf_wots(params, state->stack+state->stackoffset*params->n, sk_seed, pub_seed, ltree_addr, ots_addr);\n+\n+    state->stacklevels[state->stackoffset] = 0;\n+    state->stackoffset++;\n+    if (params->tree_height - params->bds_k > 0 && idx == 3) {\n+        memcpy(state->treehash[0].node, state->stack+state->stackoffset*params->n, params->n);\n+    }\n+    while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n+        nodeh = state->stacklevels[state->stackoffset-1];\n+        if (idx >> nodeh == 1) {\n+            memcpy(state->auth + nodeh*params->n, state->stack+(state->stackoffset-1)*params->n, params->n);\n+        }\n+        else {\n+            if (nodeh < params->tree_height - params->bds_k && idx >> nodeh == 3) {\n+                memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*params->n, params->n);\n+            }\n+            else if (nodeh >= params->tree_height - params->bds_k) {\n+                memcpy(state->retain + ((1 << (params->tree_height - 1 - nodeh)) + nodeh - params->tree_height + (((idx >> nodeh) - 3) >> 1)) * params->n, state->stack+(state->stackoffset-1)*params->n, params->n);\n+            }\n+        }\n+        set_tree_height(node_addr, state->stacklevels[state->stackoffset-1]);\n+        set_tree_index(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n+        thash_h(params, state->stack+(state->stackoffset-2)*params->n, state->stack+(state->stackoffset-2)*params->n, pub_seed, node_addr, thash_buf);\n+\n+        state->stacklevels[state->stackoffset-2]++;\n+        state->stackoffset--;\n+    }\n+    state->next_leaf++;\n+\n+    OQS_MEM_insecure_free(thash_buf);\n+    return 0;\n+}\n+\n+/**\n+ * Returns the auth path for node leaf_idx and computes the auth path for the\n+ * next leaf node, using the algorithm described by Buchmann, Dahmen and Szydlo\n+ * in \"Post Quantum Cryptography\", Springer 2009.\n+ */\n+static void bds_round(const xmss_params *params,\n+                      bds_state *state, const unsigned long leaf_idx,\n+                      const unsigned char *sk_seed,\n+                      const unsigned char *pub_seed, uint32_t addr[8])\n+{\n+    unsigned int i;\n+    unsigned int tau = params->tree_height;\n+    unsigned int startidx;\n+    unsigned int offset, rowidx;\n+    unsigned char *buf = malloc(2 * params->n);\n+    unsigned char *thash_buf = malloc(2 * params->padding_len + 6 * params->n + 32);\n+    if (buf == NULL || thash_buf == NULL) {\n+        return;\n+    }\n+\n+    uint32_t ots_addr[8] = {0};\n+    uint32_t ltree_addr[8] = {0};\n+    uint32_t node_addr[8] = {0};\n+\n+    // only copy layer and tree address parts\n+    copy_subtree_addr(ots_addr, addr);\n+    // type = ots\n+    set_type(ots_addr, 0);\n+    copy_subtree_addr(ltree_addr, addr);\n+    set_type(ltree_addr, 1);\n+    copy_subtree_addr(node_addr, addr);\n+    set_type(node_addr, 2);\n+\n+    for (i = 0; i < params->tree_height; i++) {\n+        if (! ((leaf_idx >> i) & 1)) {\n+            tau = i;\n+            break;\n+        }\n+    }\n+\n+    if (tau > 0) {\n+        memcpy(buf, state->auth + (tau-1) * params->n, params->n);\n+        // we need to do this before refreshing state->keep to prevent overwriting\n+        memcpy(buf + params->n, state->keep + ((tau-1) >> 1) * params->n, params->n);\n+    }\n+    if (!((leaf_idx >> (tau + 1)) & 1) && (tau < params->tree_height - 1)) {\n+        memcpy(state->keep + (tau >> 1)*params->n, state->auth + tau*params->n, params->n);\n+    }\n+    if (tau == 0) {\n+        set_ltree_addr(ltree_addr, leaf_idx);\n+        set_ots_addr(ots_addr, leaf_idx);\n+        gen_leaf_wots(params, state->auth, sk_seed, pub_seed, ltree_addr, ots_addr);\n+    }\n+    else {\n+        set_tree_height(node_addr, (tau-1));\n+        set_tree_index(node_addr, leaf_idx >> tau);\n+        thash_h(params, state->auth + tau * params->n, buf, pub_seed, node_addr, thash_buf);\n+        for (i = 0; i < tau; i++) {\n+            if (i < params->tree_height - params->bds_k) {\n+                memcpy(state->auth + i * params->n, state->treehash[i].node, params->n);\n+            }\n+            else {\n+                offset = (1 << (params->tree_height - 1 - i)) + i - params->tree_height;\n+                rowidx = ((leaf_idx >> i) - 1) >> 1;\n+                memcpy(state->auth + i * params->n, state->retain + (offset + rowidx) * params->n, params->n);\n+            }\n+        }\n+\n+        for (i = 0; i < ((tau < params->tree_height - params->bds_k) ? tau : (params->tree_height - params->bds_k)); i++) {\n+            startidx = leaf_idx + 1 + 3 * (1 << i);\n+            if (startidx < 1U << params->tree_height) {\n+                state->treehash[i].h = i;\n+                state->treehash[i].next_idx = startidx;\n+                state->treehash[i].completed = 0;\n+                state->treehash[i].stackusage = 0;\n+            }\n+        }\n+    }\n+\n+    OQS_MEM_insecure_free(buf);\n+    OQS_MEM_insecure_free(thash_buf);\n+}\n+\n+/**\n+ * Given a set of parameters, this function returns the size of the secret key.\n+ * This is implementation specific, as varying choices in tree traversal will\n+ * result in varying requirements for state storage.\n+ *\n+ * This function handles both XMSS and XMSSMT parameter sets.\n+ */\n+unsigned long long xmss_xmssmt_core_sk_bytes(const xmss_params *params)\n+{\n+    return params->index_bytes + 4 * params->n\n+        + (2 * params->d - 1) * (\n+            (params->tree_height + 1) * params->n\n+            + 4\n+            + params->tree_height + 1\n+            + params->tree_height * params->n\n+            + (params->tree_height >> 1) * params->n\n+            + (params->tree_height - params->bds_k) * (7 + params->n)\n+            + ((1 << params->bds_k) - params->bds_k - 1) * params->n\n+            + 4\n+         )\n+        + (params->d - 1) * params->wots_sig_bytes;\n+}\n+\n+/*\n+ * Generates a XMSS key pair for a given parameter set.\n+ * Format sk: [(32bit) idx || SK_SEED || SK_PRF || root || PUB_SEED]\n+ * Format pk: [root || PUB_SEED] omitting algo oid.\n+ */\n+int xmss_core_keypair(const xmss_params *params,\n+                      unsigned char *pk, unsigned char *sk)\n+{\n+    uint32_t addr[8] = {0};\n+\n+    // TODO (from upstream) refactor BDS state not to need separate treehash instances\n+    bds_state state;\n+    treehash_inst *treehash = calloc(params->tree_height - params->bds_k, sizeof(treehash_inst));\n+    if (treehash == NULL) {\n+        return -1;\n+    }\n+    state.treehash = treehash;\n+\n+    xmss_deserialize_state(params, &state, sk);\n+\n+    state.stackoffset = 0;\n+    state.next_leaf = 0;\n+\n+    // Set idx = 0\n+    sk[0] = 0;\n+    sk[1] = 0;\n+    sk[2] = 0;\n+    sk[3] = 0;\n+    // Init SK_SEED (n byte) and SK_PRF (n byte)\n+    OQS_randombytes(sk + params->index_bytes, 2*params->n);\n+\n+    // Init PUB_SEED (n byte)\n+    OQS_randombytes(sk + params->index_bytes + 3*params->n, params->n);\n+    // Copy PUB_SEED to public key\n+    memcpy(pk + params->n, sk + params->index_bytes + 3*params->n, params->n);\n+\n+    // Compute root\n+    treehash_init(params, pk, params->tree_height, 0, &state, sk + params->index_bytes, sk + params->index_bytes + 3*params->n, addr);\n+    // copy root to sk\n+    memcpy(sk + params->index_bytes + 2*params->n, pk, params->n);\n+\n+    /* Write the BDS state into sk. */\n+    xmss_serialize_state(params, sk, &state);\n+\n+    OQS_MEM_insecure_free(treehash);\n+\n+    return 0;\n+}\n+\n+/**\n+ * Signs a message.\n+ * Returns\n+ * 1. an array containing the signature followed by the message AND\n+ * 2. an updated secret key!\n+ *\n+ */\n+int xmss_core_sign(const xmss_params *params,\n+                   unsigned char *sk,\n+                   unsigned char *sm, unsigned long long *smlen,\n+                   const unsigned char *m, unsigned long long mlen)\n+{\n+    if (params->full_height > 60) {\n+        // Unsupport Tree height\n+        return -2;\n+    }\n+\n+    const unsigned char *pub_root = sk + params->index_bytes + 2*params->n;\n+    int ret;\n+\n+    uint16_t i = 0;\n+\n+    // TODO (from upstream) refactor BDS state not to need separate treehash instances\n+    bds_state state;\n+    treehash_inst *treehash = calloc(params->tree_height - params->bds_k, sizeof(treehash_inst));\n+    unsigned char *tmp = malloc(5 * params->n + params->padding_len + params->n + 32);\n+    if (treehash == NULL || tmp == NULL) {\n+        return -1;\n+    }\n+\n+    state.treehash = treehash;\n+    /* Load the BDS state from sk. */\n+    xmss_deserialize_state(params, &state, sk);\n+\n+    // Extract SK\n+    unsigned long long idx = ((unsigned long long)sk[0] << 24) | ((unsigned long long)sk[1] << 16) | ((unsigned long long)sk[2] << 8) | sk[3];\n+\n+    /* Check if we can still sign with this sk.\n+     * If not, return -2\n+     *\n+     * If this is the last possible signature (because the max index value\n+     * is reached), production implementations should delete the secret key\n+     * to prevent accidental further use.\n+     *\n+     * For the case of total tree height of 64 we do not use the last signature\n+     * to be on the safe side (there is no index value left to indicate that the\n+     * key is finished, hence external handling would be necessary)\n+     */\n+    if (idx >= ((1ULL << params->full_height) - 1)) {\n+        // Delete secret key here. We only do this in memory, production code\n+        // has to make sure that this happens on disk.\n+        memset(sk, 0xFF, params->index_bytes);\n+        memset(sk + params->index_bytes, 0, (size_t)(params->sk_bytes - params->index_bytes));\n+        if (idx > ((1ULL << params->full_height) - 1)) {\n+            ret = -2; // We already used all one-time keys\n+            goto cleanup;\n+        }\n+    }\n+\n+    unsigned char *sk_seed = tmp;\n+    unsigned char *sk_prf = sk_seed + params->n;\n+    unsigned char *pub_seed = sk_prf + params->n;\n+\n+    memcpy(sk_seed, sk + params->index_bytes, params->n);\n+    memcpy(sk_prf, sk + params->index_bytes + params->n, params->n);\n+    memcpy(pub_seed, sk + params->index_bytes + 3*params->n, params->n);\n+\n+    // index as 32 bytes string\n+    unsigned char idx_bytes_32[32];\n+    ull_to_bytes(idx_bytes_32, 32, idx);\n+\n+    // Update SK\n+    sk[0] = ((idx + 1) >> 24) & 255;\n+    sk[1] = ((idx + 1) >> 16) & 255;\n+    sk[2] = ((idx + 1) >> 8) & 255;\n+    sk[3] = (idx + 1) & 255;\n+    // Secret key for this non-forward-secure version is now updated.\n+    // A production implementation should consider using a file handle instead,\n+    //  and write the updated secret key at this point!\n+\n+    // Init working params\n+    unsigned char *R = pub_seed + params->n;\n+    unsigned char *msg_h = R + params->n;\n+    unsigned char *prf_buf = msg_h + params->n;\n+    uint32_t ots_addr[8] = {0};\n+\n+    // ---------------------------------\n+    // Message Hashing\n+    // ---------------------------------\n+\n+    // Message Hash:\n+    // First compute pseudorandom value\n+    prf(params, R, idx_bytes_32, sk_prf, prf_buf);\n+\n+    /* Already put the message in the right place, to make it easier to prepend\n+     * things when computing the hash over the message. */\n+    unsigned long long prefix_length = params->padding_len + 3*params->n;\n+    unsigned char *m_with_prefix = malloc((size_t)(mlen + prefix_length));\n+    if (m_with_prefix == NULL) {\n+        return -1;\n+    }\n+    memcpy(m_with_prefix, sm + params->sig_bytes - prefix_length, (size_t)prefix_length);\n+    memcpy(m_with_prefix + prefix_length, m, (size_t)mlen);\n+\n+    /* Compute the message hash. */\n+    hash_message(params, msg_h, R, pub_root, idx,\n+                 m_with_prefix,\n+                 mlen);\n+\n+    // Start collecting signature\n+    *smlen = 0;\n+\n+    // Copy index to signature\n+    sm[0] = (idx >> 24) & 255;\n+    sm[1] = (idx >> 16) & 255;\n+    sm[2] = (idx >> 8) & 255;\n+    sm[3] = idx & 255;\n+\n+    sm += 4;\n+    *smlen += 4;\n+\n+    // Copy R to signature\n+    for (i = 0; i < params->n; i++) {\n+        sm[i] = R[i];\n+    }\n+\n+    sm += params->n;\n+    *smlen += params->n;\n+\n+    // ----------------------------------\n+    // Now we start to \"really sign\"\n+    // ----------------------------------\n+\n+    // Prepare Address\n+    set_type(ots_addr, 0);\n+    set_ots_addr(ots_addr, (uint32_t) idx);\n+\n+    // Compute WOTS signature\n+    wots_sign(params, sm, msg_h, sk_seed, pub_seed, ots_addr);\n+\n+    sm += params->wots_sig_bytes;\n+    *smlen += params->wots_sig_bytes;\n+\n+    // the auth path was already computed during the previous round\n+    memcpy(sm, state.auth, params->tree_height*params->n);\n+\n+    if (idx < (1ULL << params->tree_height) - 1) {\n+        bds_round(params, &state, (const unsigned long)idx, sk_seed, pub_seed, ots_addr);\n+        bds_treehash_update(params, &state, (params->tree_height - params->bds_k) >> 1, sk_seed, pub_seed, ots_addr);\n+    }\n+\n+    *smlen += params->tree_height*params->n;\n+\n+    /* Write the updated BDS state back into sk. */\n+    xmss_serialize_state(params, sk, &state);\n+\n+    ret = 0;\n+\n+    OQS_MEM_insecure_free(m_with_prefix);\n+    OQS_MEM_insecure_free(tmp);\n+\n+cleanup:\n+    OQS_MEM_insecure_free(treehash);\n+\n+    return ret;\n+}\n+\n+/*\n+ * Generates a XMSSMT key pair for a given parameter set.\n+ * Format sk: [(ceil(h/8) bit) idx || SK_SEED || SK_PRF || root || PUB_SEED]\n+ * Format pk: [root || PUB_SEED] omitting algo oid.\n+ */\n+int xmssmt_core_keypair(const xmss_params *params,\n+                        unsigned char *pk, unsigned char *sk)\n+{\n+    uint32_t addr[8] = {0};\n+    unsigned int i;\n+    unsigned char *wots_sigs;\n+\n+    // TODO (from upstream) refactor BDS state not to need separate treehash instances\n+    bds_state *states = calloc(2*params->d - 1, sizeof(bds_state));\n+    treehash_inst *treehash = calloc((2*params->d - 1) * (params->tree_height - params->bds_k), sizeof(treehash_inst));\n+    if (states == NULL || treehash == NULL) {\n+        return -1;\n+    }\n+    for (i = 0; i < 2*params->d - 1; i++) {\n+        states[i].treehash = treehash + i * (params->tree_height - params->bds_k);\n+    }\n+\n+    xmssmt_deserialize_state(params, states, &wots_sigs, sk);\n+\n+    for (i = 0; i < 2 * params->d - 1; i++) {\n+        states[i].stackoffset = 0;\n+        states[i].next_leaf = 0;\n+    }\n+\n+    // Set idx = 0\n+    for (i = 0; i < params->index_bytes; i++) {\n+        sk[i] = 0;\n+    }\n+    // Init SK_SEED (params->n byte) and SK_PRF (params->n byte)\n+    OQS_randombytes(sk+params->index_bytes, 2*params->n);\n+\n+    // Init PUB_SEED (params->n byte)\n+    OQS_randombytes(sk+params->index_bytes + 3*params->n, params->n);\n+    // Copy PUB_SEED to public key\n+    memcpy(pk+params->n, sk+params->index_bytes+3*params->n, params->n);\n+\n+    // Start with the bottom-most layer\n+    set_layer_addr(addr, 0);\n+    // Set up state and compute wots signatures for all but topmost tree root\n+    for (i = 0; i < params->d - 1; i++) {\n+        // Compute seed for OTS key pair\n+        treehash_init(params, pk, params->tree_height, 0, states + i, sk+params->index_bytes, pk+params->n, addr);\n+        set_layer_addr(addr, (i+1));\n+        wots_sign(params, wots_sigs + i*params->wots_sig_bytes, pk, sk + params->index_bytes, pk+params->n, addr);\n+    }\n+    // Address now points to the single tree on layer d-1\n+    treehash_init(params, pk, params->tree_height, 0, states + i, sk+params->index_bytes, pk+params->n, addr);\n+    memcpy(sk + params->index_bytes + 2*params->n, pk, params->n);\n+\n+    xmssmt_serialize_state(params, sk, states);\n+\n+    OQS_MEM_insecure_free(treehash);\n+    OQS_MEM_insecure_free(states);\n+\n+    return 0;\n+}\n+\n+/**\n+ * Signs a message.\n+ * Returns\n+ * 1. an array containing the signature followed by the message AND\n+ * 2. an updated secret key!\n+ *\n+ */\n+int xmssmt_core_sign(const xmss_params *params,\n+                     unsigned char *sk,\n+                     unsigned char *sm, unsigned long long *smlen,\n+                     const unsigned char *m, unsigned long long mlen)\n+{\n+    if (params == NULL || params->full_height > 60) {\n+        // Unsupport parameter\n+        return -1;\n+    }\n+\n+    const unsigned char *pub_root = sk + params->index_bytes + 2*params->n;\n+\n+    uint64_t idx_tree;\n+    uint32_t idx_leaf;\n+    unsigned int i, j;\n+    int needswap_upto = -1;\n+    unsigned int updates;\n+\n+    // TODO (from upstream) refactor BDS state not to need separate treehash instances\n+    bds_state *states = calloc(2*params->d - 1, sizeof(bds_state));\n+    treehash_inst *treehash = calloc((2*params->d - 1) * (params->tree_height - params->bds_k), sizeof(treehash_inst));\n+    unsigned char *tmp = malloc(5 * params->n + \n+                                params->padding_len + params->n + 32);\n+    if (states == NULL || treehash == NULL || tmp == NULL) {\n+        return -1;\n+    }\n+    unsigned char *sk_seed = tmp;\n+    unsigned char *sk_prf = sk_seed + params->n;\n+    unsigned char *pub_seed = sk_prf + params->n;\n+    // Init working params\n+    unsigned char *R = pub_seed + params->n;\n+    unsigned char *msg_h = R + params->n;\n+    unsigned char *prf_buf = msg_h + params->n;\n+    uint32_t addr[8] = {0};\n+    uint32_t ots_addr[8] = {0};\n+    unsigned char idx_bytes_32[32];\n+\n+    unsigned char *wots_sigs = NULL;\n+    unsigned long long prefix_length = params->padding_len + 3*params->n;\n+    unsigned long long m_with_prefix_len = mlen + prefix_length;\n+    unsigned char *m_with_prefix = NULL;\n+    int ret = 0;\n+\n+    for (i = 0; i < 2*params->d - 1; i++) {\n+        states[i].stack = NULL;\n+        states[i].stackoffset = 0;\n+        states[i].stacklevels = NULL;\n+        states[i].auth = NULL;\n+        states[i].keep = NULL;\n+        states[i].treehash = treehash + i * (params->tree_height - params->bds_k);\n+        states[i].retain = NULL;\n+        states[i].next_leaf = 0;\n+    }\n+\n+    if ((m_with_prefix_len == 0) || (m_with_prefix = malloc(m_with_prefix_len)) == NULL) {\n+        ret = -1;\n+        goto cleanup;\n+    }\n+\n+    xmssmt_deserialize_state(params, states, &wots_sigs, sk);\n+\n+    // Extract SK\n+    unsigned long long idx = 0;\n+    for (i = 0; i < params->index_bytes; i++) {\n+        idx |= ((unsigned long long)sk[i]) << 8*(params->index_bytes - 1 - i);\n+    }\n+\n+    /* Check if we can still sign with this sk.\n+     * If not, return -2\n+     *\n+     * If this is the last possible signature (because the max index value\n+     * is reached), production implementations should delete the secret key\n+     * to prevent accidental further use.\n+     *\n+     * For the case of total tree height of 64 we do not use the last signature\n+     * to be on the safe side (there is no index value left to indicate that the\n+     * key is finished, hence external handling would be necessary)\n+     */\n+    if (idx >= ((1ULL << params->full_height) - 1)) {\n+        // Delete secret key here. We only do this in memory, production code\n+        // has to make sure that this happens on disk.\n+        memset(sk, 0xFF, params->index_bytes);\n+        memset(sk + params->index_bytes, 0, (size_t)(params->sk_bytes - params->index_bytes));\n+        if (idx > ((1ULL << params->full_height) - 1)) {\n+            // We already used all one-time keys\n+            ret = -2;\n+            goto cleanup;\n+        }\n+    }\n+\n+    memcpy(sk_seed, sk+params->index_bytes, (size_t)params->n);\n+    memcpy(sk_prf, sk+params->index_bytes+params->n, (size_t)params->n);\n+    memcpy(pub_seed, sk+params->index_bytes+3*params->n, (size_t)params->n);\n+\n+    // Update SK\n+    for (i = 0; i < params->index_bytes; i++) {\n+        sk[i] = ((idx + 1) >> 8*(params->index_bytes - 1 - i)) & 255;\n+    }\n+    // Secret key for this non-forward-secure version is now updated.\n+    // A production implementation should consider using a file handle instead,\n+    //  and write the updated secret key at this point!\n+\n+    // ---------------------------------\n+    // Message Hashing\n+    // ---------------------------------\n+\n+    // Message Hash:\n+    // First compute pseudorandom value\n+    ull_to_bytes(idx_bytes_32, 32, idx);\n+    prf(params, R, idx_bytes_32, sk_prf, prf_buf);\n+\n+    /* Already put the message in the right place, to make it easier to prepend\n+     * things when computing the hash over the message. */\n+    memcpy(m_with_prefix, sm + params->sig_bytes - prefix_length, prefix_length);\n+    memcpy(m_with_prefix + prefix_length, m, mlen);\n+\n+    /* Compute the message hash. */\n+    hash_message(params, msg_h, R, pub_root, idx,\n+                m_with_prefix,\n+                 mlen);\n+\n+    // Start collecting signature\n+    *smlen = 0;\n+\n+    // Copy index to signature\n+    for (i = 0; i < params->index_bytes; i++) {\n+        sm[i] = (idx >> 8*(params->index_bytes - 1 - i)) & 255;\n+    }\n+\n+    sm += params->index_bytes;\n+    *smlen += params->index_bytes;\n+\n+    // Copy R to signature\n+    for (i = 0; i < params->n; i++) {\n+        sm[i] = R[i];\n+    }\n+\n+    sm += params->n;\n+    *smlen += params->n;\n+\n+    // ----------------------------------\n+    // Now we start to \"really sign\"\n+    // ----------------------------------\n+\n+    // Handle lowest layer separately as it is slightly different...\n+\n+    // Prepare Address\n+    set_type(ots_addr, 0);\n+    idx_tree = idx >> params->tree_height;\n+    idx_leaf = (idx & ((1 << params->tree_height)-1));\n+    set_layer_addr(ots_addr, 0);\n+    set_tree_addr(ots_addr, idx_tree);\n+    set_ots_addr(ots_addr, idx_leaf);\n+\n+    // Compute WOTS signature\n+    wots_sign(params, sm, msg_h, sk_seed, pub_seed, ots_addr);\n+\n+    sm += params->wots_sig_bytes;\n+    *smlen += params->wots_sig_bytes;\n+\n+    memcpy(sm, states[0].auth, params->tree_height*params->n);\n+    sm += params->tree_height*params->n;\n+    *smlen += params->tree_height*params->n;\n+\n+    // prepare signature of remaining layers\n+    for (i = 1; i < params->d; i++) {\n+        // put WOTS signature in place\n+        memcpy(sm, wots_sigs + (i-1)*params->wots_sig_bytes, params->wots_sig_bytes);\n+\n+        sm += params->wots_sig_bytes;\n+        *smlen += params->wots_sig_bytes;\n+\n+        // put AUTH nodes in place\n+        if (states[i].auth == NULL) {\n+            ret = -1;\n+            goto cleanup;\n+        }\n+        memcpy(sm, states[i].auth, params->tree_height*params->n);\n+        sm += params->tree_height*params->n;\n+        *smlen += params->tree_height*params->n;\n+    }\n+\n+    updates = (params->tree_height - params->bds_k) >> 1;\n+\n+    set_tree_addr(addr, (idx_tree + 1));\n+    // mandatory update for NEXT_0 (does not count towards h-k/2) if NEXT_0 exists\n+    if ((1 + idx_tree) * (1ULL << params->tree_height) + idx_leaf < (1ULL << (unsigned long long) params->full_height)) {\n+        bds_state_update(params, &states[params->d], sk_seed, pub_seed, addr);\n+    }\n+\n+    for (i = 0; i < params->d; i++) {\n+        // check if we're not at the end of a tree\n+        if (! (((idx + 1) & ((1ULL << ((i+1)*params->tree_height)) - 1)) == 0)) {\n+            idx_leaf = (uint32_t)((idx >> (params->tree_height * i)) & ((1 << params->tree_height)-1));\n+            idx_tree = (idx >> (params->tree_height * (i+1)));\n+            set_layer_addr(addr, i);\n+            set_tree_addr(addr, (uint32_t)idx_tree);\n+            if (i == (unsigned int) (needswap_upto + 1)) {\n+                bds_round(params, &states[i], idx_leaf, sk_seed, pub_seed, addr);\n+            }\n+            updates = bds_treehash_update(params, &states[i], updates, sk_seed, pub_seed, addr);\n+            set_tree_addr(addr, (idx_tree + 1));\n+            // if a NEXT-tree exists for this level;\n+            if ((1 + idx_tree) * (1ULL << params->tree_height) + idx_leaf < (1ULL << (params->full_height - params->tree_height * i))) {\n+                if (i > 0 && updates > 0 && states[params->d + i].next_leaf < (1ULL << params->full_height)) {\n+                    bds_state_update(params, &states[params->d + i], sk_seed, pub_seed, addr);\n+                    updates--;\n+                }\n+            }\n+        }\n+        else if (idx < (1ULL << params->full_height) - 1) {\n+            deep_state_swap(params, &states[params->d + i], &states[i]);\n+\n+            set_layer_addr(ots_addr, (uint32_t)(i+1));\n+            set_tree_addr(ots_addr, ((idx + 1) >> ((i+2) * params->tree_height)));\n+            set_ots_addr(ots_addr, (((idx >> ((i+1) * params->tree_height)) + 1) & ((1ULL << params->tree_height)-1)));\n+\n+            wots_sign(params, wots_sigs + i*params->wots_sig_bytes, states[i].stack, sk_seed, pub_seed, ots_addr);\n+\n+            states[params->d + i].stackoffset = 0;\n+            states[params->d + i].next_leaf = 0;\n+\n+            updates--; // WOTS-signing counts as one update\n+            needswap_upto = (int)i;\n+            for (j = 0; j < params->tree_height-params->bds_k; j++) {\n+                states[i].treehash[j].completed = 1;\n+            }\n+        }\n+    }\n+\n+    xmssmt_serialize_state(params, sk, states);\n+\n+cleanup:\n+    OQS_MEM_insecure_free(treehash);\n+    OQS_MEM_insecure_free(states);\n+    OQS_MEM_insecure_free(tmp);\n+    OQS_MEM_insecure_free(m_with_prefix);","path":"src/sig_stfl/xmss/external/xmss_core_fast.c","commit_id":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","original_commit_id":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"body":"Are we confident that none of these contain sensitive data and thus don't need `OQS_MEM_secure_free`? Similarly elsewhere in this file.","created_at":"2024-05-09T23:54:17Z","updated_at":"2024-05-09T23:54:18Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1596108719","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596108719"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1596108719"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596108719/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1093,"original_start_line":1093,"start_side":"RIGHT","line":1096,"original_line":1096,"side":"RIGHT","original_position":1096,"position":1096,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-05-09T23:54:18Z","closed_at":null,"merged_at":null,"merge_commit_sha":"54788120996eef1d7e0acacdb80135d512aadf8c","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":5,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-05-07T16:54:40Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-05-09T06:31:52Z","pushed_at":"2024-05-09T10:07:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143406,"stargazers_count":1626,"watchers_count":1626,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":406,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":56,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":406,"open_issues":56,"watchers":1626,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-05-09T06:31:52Z","pushed_at":"2024-05-09T10:07:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143406,"stargazers_count":1626,"watchers_count":1626,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":406,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":56,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":406,"open_issues":56,"watchers":1626,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-05-09T23:54:17Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"38250093245","type":"PullRequestReviewCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596111064","pull_request_review_id":2049031350,"id":1596111064,"node_id":"PRRC_kwDOA-eq3c5fIrjY","diff_hunk":"@@ -0,0 +1,164 @@\n+/*\n+ * example_sig_stfl.c\n+ *\n+ * Minimal example of using a post-quantum stateful signature implemented in liboqs.\n+ *\n+ * SPDX-License-Identifier: MIT\n+ */\n+\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <oqs/oqs.h>\n+\n+#define MESSAGE_LEN 50\n+\n+static OQS_STATUS do_nothing_save(uint8_t *key_buf, size_t buf_len, void *context) {\n+\t(void)(context);\n+\t(void)(buf_len);\n+\treturn key_buf != NULL ? OQS_SUCCESS : OQS_ERROR;\n+}\n+\n+/* This function gives an example of the signing operations,\n+ * allocating variables dynamically on the heap and calling the\n+ * OQS_SIG_STFL and OQS_SIG_STFL_SECRET_KEY objects.\n+ *\n+ * This does not require the use of compile-time macros to check if the\n+ * algorithm in question was enabled at compile-time; instead, the caller\n+ * must check that the OQS_SIG object returned is not NULL.\n+ */\n+static OQS_STATUS stfl_example(char *method_name) {\n+\n+\tOQS_SIG_STFL *sig = NULL;\n+\tuint8_t *public_key = NULL;\n+\tOQS_SIG_STFL_SECRET_KEY *secret_key = NULL;\n+\tuint8_t *message = NULL;\n+\tuint8_t *signature = NULL;\n+\tsize_t message_len = MESSAGE_LEN;\n+\tsize_t signature_len;\n+\tchar *sk_fname = NULL;\n+\tOQS_STATUS rc = OQS_ERROR;\n+\n+\t/*\n+\t * Steps\n+\t * 1. create stateful signature object\n+\t * 2. create secret key object\n+\t * 3. set key storage callback function\n+\t *    set mutex if necessary\n+\t * 4. Generate key-pair\n+\t * 5. Signature generation\n+\t * 6. verify signature\n+\t */\n+\tsig = OQS_SIG_STFL_new(method_name);\n+\tif (sig == NULL) {\n+\t\tprintf(\"[Stateful sig]  %s new failed.\\n\", method_name);\n+\t\treturn OQS_ERROR;\n+\t}\n+\n+\tsecret_key = OQS_SIG_STFL_SECRET_KEY_new(method_name);\n+\tif (secret_key == NULL) {\n+\t\tprintf(\"[Stateful secret key] %s new failed.\\n\", method_name);\n+\t\tgoto err;\n+\t}\n+\n+\t/*\n+\t * Allocate storage for public key, secret key filename, message and signature\n+\t */\n+\tpublic_key = malloc(sig->length_public_key);\n+\tsk_fname = malloc(strlen(method_name) + strlen(\".sk\"));\n+\tmessage = malloc(message_len);\n+\tsignature = malloc(sig->length_signature);\n+\tif ((public_key == NULL) || (message == NULL) || (signature == NULL) || (sk_fname == NULL)) {\n+\t\tfprintf(stderr, \"ERROR: malloc failed!\\n\");\n+\t\tgoto err;\n+\t}\n+\n+\tstrcpy(sk_fname, method_name);\n+\tstrcat(sk_fname, \".sk\");\n+\t/*\n+\t * set callback to securely store the secret key\n+\t * secret keys are one time use only. So after a signature gen\n+\t * the secret key most be advanced to the next\n+\t */\n+\tOQS_SIG_STFL_SECRET_KEY_SET_store_cb(secret_key, do_nothing_save, (void *)sk_fname);\n+\n+\t/*\n+\t * Generate key pair\n+\t */\n+\trc = OQS_SIG_STFL_keypair(sig, public_key, secret_key);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tprintf(\"[Stateful key pair generation] %s new failed.\\n\", method_name);\n+\t\tgoto err;\n+\t}\n+\n+\t// let's create a random test message to sign\n+\tOQS_randombytes(message, message_len);\n+\n+\trc = OQS_SIG_STFL_sign(sig, signature, &signature_len, message, message_len, secret_key);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_sign failed %s!\\n\", method_name);\n+\t\tgoto err;\n+\t}\n+\trc = OQS_SIG_STFL_verify(sig, message, message_len, signature, signature_len, public_key);\n+\tif (rc != OQS_SUCCESS) {\n+\t\tfprintf(stderr, \"ERROR: OQS_SIG_STFL_verify failed %s!\\n\", method_name);\n+\t\tgoto err;\n+\t}\n+\n+\tprintf(\"[Stateful signature]  %s operations completed.\\n\", method_name);\n+err:\n+//cleanup\n+\tOQS_MEM_insecure_free(public_key);\n+\tOQS_MEM_insecure_free(sk_fname);\n+\tOQS_MEM_insecure_free(message);","path":"tests/example_sig_stfl.c","commit_id":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","original_commit_id":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"body":"```suggestion\r\n\tOQS_MEM_secure_free(message, message_len);\r\n```","created_at":"2024-05-09T23:59:02Z","updated_at":"2024-05-09T23:59:03Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1596111064","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596111064"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650#discussion_r1596111064"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"}},"reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/1596111064/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":115,"original_line":115,"side":"RIGHT","original_position":115,"position":115,"subject_type":"line"},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650","id":1663975754,"node_id":"PR_kwDOA-eq3c5jLkFK","html_url":"https://github.com/open-quantum-safe/liboqs/pull/1650","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/1650.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650","number":1650,"state":"open","locked":false,"title":"Add Stateful Signature (XMSS and LMS)","user":{"login":"ashman-p","id":23340773,"node_id":"MDQ6VXNlcjIzMzQwNzcz","avatar_url":"https://avatars.githubusercontent.com/u/23340773?v=4","gravatar_id":"","url":"https://api.github.com/users/ashman-p","html_url":"https://github.com/ashman-p","followers_url":"https://api.github.com/users/ashman-p/followers","following_url":"https://api.github.com/users/ashman-p/following{/other_user}","gists_url":"https://api.github.com/users/ashman-p/gists{/gist_id}","starred_url":"https://api.github.com/users/ashman-p/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ashman-p/subscriptions","organizations_url":"https://api.github.com/users/ashman-p/orgs","repos_url":"https://api.github.com/users/ashman-p/repos","events_url":"https://api.github.com/users/ashman-p/events{/privacy}","received_events_url":"https://api.github.com/users/ashman-p/received_events","type":"User","site_admin":false},"body":"<!-- Please give a brief explanation of the purpose of this pull request. -->\r\nAdds implementations of stateful signatures to liboqs for XMSS and LMS. The feature include new OQS APIs to generate key-pairs, signature generation, verification, and secret key state-management. Actual secret key storage is left up to the application.\r\n\r\nThis PR also includes an enhancement to OQS SHA2 API to allow handling updates with arbitrary length buffers.\r\n\r\n<!-- Does this PR resolve any issue?  If so, please reference it using automatic-closing keywords like \"Fixes #123.\" -->\r\n\r\n<!-- Any PR adding a new feature is expected to contain a test; the test should be part of CI testing, preferably within the \".github/workflows\" directory tree. Please add an explanation to the PR if/when (why) this cannot be done. -->\r\n\r\n<!-- Please answer the following questions to help manage version and changes across projects. -->\r\n\r\n* [ No ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ Yes ] Does this PR change the list of algorithms available -- either adding, removing, or renaming? Does this PR otherwise change an API? (If so, PRs in fully supported downstream projects dependent on these, i.e., [oqs-provider](https://github.com/open-quantum-safe/oqs-provider) and [OQS-OpenSSH](https://github.com/open-quantum-safe/openssh) will also need to be ready for review and merge by the time this is merged.)\r\nOQS provider support is a separate and forthcoming feature. This is separated because of the need to manage the stateful of secret keys.\r\n<!-- Once your pull request is ready for review and passing continuous integration tests, please convert from a draft PR to a normal PR, and request a review from one of the OQS core team members. -->\r\n\r\n","created_at":"2024-01-04T00:49:00Z","updated_at":"2024-05-09T23:59:02Z","closed_at":null,"merged_at":null,"merge_commit_sha":"54788120996eef1d7e0acacdb80135d512aadf8c","assignee":null,"assignees":[],"requested_reviewers":[{"login":"tomato42","id":618246,"node_id":"MDQ6VXNlcjYxODI0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/618246?v=4","gravatar_id":"","url":"https://api.github.com/users/tomato42","html_url":"https://github.com/tomato42","followers_url":"https://api.github.com/users/tomato42/followers","following_url":"https://api.github.com/users/tomato42/following{/other_user}","gists_url":"https://api.github.com/users/tomato42/gists{/gist_id}","starred_url":"https://api.github.com/users/tomato42/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tomato42/subscriptions","organizations_url":"https://api.github.com/users/tomato42/orgs","repos_url":"https://api.github.com/users/tomato42/repos","events_url":"https://api.github.com/users/tomato42/events{/privacy}","received_events_url":"https://api.github.com/users/tomato42/received_events","type":"User","site_admin":false},{"login":"simo5","id":8332609,"node_id":"MDQ6VXNlcjgzMzI2MDk=","avatar_url":"https://avatars.githubusercontent.com/u/8332609?v=4","gravatar_id":"","url":"https://api.github.com/users/simo5","html_url":"https://github.com/simo5","followers_url":"https://api.github.com/users/simo5/followers","following_url":"https://api.github.com/users/simo5/following{/other_user}","gists_url":"https://api.github.com/users/simo5/gists{/gist_id}","starred_url":"https://api.github.com/users/simo5/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/simo5/subscriptions","organizations_url":"https://api.github.com/users/simo5/orgs","repos_url":"https://api.github.com/users/simo5/repos","events_url":"https://api.github.com/users/simo5/events{/privacy}","received_events_url":"https://api.github.com/users/simo5/received_events","type":"User","site_admin":false},{"login":"hartm","id":16846129,"node_id":"MDQ6VXNlcjE2ODQ2MTI5","avatar_url":"https://avatars.githubusercontent.com/u/16846129?v=4","gravatar_id":"","url":"https://api.github.com/users/hartm","html_url":"https://github.com/hartm","followers_url":"https://api.github.com/users/hartm/followers","following_url":"https://api.github.com/users/hartm/following{/other_user}","gists_url":"https://api.github.com/users/hartm/gists{/gist_id}","starred_url":"https://api.github.com/users/hartm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hartm/subscriptions","organizations_url":"https://api.github.com/users/hartm/orgs","repos_url":"https://api.github.com/users/hartm/repos","events_url":"https://api.github.com/users/hartm/events{/privacy}","received_events_url":"https://api.github.com/users/hartm/received_events","type":"User","site_admin":false},{"login":"SWilson4","id":39264796,"node_id":"MDQ6VXNlcjM5MjY0Nzk2","avatar_url":"https://avatars.githubusercontent.com/u/39264796?v=4","gravatar_id":"","url":"https://api.github.com/users/SWilson4","html_url":"https://github.com/SWilson4","followers_url":"https://api.github.com/users/SWilson4/followers","following_url":"https://api.github.com/users/SWilson4/following{/other_user}","gists_url":"https://api.github.com/users/SWilson4/gists{/gist_id}","starred_url":"https://api.github.com/users/SWilson4/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SWilson4/subscriptions","organizations_url":"https://api.github.com/users/SWilson4/orgs","repos_url":"https://api.github.com/users/SWilson4/repos","events_url":"https://api.github.com/users/SWilson4/events{/privacy}","received_events_url":"https://api.github.com/users/SWilson4/received_events","type":"User","site_admin":false},{"login":"ducnguyen-sb","id":106774416,"node_id":"U_kgDOBl0_kA","avatar_url":"https://avatars.githubusercontent.com/u/106774416?v=4","gravatar_id":"","url":"https://api.github.com/users/ducnguyen-sb","html_url":"https://github.com/ducnguyen-sb","followers_url":"https://api.github.com/users/ducnguyen-sb/followers","following_url":"https://api.github.com/users/ducnguyen-sb/following{/other_user}","gists_url":"https://api.github.com/users/ducnguyen-sb/gists{/gist_id}","starred_url":"https://api.github.com/users/ducnguyen-sb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ducnguyen-sb/subscriptions","organizations_url":"https://api.github.com/users/ducnguyen-sb/orgs","repos_url":"https://api.github.com/users/ducnguyen-sb/repos","events_url":"https://api.github.com/users/ducnguyen-sb/events{/privacy}","received_events_url":"https://api.github.com/users/ducnguyen-sb/received_events","type":"User","site_admin":false}],"requested_teams":[],"labels":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/25","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/25/labels","id":10823145,"node_id":"MI_kwDOA-eq3c4ApSXp","number":25,"title":"0.11.0","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":5,"closed_issues":0,"state":"open","created_at":"2024-04-16T00:06:48Z","updated_at":"2024-05-07T16:54:40Z","due_on":null,"closed_at":null},"draft":false,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","head":{"label":"open-quantum-safe:stateful-sigs","ref":"stateful-sigs","sha":"6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-05-09T06:31:52Z","pushed_at":"2024-05-09T10:07:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143406,"stargazers_count":1626,"watchers_count":1626,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":406,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":56,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":406,"open_issues":56,"watchers":1626,"default_branch":"main"}},"base":{"label":"open-quantum-safe:main","ref":"main","sha":"6f0c46187c94f763c5f4cd703ff633c4b28f3035","user":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"node_id":"MDEwOlJlcG9zaXRvcnk2NTUxNDIwNQ==","name":"liboqs","full_name":"open-quantum-safe/liboqs","private":false,"owner":{"login":"open-quantum-safe","id":20689385,"node_id":"MDEyOk9yZ2FuaXphdGlvbjIwNjg5Mzg1","avatar_url":"https://avatars.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for prototyping and experimenting with quantum-resistant cryptography","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2024-05-09T06:31:52Z","pushed_at":"2024-05-09T10:07:54Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":143406,"stargazers_count":1626,"watchers_count":1626,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":true,"forks_count":406,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":56,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":true,"topics":["cryptography","key-exchange-algorithms","lattice-based-crypto","post-quantum-cryptography"],"visibility":"public","forks":406,"open_issues":56,"watchers":1626,"default_branch":"main"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/1650"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1650/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/1650/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/6b31a8557c04dfb5d1f30a1ab6325a461aa8ccba"}},"author_association":"COLLABORATOR","auto_merge":null,"active_lock_reason":null}},"public":true,"created_at":"2024-05-09T23:59:02Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
