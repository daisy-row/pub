{"id":"40452400601","type":"IssuesEvent","actor":{"id":41887480,"login":"MMDHBZ","display_login":"MMDHBZ","gravatar_id":"","url":"https://api.github.com/users/MMDHBZ","avatar_url":"https://avatars.githubusercontent.com/u/41887480?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"opened","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/1859","id":2429364092,"node_id":"I_kwDOA-eq3c6QzSd8","number":1859,"title":"Multi-threaded performance testing issues","user":{"login":"MMDHBZ","id":41887480,"node_id":"MDQ6VXNlcjQxODg3NDgw","avatar_url":"https://avatars.githubusercontent.com/u/41887480?v=4","gravatar_id":"","url":"https://api.github.com/users/MMDHBZ","html_url":"https://github.com/MMDHBZ","followers_url":"https://api.github.com/users/MMDHBZ/followers","following_url":"https://api.github.com/users/MMDHBZ/following{/other_user}","gists_url":"https://api.github.com/users/MMDHBZ/gists{/gist_id}","starred_url":"https://api.github.com/users/MMDHBZ/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/MMDHBZ/subscriptions","organizations_url":"https://api.github.com/users/MMDHBZ/orgs","repos_url":"https://api.github.com/users/MMDHBZ/repos","events_url":"https://api.github.com/users/MMDHBZ/events{/privacy}","received_events_url":"https://api.github.com/users/MMDHBZ/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2024-07-25T08:31:55Z","updated_at":"2024-07-25T08:31:55Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I wrote a multi-threaded test function myself, but when testing performance, the performance of multi-threading and single-threading are almost the same, and even multi-threading is slower than single-threading. I want to know why？\r\n\r\nCPU：Intel(R) Core(TM) i9-10920X CPU @ 3.50GHz\r\nOS：centos7\r\n\r\nCompilation of liboqs is followed：\r\nmkdir build && cd build\r\ncmake -GNinja .. -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=../install -DOQS_USE_PTHREADS=ON\r\nninja\r\nninja install\r\n\r\nThe function that calls liboqs.so for performance testing is as follows:\r\n\r\n#include \"oqs/kem_kyber.h\"\r\n#include <stdio.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n\r\n#include <unistd.h>\r\n#include <pthread.h>\r\n\r\n#define SLEEP sleep(1)\r\n\r\n\r\nunsigned int isContinue = 0;\r\nunsigned int g_unTotalTimes[100];\r\nunsigned int loop = 0;\r\n\r\n/*********TEST_KYBER************/\r\nvoid PerformanceTestStatFunc_Kyber512_Keygen(void* argv)\r\n{\t//\r\n\tint _g_unTotalTimes;\r\n\tint i;\r\n\tint times;\r\n\tclock_t ctStart, ctEnd;\r\n\r\n\ttime_t t0, t1;\r\n\tt0 = time(0);\r\n\tctStart = clock();\r\n\twhile (isContinue)\r\n\t{\r\n\r\n\t\tSLEEP;\r\n\t\tt1 = time(0);\r\n\t\tprintf(\"once: test time:%d sec\\n\", times = t1 - t0);//times);\r\n\t\t_g_unTotalTimes = 0;\r\n\t\tfor (i = 0; i < 100; i++)\r\n\t\t{\r\n\t\t\t//printf(\"%d %d\\n\", i, g_unTotalTimes[i]);\r\n\t\t\t_g_unTotalTimes += g_unTotalTimes[i];\r\n\t\t}\r\n\t\tprintf(\"once: Kyber512_Keygen times:%d times\\n\", _g_unTotalTimes);\r\n\t\tprintf(\"once: performance: %dTps\\n\\n\", _g_unTotalTimes / times);\r\n\t}\r\n\tctEnd = clock();\r\n\tt1 = time(0);\r\n\r\n\ttimes = (ctEnd - ctStart) / CLOCKS_PER_SEC / loop;\r\n\tprintf(\"test time:%d sec\\n\", t1 - t0);//times);\r\n\r\n\t_g_unTotalTimes = 0;\r\n\tfor (i = 0; i < 100; i++)\r\n\t{\r\n\t\t//printf(\"%d %d\\n\", i, g_unTotalTimes[i]);\r\n\t\t_g_unTotalTimes += g_unTotalTimes[i];\r\n\t}\r\n\tprintf(\"Kyber512_Keygen times:%d times\\n\", _g_unTotalTimes);\r\n\tprintf(\"performance: %dTps\\n\", _g_unTotalTimes / times);\r\n}\r\n\r\n\r\nint myThread_Kyber512_Keygen(void* argv)\r\n{\r\n    unsigned char  public_key[OQS_KEM_kyber_512_length_public_key];\r\n    unsigned char secret_key[OQS_KEM_kyber_512_length_secret_key];\r\n    unsigned char ciphertext[OQS_KEM_kyber_512_length_ciphertext];\r\n    unsigned char shared_secreta[OQS_KEM_kyber_512_length_shared_secret];\r\n    unsigned char shared_secretb[OQS_KEM_kyber_512_length_shared_secret];\r\n    int ret = 5, i;\r\n\r\n    OQS_KEM_new(\"Kyber512\");\r\n    ret = OQS_KEM_kyber_512_keypair(public_key, secret_key);\r\n    ret = OQS_KEM_kyber_512_encaps(ciphertext, shared_secreta, public_key);\r\n    ret = OQS_KEM_kyber_512_decaps(shared_secretb, ciphertext, secret_key);\r\n    if(ret !=0 || memcmp(shared_secreta, shared_secretb, OQS_KEM_kyber_512_length_shared_secret) !=0)\r\n    {printf(\"\\n OQS_KEM_kyber_512 failed\\n\");}\r\n    else{printf(\"\\n OQS_KEM_kyber_512 sucess\\n\");}\r\n\r\n\twhile (isContinue)\r\n\t{\r\n\t    ret = OQS_KEM_kyber_512_keypair(public_key, secret_key);\r\n\t\tif (ret != 0)\r\n\t\t{\r\n\t\t\tprintf(\"OQS_KEM_kyber_512_keypair: ERROR\");\r\n\t\t\tbreak;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t(*(int*)argv)++;\r\n\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\n\r\nvoid PerformanceTestStatFunc_Kyber512_Enc(void* argv)\r\n{\t//\r\n\tint _g_unTotalTimes;\r\n\tint i;\r\n\tint times;\r\n\tclock_t ctStart, ctEnd;\r\n\r\n\ttime_t t0, t1;\r\n\tt0 = time(0);\r\n\tctStart = clock();\r\n\twhile (isContinue)\r\n\t{\r\n\r\n\t\tSLEEP;\r\n\t\tt1 = time(0);\r\n\t\tprintf(\"once: test time:%d sec\\n\", times = t1 - t0);//times);\r\n\t\t_g_unTotalTimes = 0;\r\n\t\tfor (i = 0; i < 100; i++)\r\n\t\t{\r\n\t\t\t//printf(\"%d %d\\n\", i, g_unTotalTimes[i]);\r\n\t\t\t_g_unTotalTimes += g_unTotalTimes[i];\r\n\t\t}\r\n\t\tprintf(\"once: Kyber512_Enc times:%d times\\n\", _g_unTotalTimes);\r\n\t\tprintf(\"once: performance: %dTps\\n\\n\", _g_unTotalTimes / times);\r\n\t}\r\n\tctEnd = clock();\r\n\tt1 = time(0);\r\n\r\n\ttimes = (ctEnd - ctStart) / CLOCKS_PER_SEC / loop;\r\n\tprintf(\"test time:%d sec\\n\", t1 - t0);//times);\r\n\r\n\t_g_unTotalTimes = 0;\r\n\tfor (i = 0; i < 100; i++)\r\n\t{\r\n\t\t//printf(\"%d %d\\n\", i, g_unTotalTimes[i]);\r\n\t\t_g_unTotalTimes += g_unTotalTimes[i];\r\n\t}\r\n\tprintf(\"Kyber512_Enc times:%d times\\n\", _g_unTotalTimes);\r\n\tprintf(\"performance: %dTps\\n\", _g_unTotalTimes / times);\r\n}\r\n\r\n\r\nint myThread_Kyber512_Enc(void* argv)\r\n{\r\n\r\n    unsigned char  public_key[OQS_KEM_kyber_512_length_public_key];\r\n    unsigned char secret_key[OQS_KEM_kyber_512_length_secret_key];\r\n    unsigned char ciphertext[OQS_KEM_kyber_512_length_ciphertext];\r\n    unsigned char shared_secreta[OQS_KEM_kyber_512_length_shared_secret];\r\n    unsigned char shared_secretb[OQS_KEM_kyber_512_length_shared_secret];\r\n    int ret = 5, i;\r\n\r\n    OQS_KEM_new(\"Kyber512\");\r\n    ret = OQS_KEM_kyber_512_keypair(public_key, secret_key);\r\n    ret = OQS_KEM_kyber_512_encaps(ciphertext, shared_secreta, public_key);\r\n    ret = OQS_KEM_kyber_512_decaps(shared_secretb, ciphertext, secret_key);\r\n    if(ret !=0 || memcmp(shared_secreta, shared_secretb, OQS_KEM_kyber_512_length_shared_secret) !=0)\r\n    {printf(\"\\n OQS_KEM_kyber_512 failed\\n\");}\r\n    else{printf(\"\\n OQS_KEM_kyber_512 sucess\\n\");}\r\n\r\n\twhile (isContinue)\r\n\t{\r\n\t    ret =  OQS_KEM_kyber_512_encaps(ciphertext, shared_secreta, public_key);\r\n\t\tif (ret != 0)\r\n\t\t{\r\n\t\t\tprintf(\"Kyber512_Enc: ERROR\");\r\n\t\t\tbreak;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t(*(int*)argv)++;\r\n\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\n\r\n\r\nvoid test_speed() {\r\n\r\n#ifndef WIN32\r\n\tpthread_t ntid;\r\n#endif\r\n\r\n\tint i;\r\n\tint ID;\r\n\r\n\tisContinue = 1;\r\n\tgetchar();\r\n\tprintf(\"\\n please scanf loops (threads'number)....\\n\");\r\n\tscanf(\"%d\", &loop);\r\n\tprintf(\"loops:%d\\n\", loop);\r\n\tprintf(\"\\n Choosed ID....\\n\");\r\n\tprintf(\"\\n0:Kyber512_Keygen\\n\");\r\n\tprintf(\"\\n1:Kyber512_Enc\\n\");\r\n\r\n\r\n\r\n\r\n\tprintf(\"\\n please scanf ID....\\n\");\r\n\tscanf(\"%d\", &ID);\r\n\tprintf(\"ID:%d\\n\", ID);\r\n\tif (ID == 0)\r\n\t{\r\n\r\n#ifdef WIN32\r\n\t\t_beginthread(PerformanceTestStatFunc_Kyber512_Keygen, 0, NULL);\t//性能统计线程\r\n\t\tfor (i = 0; i < loop; i++)\r\n\t\t{\r\n\r\n\t\t\t_beginthread(myThread_Kyber512_Keygen, 0, g_unTotalTimes + i);\r\n\r\n\t\t\t//SLEEP(10);\t\r\n\t\t}\r\n#else\r\n        // struct params t_params[100] ;\r\n\t\tpthread_create(&ntid, NULL, (void*)PerformanceTestStatFunc_Kyber512_Keygen, NULL);\r\n\r\n\t\tfor (i = 0; i < loop; i++)\r\n\t\t{\t\r\n\t\t\t// t_params[i].g_unTotalTimes = g_unTotalTimes + i;\r\n\t\t\t// t_params[i].p = 4;\r\n\t\t\tpthread_create(&ntid, NULL, (void*)myThread_Kyber512_Keygen, g_unTotalTimes + i);\r\n\t\t\t// pthread_create(&ntid, NULL, (void*)myThread_Kyber512_Keygen, t_params + i);\r\n\t\t\t//SLEEP(10);\t\r\n\t\t}\r\n#endif\r\n\r\n\t\tprintf(\"testing....press any key to stop...\\n\");\r\n\t\tgetchar();\r\n\t\tgetchar();\r\n\t\tisContinue = 0;\r\n\t\tgetchar();\r\n\t\tputs(\"press CTL+C to exit\");\r\n\t\tSLEEP;\r\n\t}\r\n\r\n    if (ID == 1)\r\n\t{\r\n\r\n#ifdef WIN32\r\n\t\t_beginthread(PerformanceTestStatFunc_Kyber512_Keygen, 0, NULL);\t//性能统计线程\r\n\t\tfor (i = 0; i < loop; i++)\r\n\t\t{\r\n\r\n\t\t\t_beginthread(myThread_Kyber512_Keygen, 0, g_unTotalTimes + i);\r\n\r\n\t\t\t//SLEEP(10);\t\r\n\t\t}\r\n#else\r\n\t\tpthread_create(&ntid, NULL, (void*)PerformanceTestStatFunc_Kyber512_Keygen, NULL);\r\n\r\n\t\tfor (i = 0; i < loop; i++)\r\n\t\t{\r\n\t\t\tpthread_create(&ntid, NULL, (void*)myThread_Kyber512_Keygen, g_unTotalTimes + i);\r\n\t\t\t//SLEEP(10);\t\r\n\t\t}\r\n#endif\r\n\r\n\t\tprintf(\"testing....press any key to stop...\\n\");\r\n\t\tgetchar();\r\n\t\tgetchar();\r\n\t\tisContinue = 0;\r\n\t\tgetchar();\r\n\t\tputs(\"press CTL+C to exit\");\r\n\t\tSLEEP;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nvoid main()\r\n{\r\n    test_speed();\r\n}\r\n\r\n\r\n\r\n","reactions":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1859/timeline","performed_via_github_app":null,"state_reason":null}},"public":true,"created_at":"2024-07-25T08:31:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
