{"id":"14931688672","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","id":782037360,"node_id":"MDExOlB1bGxSZXF1ZXN0NTUxNjY1NzY5","number":267,"title":"removal of internal OSSL dependencies","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":33,"created_at":"2021-01-08T11:02:49Z","updated_at":"2021-01-25T06:20:06Z","closed_at":"2021-01-19T06:07:31Z","author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/267","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","diff_url":"https://github.com/open-quantum-safe/openssl/pull/267.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/267.patch"},"body":"Addresses various [improvement suggestions](https://github.com/open-quantum-safe/openssl/commit/603b1f764dda7739074278c7e9d0e7db20384828#commitcomment-45737460) by @mattcaswell: Thanks!\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/766574145","html_url":"https://github.com/open-quantum-safe/openssl/pull/267#issuecomment-766574145","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","id":766574145,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NjU3NDE0NQ==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T06:20:06Z","updated_at":"2021-01-25T06:20:06Z","author_association":"MEMBER","body":"> but if a provider calls d2i_X509_PUBKEY then we need it to go the old route\r\n\r\nArguably not a(ny) (decoder) provider but only the built-in provider(s), right? Or is the assumption that _all_ providers (incl. oqsprovider) could utilize `d2i...` (and `i2d...`) code? Just curious considering doing this for the oqsprovider: Actually, the more I'm reading the documentation, the more questions I have (also see https://github.com/openssl/openssl/issues/13949): [provider-encoder](https://www.openssl.org/docs/manmaster/man7/provider-encoder.html) doesn't read as smoothly as the other provider-docs (keymgmt, signature, etc) and could do with some more guidance for provider developers (e.g., what _not_ to use).\r\n\r\nNow, when checking who's calling `d2i_X509_PUBKEY` only three locations turned up:\r\n- `d2i_X509_PUBKEY_fp` and `..._bio`, both of which are completely non-utilized (and un-tested) functions (strange in itself: I'd have assumed all public functions have at least 1 test: Isn't that a reasonable (test coverage) goal? Or am I overlooking something? If not, worthwhile opening an issue on this, too?).\r\n- `X509_PUBKEY_set` -- which arguably is an encoder-side function, so not relevant in this context\r\n- `d2i_PUBKEY_ex` which in turn means `d2i_PUBKEY` which is used pretty often, incl. code paths I wouldn't be able to label \"provider-side only\" or \"crypto-side only\" -- plus some clear provider-side calls. Anyway, I'm at a loss finding a clear-cut code location where to distinguish whether either function `x509_pubkey_decode` or `d2i_X509_PUBKEY` is called from a provider or not. \r\n\r\nThe only idea reading the code gave me is to check whether or not `libctx` within the `X509_pubkey_st` structure is set: I got the impression it is set when a provider has been involved and NULL if that's not the case: Is that correct? A quick test adding `if (key->libctx)` to `x509_pubkey_decode` executing the old code in that case and my new code switching on OID above in the `else` clause did break the recursion and decoded the RSA cert. I'm pretty unsure whether this is a valid solution now, though, given it's relying on an assumption.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T06:20:06Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14933895413","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","id":792333487,"node_id":"MDExOlB1bGxSZXF1ZXN0NTYwMjM0NzI4","number":881,"title":"Use valgrind to check for secret-dependent branching","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-01-22T22:01:16Z","updated_at":"2021-01-25T09:49:27Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/881","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/881.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/881.patch"},"body":"Here's one way to use Valgrind to check for secret-dependent branching (and resolve #812). It's based on  Moritz Neikes [TIMECOP](https://post-apocalyptic-crypto.org/timecop/index.html).\r\n\r\nThe idea behind TIMECOP is that if you tell Valgrind that secret data resides in uninitialized memory, then Valgrind will tell you when your program branches on secret data.\r\n\r\nSUPERCOP's implementation of TIMECOP introduced \"classify\" and \"declassify\" terminology for the operation of telling Valgrind that memory is secret or non-secret. I've replicated that terminology by defining two macros in oqs.h:\r\n\r\n```c\r\n#define OQS_TIMECOP_CLASSIFY(addr, len)  VALGRIND_MAKE_MEM_UNDEFINED(addr, len)\r\n#define OQS_TIMECOP_DECLASSIFY(addr, len)  VALGRIND_MAKE_MEM_DEFINED(addr, len)\r\n```\r\n\r\nEvery secret can ultimately be traced back to a call to randombytes, so we can tell Valgrind that secrets reside in uninitialized memory by defining our own randombytes, e.g.\r\n\r\n```c\r\nvoid TEST_KEM_randombytes(uint8_t *random_array, size_t bytes_to_read) {\r\n  OQS_randombytes_system(random_array, bytes_to_read);\r\n  OQS_TIMECOP_CLASSIFY(random_array, bytes_to_read);\r\n}\r\n```\r\nand making it the default\r\n```c\r\n  OQS_randombytes_custom_algorithm(&TEST_KEM_randombytes);\r\n```\r\n\r\nI've done this in test_kem.c and test_sig.c. If you run the new test_kem or test_sig outside of Valgrind there's no change. But in Valgrind you'll see something like this:\r\n\r\n```sh\r\n$ valgrind ./tests/test_kem sntrup761\r\n[...]\r\n== Thread 2:\r\n== Conditional jump or move depends on uninitialised value(s)\r\n==    at 0x2B4EBF: PQCLEAN_SNTRUP761_CLEAN_crypto_kem_keypair (kem.c:145)\r\n==    by 0x10BCE8: kem_test_correctness (test_kem.c:94)\r\n==    by 0x10C58B: test_wrapper (test_kem.c:177)\r\n==    by 0x4CDAFA2: start_thread (pthread_create.c:486)\r\n==    by 0x4DED4CE: clone (clone.S:95) \r\n[...]\r\n```\r\n(I've compiled with CMAKE_BUILD_TYPE=debug to get the line numbers were secret branching occurs.)\r\n\r\nOf course, some non-secret data is derived from calls to randombytes, and examining pqclean_sntrup761_clean/kem.c we see that line 145 is part of a rejection sampling loop and the branch is not secret. We can remove the false positive by calling OQS_TIMECOP_DECLASSIFY on the offending memory.\r\n\r\nThere's a different example of declassifying memory in Kyber512 in the first commit linked to this PR.\r\n\r\n--- \r\n\r\nNone of changes to oqs.h, test_kem.c, or test_sig.c introduce a dependency on Valgrind. Users can still compile test_kem and test_sig and run them outside of Valgrind. All we need are some header files that the Valgrind project provides, for this purpose, under a BSD license. I've added those to src/common/valgrind.\r\n\r\n**TODO:**\r\n- [ ] Configure CMake to include the local valgrind/memcheck.h and valgrind/valgrind.h.\r\n- [ ] Add a compilation flag to completely remove calls to VALGRIND_MAKE_MEM_DEFINED. Compiling the schemes with \"-DNVALGRIND\" will do the trick. Alternatively we can change the definitions of OQS_TIMECOP_(DE)CLASSIFY in oqs.h with an ifdef.\r\n- [ ] Flag false positives with OQS_TIMECOP_DECLASSIFY.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766692667","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881#issuecomment-766692667","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","id":766692667,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NjY5MjY2Nw==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T09:49:27Z","updated_at":"2021-01-25T09:49:27Z","author_association":"MEMBER","body":"Very nice approach to use valgrind to highlight possible random-dependent code paths (tagging random data as uninitialized memory). Three \"nitpick\"/curiousity questions if I may before you finalize this:\r\n1) Is it _guaranteed_ that all secret data has been generated via the (centralized) randomness function? I have a fuzzy feeling it is (e.g., via a NIST competition demand to only use such function [Reference needed] but I'm not certain).\r\n2) Shouldn't take constant runtime checks take all data (secret or not) into account? But possibly I read to much (of a goal) into #812.\r\n3) Wouldn't it be better to have an option to _enable_ Valgrind-based testing, rather than disabling it? I'm personally no fan of `#ifndef(NO_FEATURE)`: Isn't `#ifdef FEATURE` more readable in code (e.g., for activating/deactivating `OQS_TIMECOP_CLASSIFY` as per your TODO)?","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T09:49:27Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14938843809","type":"IssueCommentEvent","actor":{"id":25615540,"login":"jschanck","display_login":"jschanck","gravatar_id":"","url":"https://api.github.com/users/jschanck","avatar_url":"https://avatars.githubusercontent.com/u/25615540?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","id":792333487,"node_id":"MDExOlB1bGxSZXF1ZXN0NTYwMjM0NzI4","number":881,"title":"Use valgrind to check for secret-dependent branching","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-01-22T22:01:16Z","updated_at":"2021-01-25T16:14:31Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/881","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/881.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/881.patch"},"body":"Here's one way to use Valgrind to check for secret-dependent branching (and resolve #812). It's based on  Moritz Neikes [TIMECOP](https://post-apocalyptic-crypto.org/timecop/index.html).\r\n\r\nThe idea behind TIMECOP is that if you tell Valgrind that secret data resides in uninitialized memory, then Valgrind will tell you when your program branches on secret data.\r\n\r\nSUPERCOP's implementation of TIMECOP introduced \"classify\" and \"declassify\" terminology for the operation of telling Valgrind that memory is secret or non-secret. I've replicated that terminology by defining two macros in oqs.h:\r\n\r\n```c\r\n#define OQS_TIMECOP_CLASSIFY(addr, len)  VALGRIND_MAKE_MEM_UNDEFINED(addr, len)\r\n#define OQS_TIMECOP_DECLASSIFY(addr, len)  VALGRIND_MAKE_MEM_DEFINED(addr, len)\r\n```\r\n\r\nEvery secret can ultimately be traced back to a call to randombytes, so we can tell Valgrind that secrets reside in uninitialized memory by defining our own randombytes, e.g.\r\n\r\n```c\r\nvoid TEST_KEM_randombytes(uint8_t *random_array, size_t bytes_to_read) {\r\n  OQS_randombytes_system(random_array, bytes_to_read);\r\n  OQS_TIMECOP_CLASSIFY(random_array, bytes_to_read);\r\n}\r\n```\r\nand making it the default\r\n```c\r\n  OQS_randombytes_custom_algorithm(&TEST_KEM_randombytes);\r\n```\r\n\r\nI've done this in test_kem.c and test_sig.c. If you run the new test_kem or test_sig outside of Valgrind there's no change. But in Valgrind you'll see something like this:\r\n\r\n```sh\r\n$ valgrind ./tests/test_kem sntrup761\r\n[...]\r\n== Thread 2:\r\n== Conditional jump or move depends on uninitialised value(s)\r\n==    at 0x2B4EBF: PQCLEAN_SNTRUP761_CLEAN_crypto_kem_keypair (kem.c:145)\r\n==    by 0x10BCE8: kem_test_correctness (test_kem.c:94)\r\n==    by 0x10C58B: test_wrapper (test_kem.c:177)\r\n==    by 0x4CDAFA2: start_thread (pthread_create.c:486)\r\n==    by 0x4DED4CE: clone (clone.S:95) \r\n[...]\r\n```\r\n(I've compiled with CMAKE_BUILD_TYPE=debug to get the line numbers were secret branching occurs.)\r\n\r\nOf course, some non-secret data is derived from calls to randombytes, and examining pqclean_sntrup761_clean/kem.c we see that line 145 is part of a rejection sampling loop and the branch is not secret. We can remove the false positive by calling OQS_TIMECOP_DECLASSIFY on the offending memory.\r\n\r\nThere's a different example of declassifying memory in Kyber512 in the first commit linked to this PR.\r\n\r\n--- \r\n\r\nNone of changes to oqs.h, test_kem.c, or test_sig.c introduce a dependency on Valgrind. Users can still compile test_kem and test_sig and run them outside of Valgrind. All we need are some header files that the Valgrind project provides, for this purpose, under a BSD license. I've added those to src/common/valgrind.\r\n\r\n**TODO:**\r\n- [ ] Configure CMake to include the local valgrind/memcheck.h and valgrind/valgrind.h.\r\n- [ ] Add a compilation flag to completely remove calls to VALGRIND_MAKE_MEM_DEFINED. Compiling the schemes with \"-DNVALGRIND\" will do the trick. Alternatively we can change the definitions of OQS_TIMECOP_(DE)CLASSIFY in oqs.h with an ifdef.\r\n- [ ] Flag false positives with OQS_TIMECOP_DECLASSIFY.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766928791","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881#issuecomment-766928791","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","id":766928791,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NjkyODc5MQ==","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T16:14:31Z","updated_at":"2021-01-25T16:14:31Z","author_association":"NONE","body":">     1. Is it _guaranteed_ that all secret data has been generated via the (centralized) randomness function? I have a fuzzy feeling it is (e.g., via a NIST competition demand to only use such function [Reference needed] but I'm not certain).\r\n\r\nAny scheme that passes the liboqs KAT test generates all of its secret data using the centralized random function.\r\n\r\nNIST's call for proposals did not guarantee KATs of exactly the form assumed by liboqs. But the form assumed by liboqs is a de facto standard---no one deviates from it.\r\n\r\n>     2. Shouldn't take constant runtime checks take all data (secret or not) into account? But possibly I read to much (of a goal) into #812.\r\n\r\nI'm currently \"declassifying\" public keys, ciphertexts, and (signature, message) pairs. There are contexts where it makes sense to treat each of these as secret, but I think it's good to keep a narrow scope.\r\n\r\n>     3. Wouldn't it be better to have an option to _enable_ Valgrind-based testing, rather than disabling it? I'm personally no fan of `#ifndef(NO_FEATURE)`: Isn't `#ifdef FEATURE` more readable in code (e.g., for activating/deactivating `OQS_TIMECOP_CLASSIFY` as per your TODO)?\r\n> Edit: Plus the question whether checking in valgrind header files is really necessary? Shouldn't installation of Valgrind suffice?\r\n\r\nSee latest commit on this PR. I don't have much of a preference, but I think there's some benefit to enabling timecop for all debug builds.\r\n\r\nDebian users, for instance, might eventually get the option of installing \"liboqs\" and \"liboqs-dbg\". A Debian user who installs liboqs-dbg might want to run their own constant-time analysis, but the Debian packager should not have to have valgrind installed in order to create liboqs-dbg.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T16:14:31Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14939719048","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","id":792333487,"node_id":"MDExOlB1bGxSZXF1ZXN0NTYwMjM0NzI4","number":881,"title":"Use valgrind to check for secret-dependent branching","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-01-22T22:01:16Z","updated_at":"2021-01-25T17:18:08Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/881","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/881.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/881.patch"},"body":"Here's one way to use Valgrind to check for secret-dependent branching (and resolve #812). It's based on  Moritz Neikes [TIMECOP](https://post-apocalyptic-crypto.org/timecop/index.html).\r\n\r\nThe idea behind TIMECOP is that if you tell Valgrind that secret data resides in uninitialized memory, then Valgrind will tell you when your program branches on secret data.\r\n\r\nSUPERCOP's implementation of TIMECOP introduced \"classify\" and \"declassify\" terminology for the operation of telling Valgrind that memory is secret or non-secret. I've replicated that terminology by defining two macros in oqs.h:\r\n\r\n```c\r\n#define OQS_TIMECOP_CLASSIFY(addr, len)  VALGRIND_MAKE_MEM_UNDEFINED(addr, len)\r\n#define OQS_TIMECOP_DECLASSIFY(addr, len)  VALGRIND_MAKE_MEM_DEFINED(addr, len)\r\n```\r\n\r\nEvery secret can ultimately be traced back to a call to randombytes, so we can tell Valgrind that secrets reside in uninitialized memory by defining our own randombytes, e.g.\r\n\r\n```c\r\nvoid TEST_KEM_randombytes(uint8_t *random_array, size_t bytes_to_read) {\r\n  OQS_randombytes_system(random_array, bytes_to_read);\r\n  OQS_TIMECOP_CLASSIFY(random_array, bytes_to_read);\r\n}\r\n```\r\nand making it the default\r\n```c\r\n  OQS_randombytes_custom_algorithm(&TEST_KEM_randombytes);\r\n```\r\n\r\nI've done this in test_kem.c and test_sig.c. If you run the new test_kem or test_sig outside of Valgrind there's no change. But in Valgrind you'll see something like this:\r\n\r\n```sh\r\n$ valgrind ./tests/test_kem sntrup761\r\n[...]\r\n== Thread 2:\r\n== Conditional jump or move depends on uninitialised value(s)\r\n==    at 0x2B4EBF: PQCLEAN_SNTRUP761_CLEAN_crypto_kem_keypair (kem.c:145)\r\n==    by 0x10BCE8: kem_test_correctness (test_kem.c:94)\r\n==    by 0x10C58B: test_wrapper (test_kem.c:177)\r\n==    by 0x4CDAFA2: start_thread (pthread_create.c:486)\r\n==    by 0x4DED4CE: clone (clone.S:95) \r\n[...]\r\n```\r\n(I've compiled with CMAKE_BUILD_TYPE=debug to get the line numbers were secret branching occurs.)\r\n\r\nOf course, some non-secret data is derived from calls to randombytes, and examining pqclean_sntrup761_clean/kem.c we see that line 145 is part of a rejection sampling loop and the branch is not secret. We can remove the false positive by calling OQS_TIMECOP_DECLASSIFY on the offending memory.\r\n\r\nThere's a different example of declassifying memory in Kyber512 in the first commit linked to this PR.\r\n\r\n--- \r\n\r\nNone of changes to oqs.h, test_kem.c, or test_sig.c introduce a dependency on Valgrind. Users can still compile test_kem and test_sig and run them outside of Valgrind. All we need are some header files that the Valgrind project provides, for this purpose, under a BSD license. I've added those to src/common/valgrind.\r\n\r\n**TODO:**\r\n- [ ] Configure CMake to include the local valgrind/memcheck.h and valgrind/valgrind.h.\r\n- [ ] Add a compilation flag to completely remove calls to VALGRIND_MAKE_MEM_DEFINED. Compiling the schemes with \"-DNVALGRIND\" will do the trick. Alternatively we can change the definitions of OQS_TIMECOP_(DE)CLASSIFY in oqs.h with an ifdef.\r\n- [ ] Flag false positives with OQS_TIMECOP_DECLASSIFY.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766973088","html_url":"https://github.com/open-quantum-safe/liboqs/pull/881#issuecomment-766973088","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/881","id":766973088,"node_id":"MDEyOklzc3VlQ29tbWVudDc2Njk3MzA4OA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T17:18:08Z","updated_at":"2021-01-25T17:18:08Z","author_association":"MEMBER","body":"> See latest commit on this PR.\r\n\r\nThat (TIMECOP option) really looks good: Thanks!\r\n\r\n> the Debian packager should not have to have valgrind installed in order to create liboqs-dbg\r\n\r\nWhy? It's just one more prereq/package -- Is debian packaging resource-constrained? For the actual package I guess all the dev/dbg variant would need is a(nother) dependency (the runtime package wouldn't need).\r\n\r\nThat said -- the underlying concern was \"GPL license contagion\" via valgrind code (that could make liboqs unattractive for some)... Upon reading the headers, it seems just these two files are not GPL'd. I didn't experience such \"license splitting\" of header files for a program yet, but this does all pretty nearly eliminate this concern.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T17:18:08Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14939749243","type":"IssueCommentEvent","actor":{"id":7422273,"login":"mattcaswell","display_login":"mattcaswell","gravatar_id":"","url":"https://api.github.com/users/mattcaswell","avatar_url":"https://avatars.githubusercontent.com/u/7422273?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","id":782037360,"node_id":"MDExOlB1bGxSZXF1ZXN0NTUxNjY1NzY5","number":267,"title":"removal of internal OSSL dependencies","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":35,"created_at":"2021-01-08T11:02:49Z","updated_at":"2021-01-25T17:20:29Z","closed_at":"2021-01-19T06:07:31Z","author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/267","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","diff_url":"https://github.com/open-quantum-safe/openssl/pull/267.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/267.patch"},"body":"Addresses various [improvement suggestions](https://github.com/open-quantum-safe/openssl/commit/603b1f764dda7739074278c7e9d0e7db20384828#commitcomment-45737460) by @mattcaswell: Thanks!\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/766974685","html_url":"https://github.com/open-quantum-safe/openssl/pull/267#issuecomment-766974685","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","id":766974685,"node_id":"MDEyOklzc3VlQ29tbWVudDc2Njk3NDY4NQ==","user":{"login":"mattcaswell","id":7422273,"node_id":"MDQ6VXNlcjc0MjIyNzM=","avatar_url":"https://avatars.githubusercontent.com/u/7422273?v=4","gravatar_id":"","url":"https://api.github.com/users/mattcaswell","html_url":"https://github.com/mattcaswell","followers_url":"https://api.github.com/users/mattcaswell/followers","following_url":"https://api.github.com/users/mattcaswell/following{/other_user}","gists_url":"https://api.github.com/users/mattcaswell/gists{/gist_id}","starred_url":"https://api.github.com/users/mattcaswell/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mattcaswell/subscriptions","organizations_url":"https://api.github.com/users/mattcaswell/orgs","repos_url":"https://api.github.com/users/mattcaswell/repos","events_url":"https://api.github.com/users/mattcaswell/events{/privacy}","received_events_url":"https://api.github.com/users/mattcaswell/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T17:20:28Z","updated_at":"2021-01-25T17:20:28Z","author_association":"NONE","body":"> Arguably not a(ny) (decoder) provider but only the built-in provider(s), right?\r\n\r\nRight.\r\n\r\nI suspect the provider side handling of this is not quite right. Maybe, it should not call d2i_PUBKEY at all - but possibly an alternative internal only version that uses a different callback...i.e. not `x509_pubkey_decode`. I had an exchange with @levitte about this issue this morning - so possibly he might chip in.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T17:20:29Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14939797509","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882","id":792340302,"node_id":"MDU6SXNzdWU3OTIzNDAzMDI=","number":882,"title":"Outdated SIKE code","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-01-22T22:16:29Z","updated_at":"2021-01-25T17:24:15Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"The timing side-channel test from #881 flags this as a potential timing leak. It was fixed upstream last June.\r\n\r\nhttps://github.com/open-quantum-safe/liboqs/blob/fb5484cda68dac115dc563593c68388f89444b95/src/kem/sike/external/sike.c#L79-L82","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766977250","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882#issuecomment-766977250","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","id":766977250,"node_id":"MDEyOklzc3VlQ29tbWVudDc2Njk3NzI1MA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T17:24:15Z","updated_at":"2021-01-25T17:24:15Z","author_association":"MEMBER","body":"Thanks for this information. SIKE is not part of the automated PQClean-upstream import mechanism, right? Might this be a candidate for further automated direct-upstream importing (as discussed in #880)?","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T17:24:15Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14939958418","type":"IssueCommentEvent","actor":{"id":21228961,"login":"xvzcf","display_login":"xvzcf","gravatar_id":"","url":"https://api.github.com/users/xvzcf","avatar_url":"https://avatars.githubusercontent.com/u/21228961?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/880","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/880/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/880/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/880/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/880","id":791911850,"node_id":"MDU6SXNzdWU3OTE5MTE4NTA=","number":880,"title":"Update copy_from_pqclean","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-01-22T11:02:42Z","updated_at":"2021-01-25T17:37:01Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"I'd support this proposal from Basil Hess and solicit further feedback to the below from @dstebila , @xvzcf : \r\n\r\n> Using kyber-upstream is now indeed a simple task thanks to what you already prepared.\r\n> I really like the copy_from_pqclean mechanism. The META.yml definitions are obviously a pqclean-\"invention\", but they are a nice way to make an easy path for integrating also other implementations/libraries. Perhaps it could be renamed to copy_from_upstream.\r\n> \r\n> I'm slightly updating the script with the following features. Please let me know if anything doesn't make sense here:\r\n>\r\n>- Adding support to checkout the upstream code from a git-repository: copy_from_pqclean.yml will contain a section \"upstreams\" with several git-repos (pqclean, pqcrystals-kyber, pqcrystals-dilithium, etc...), and the git-commit hash that will be used. This will replace the PQCLEAN_DIR env. variable. Instead, the git repo location will be used (this can be a github-url, a local path on the filesystem, etc.).\r\n> - Adding a \"verify\" switch to the script: The goal is to be able to prove that the code used in liboqs origins from an upstream location with a specific commit. This will basically repeat the copy_from_pqclean process, hash of the code that is checked out, and compare it with the code in the liboqs src-directory. For someone using liboqs it should be useful to be able to reproduce and verify from where the crypto code origins.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766986000","html_url":"https://github.com/open-quantum-safe/liboqs/issues/880#issuecomment-766986000","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/880","id":766986000,"node_id":"MDEyOklzc3VlQ29tbWVudDc2Njk4NjAwMA==","user":{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T17:37:01Z","updated_at":"2021-01-25T17:37:01Z","author_association":"MEMBER","body":"Same here.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T17:37:01Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14939983493","type":"IssueCommentEvent","actor":{"id":21228961,"login":"xvzcf","display_login":"xvzcf","gravatar_id":"","url":"https://api.github.com/users/xvzcf","avatar_url":"https://avatars.githubusercontent.com/u/21228961?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882","id":792340302,"node_id":"MDU6SXNzdWU3OTIzNDAzMDI=","number":882,"title":"Outdated SIKE code","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-01-22T22:16:29Z","updated_at":"2021-01-25T17:39:07Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"The timing side-channel test from #881 flags this as a potential timing leak. It was fixed upstream last June.\r\n\r\nhttps://github.com/open-quantum-safe/liboqs/blob/fb5484cda68dac115dc563593c68388f89444b95/src/kem/sike/external/sike.c#L79-L82","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/766989763","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882#issuecomment-766989763","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","id":766989763,"node_id":"MDEyOklzc3VlQ29tbWVudDc2Njk4OTc2Mw==","user":{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T17:39:07Z","updated_at":"2021-01-25T17:39:07Z","author_association":"MEMBER","body":"> Thanks for this information. SIKE is not part of the automated PQClean-upstream import mechanism, right? Might this be a candidate for further automated direct-upstream importing (as discussed in #880)?\r\n\r\nSIKE updates are handled by @christianpaquin I believe.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T17:39:07Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14942080806","type":"IssueCommentEvent","actor":{"id":698918,"login":"levitte","display_login":"levitte","gravatar_id":"","url":"https://api.github.com/users/levitte","avatar_url":"https://avatars.githubusercontent.com/u/698918?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","id":782037360,"node_id":"MDExOlB1bGxSZXF1ZXN0NTUxNjY1NzY5","number":267,"title":"removal of internal OSSL dependencies","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":36,"created_at":"2021-01-08T11:02:49Z","updated_at":"2021-01-25T20:44:39Z","closed_at":"2021-01-19T06:07:31Z","author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/267","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","diff_url":"https://github.com/open-quantum-safe/openssl/pull/267.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/267.patch"},"body":"Addresses various [improvement suggestions](https://github.com/open-quantum-safe/openssl/commit/603b1f764dda7739074278c7e9d0e7db20384828#commitcomment-45737460) by @mattcaswell: Thanks!\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/767101256","html_url":"https://github.com/open-quantum-safe/openssl/pull/267#issuecomment-767101256","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","id":767101256,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NzEwMTI1Ng==","user":{"login":"levitte","id":698918,"node_id":"MDQ6VXNlcjY5ODkxOA==","avatar_url":"https://avatars.githubusercontent.com/u/698918?v=4","gravatar_id":"","url":"https://api.github.com/users/levitte","html_url":"https://github.com/levitte","followers_url":"https://api.github.com/users/levitte/followers","following_url":"https://api.github.com/users/levitte/following{/other_user}","gists_url":"https://api.github.com/users/levitte/gists{/gist_id}","starred_url":"https://api.github.com/users/levitte/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/levitte/subscriptions","organizations_url":"https://api.github.com/users/levitte/orgs","repos_url":"https://api.github.com/users/levitte/repos","events_url":"https://api.github.com/users/levitte/events{/privacy}","received_events_url":"https://api.github.com/users/levitte/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T20:44:39Z","updated_at":"2021-01-25T20:44:39Z","author_association":"NONE","body":"Uhmmmm, I don't see why calling `d2i_PUBKEY_ex()` from the der2key decoder would make much harm.  Do note that after calling `d2i_X509_PUBKEY()` (which is the generated ASN1 function to decode DER into a X509_PUBKEY), `d2i_PUBKEY()` calls `X509_PUBKEY_get()`, which calls `x509_pubkey_decode()`.  So in essence, calling `d2i_PUBKEY_ex()` does the same thing as when `ASN1_item_d2i()` comes to the point of decoding the SubjectPublicKeyInfo part of an X.509 certificate.\r\n\r\nSo yeah, for a conversion of a SubjectPublicKeyInfo to a X509_PUBKEY with a provider side EVP_PKEY, the function to rewrite is `d2i_X509_PUBKEY()`...  and yes, I do hear the problem with knowing if it gets called down the line from a decoder or not and the recursion problem there.  We have a similar problem with `d2i_PrivateKey()`, which has a proposed workaround that's still in an OpenSSL PR: openssl/openssl#13591.  I haven't given that workaround enough thought yet to comment on it, but it might be an inspiration.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T20:44:39Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14942151960","type":"IssueCommentEvent","actor":{"id":698918,"login":"levitte","display_login":"levitte","gravatar_id":"","url":"https://api.github.com/users/levitte","avatar_url":"https://avatars.githubusercontent.com/u/698918?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","id":782037360,"node_id":"MDExOlB1bGxSZXF1ZXN0NTUxNjY1NzY5","number":267,"title":"removal of internal OSSL dependencies","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":37,"created_at":"2021-01-08T11:02:49Z","updated_at":"2021-01-25T20:51:22Z","closed_at":"2021-01-19T06:07:31Z","author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/267","html_url":"https://github.com/open-quantum-safe/openssl/pull/267","diff_url":"https://github.com/open-quantum-safe/openssl/pull/267.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/267.patch"},"body":"Addresses various [improvement suggestions](https://github.com/open-quantum-safe/openssl/commit/603b1f764dda7739074278c7e9d0e7db20384828#commitcomment-45737460) by @mattcaswell: Thanks!\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/767104578","html_url":"https://github.com/open-quantum-safe/openssl/pull/267#issuecomment-767104578","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/267","id":767104578,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NzEwNDU3OA==","user":{"login":"levitte","id":698918,"node_id":"MDQ6VXNlcjY5ODkxOA==","avatar_url":"https://avatars.githubusercontent.com/u/698918?v=4","gravatar_id":"","url":"https://api.github.com/users/levitte","html_url":"https://github.com/levitte","followers_url":"https://api.github.com/users/levitte/followers","following_url":"https://api.github.com/users/levitte/following{/other_user}","gists_url":"https://api.github.com/users/levitte/gists{/gist_id}","starred_url":"https://api.github.com/users/levitte/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/levitte/subscriptions","organizations_url":"https://api.github.com/users/levitte/orgs","repos_url":"https://api.github.com/users/levitte/repos","events_url":"https://api.github.com/users/levitte/events{/privacy}","received_events_url":"https://api.github.com/users/levitte/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T20:51:22Z","updated_at":"2021-01-25T20:51:22Z","author_association":"NONE","body":"We have avoided, as much as possible, to make too much changes for provider stuff in the ASN.1 code...  some of it is definitely not made for that.\r\nYou mentioned ASN1_item_sign_ex()...  The ASN1_item_sign and ASN1_item_verify set of functions would really need to be rewritten from zero, and carry more signs of hacks than well thought out functionality, in my not very humble opinion.  I was able to butcher ASN1_item_verify_ctx() to work with provider side keys, but oh boy how I dislike the result...","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T20:51:22Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"14942780837","type":"IssueCommentEvent","actor":{"id":16247285,"login":"christianpaquin","display_login":"christianpaquin","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","avatar_url":"https://avatars.githubusercontent.com/u/16247285?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882","id":792340302,"node_id":"MDU6SXNzdWU3OTIzNDAzMDI=","number":882,"title":"Outdated SIKE code","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-01-22T22:16:29Z","updated_at":"2021-01-25T21:51:29Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"The timing side-channel test from #881 flags this as a potential timing leak. It was fixed upstream last June.\r\n\r\nhttps://github.com/open-quantum-safe/liboqs/blob/fb5484cda68dac115dc563593c68388f89444b95/src/kem/sike/external/sike.c#L79-L82","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/767135766","html_url":"https://github.com/open-quantum-safe/liboqs/issues/882#issuecomment-767135766","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/882","id":767135766,"node_id":"MDEyOklzc3VlQ29tbWVudDc2NzEzNTc2Ng==","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"created_at":"2021-01-25T21:51:29Z","updated_at":"2021-01-25T21:51:29Z","author_association":"CONTRIBUTOR","body":"Thanks for the info. SIKE is up-to-date, but it looks like this code snippet has not been updated. Weird; I'll look into it.","performed_via_github_app":null}},"public":true,"created_at":"2021-01-25T21:51:29Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
