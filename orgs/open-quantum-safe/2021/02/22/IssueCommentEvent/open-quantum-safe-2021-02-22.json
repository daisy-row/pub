{"id":"15263351974","type":"IssueCommentEvent","actor":{"id":16247285,"login":"christianpaquin","display_login":"christianpaquin","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","avatar_url":"https://avatars.githubusercontent.com/u/16247285?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","id":812948985,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3MTc5MTA0","number":286,"title":"Integrates tag 1.1.1j from upstream.","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-21T20:57:18Z","updated_at":"2021-02-22T02:28:46Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/286","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","diff_url":"https://github.com/open-quantum-safe/openssl/pull/286.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/286.patch"},"body":"Integrates release [1.1.1j](https://github.com/openssl/openssl/tree/OpenSSL_1_1_1j) from upstream, fixes #281.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/782995819","html_url":"https://github.com/open-quantum-safe/openssl/pull/286#issuecomment-782995819","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","id":782995819,"node_id":"MDEyOklzc3VlQ29tbWVudDc4Mjk5NTgxOQ==","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T02:28:46Z","updated_at":"2021-02-22T02:28:46Z","author_association":"NONE","body":"@xvzcf, does the openssl code base needs an update to use updated oqs algs? CI complains about rainbow and dilithium. ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T02:28:46Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15264921688","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","id":812948985,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3MTc5MTA0","number":286,"title":"Integrates tag 1.1.1j from upstream.","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-02-21T20:57:18Z","updated_at":"2021-02-22T06:23:14Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/286","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","diff_url":"https://github.com/open-quantum-safe/openssl/pull/286.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/286.patch"},"body":"Integrates release [1.1.1j](https://github.com/openssl/openssl/tree/OpenSSL_1_1_1j) from upstream, fixes #281.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783120604","html_url":"https://github.com/open-quantum-safe/openssl/pull/286#issuecomment-783120604","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","id":783120604,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzEyMDYwNA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T06:23:14Z","updated_at":"2021-02-22T06:23:14Z","author_association":"MEMBER","body":"@christianpaquin can I ask which code base you started off with? To me this looks like `python3 oqs-template/generate.py` has not been run with the latest `generate.yml` (including the latest rainbow and dilithium algs).","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T06:23:14Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15264962470","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-22T06:27:55Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783122930","html_url":"https://github.com/open-quantum-safe/openssl/issues/285#issuecomment-783122930","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","id":783122930,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzEyMjkzMA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T06:27:55Z","updated_at":"2021-02-22T06:27:55Z","author_association":"MEMBER","body":"Can I ask the exact sequence of (build) commands you executed to arrive at this? What's the contents  of `oqs/include/oqs/oqsconfig.h` (first 7 lines and the lines dealing with Dilithium)?","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T06:27:55Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15264964915","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-22T06:28:12Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783123067","html_url":"https://github.com/open-quantum-safe/openssl/issues/285#issuecomment-783123067","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","id":783123067,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzEyMzA2Nw==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T06:28:12Z","updated_at":"2021-02-22T06:28:12Z","author_association":"MEMBER","body":"Can I ask the exact sequence of (build) commands you executed to arrive at this? What's the contents  of `oqs/include/oqs/oqsconfig.h` (first 7 lines and the lines dealing with Dilithium)?","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T06:28:12Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15265074076","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896","id":801401722,"node_id":"MDU6SXNzdWU4MDE0MDE3MjI=","number":896,"title":"Missing AVX2 version of Classic McEliece","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-02-04T15:42:40Z","updated_at":"2021-02-22T06:40:25Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"We only pull in the vec (vectorized plain C) implementation of Classic McEliece from PQClean; we should also pull in the avx2 implementation.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783129393","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-783129393","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","id":783129393,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzEyOTM5Mw==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T06:40:25Z","updated_at":"2021-02-22T06:40:25Z","author_association":"MEMBER","body":"Is anyone already working this issue? When looking at it also noticed that a presumably idempotent `python3 scripts/copy_from_upstream/copy_from_upstream.py copy` changes a file (just a nit - newline missing)... Would also address that then.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T06:40:25Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15265923912","type":"IssueCommentEvent","actor":{"id":974662,"login":"thomwiggers","display_login":"thomwiggers","gravatar_id":"","url":"https://api.github.com/users/thomwiggers","avatar_url":"https://avatars.githubusercontent.com/u/974662?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/915","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/915/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/915/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/915/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/915","id":808605157,"node_id":"MDExOlB1bGxSZXF1ZXN0NTczNjE4MDk0","number":915,"title":"Support OpenSSL on Windows","user":{"login":"thomwiggers","id":974662,"node_id":"MDQ6VXNlcjk3NDY2Mg==","avatar_url":"https://avatars.githubusercontent.com/u/974662?v=4","gravatar_id":"","url":"https://api.github.com/users/thomwiggers","html_url":"https://github.com/thomwiggers","followers_url":"https://api.github.com/users/thomwiggers/followers","following_url":"https://api.github.com/users/thomwiggers/following{/other_user}","gists_url":"https://api.github.com/users/thomwiggers/gists{/gist_id}","starred_url":"https://api.github.com/users/thomwiggers/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomwiggers/subscriptions","organizations_url":"https://api.github.com/users/thomwiggers/orgs","repos_url":"https://api.github.com/users/thomwiggers/repos","events_url":"https://api.github.com/users/thomwiggers/events{/privacy}","received_events_url":"https://api.github.com/users/thomwiggers/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2021-02-15T14:56:50Z","updated_at":"2021-02-22T08:05:56Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/915","html_url":"https://github.com/open-quantum-safe/liboqs/pull/915","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/915.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/915.patch"},"body":"Attempts to add support for OpenSSL on Windows. We probably should add this to the CI matrix as well.\r\n\r\nSee also https://github.com/open-quantum-safe/liboqs-rust/issues/17","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783176755","html_url":"https://github.com/open-quantum-safe/liboqs/pull/915#issuecomment-783176755","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/915","id":783176755,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzE3Njc1NQ==","user":{"login":"thomwiggers","id":974662,"node_id":"MDQ6VXNlcjk3NDY2Mg==","avatar_url":"https://avatars.githubusercontent.com/u/974662?v=4","gravatar_id":"","url":"https://api.github.com/users/thomwiggers","html_url":"https://github.com/thomwiggers","followers_url":"https://api.github.com/users/thomwiggers/followers","following_url":"https://api.github.com/users/thomwiggers/following{/other_user}","gists_url":"https://api.github.com/users/thomwiggers/gists{/gist_id}","starred_url":"https://api.github.com/users/thomwiggers/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomwiggers/subscriptions","organizations_url":"https://api.github.com/users/thomwiggers/orgs","repos_url":"https://api.github.com/users/thomwiggers/repos","events_url":"https://api.github.com/users/thomwiggers/events{/privacy}","received_events_url":"https://api.github.com/users/thomwiggers/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T08:05:56Z","updated_at":"2021-02-22T08:05:56Z","author_association":"MEMBER","body":"The Windows guard was changes so that OpenSSL is disabled by default on Windows and enabled by default otherwise.\r\n\r\nBIKE is unavailable on Windows now, and enabled by default otherwise using `cmake_dependent_option`:\r\n```cmake\r\n cmake_dependent_option(OQS_ENABLE_KEM_BIKE \"\" ON \"NOT WIN32\" OFF)\r\n ```","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T08:05:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15268511452","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","id":813404186,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3NTU3Njc4","number":920,"title":"Update Falcon & McEliece (adding AVX)","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-22T11:16:48Z","updated_at":"2021-02-22T11:29:58Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/920","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/920.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/920.patch"},"body":"Could fix #896 and #917 \r\n\r\nPlease review initial commit to see changes that led to full PR (running `copy_from_upstream`)\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783308093","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920#issuecomment-783308093","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","id":783308093,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzMwODA5Mw==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T11:29:58Z","updated_at":"2021-02-22T11:29:58Z","author_association":"MEMBER","body":"@jschanck, @dstebila As the code is now building (improving on https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-780596304 ) would you have time/interest to take a look as to what's happening here with address-sanitizer in (newly added) McEliece-AVX code ?\r\n\r\n@bhess Are you OK with the changes done to `copy_from_upstream` (in https://github.com/open-quantum-safe/liboqs/pull/920/commits/d0fc088b6b9a4226ba130e97bcbb5cb326cb738a)\r\n\r\nAnyone, maybe @xvzcf (as I have no experience whatsoever with this): Any idea what this is?\r\n\r\n> /usr/bin/ld: src/kem/classic_mceliece/CMakeFiles/classic_mceliece_348864_avx.dir/pqclean_mceliece348864_avx/transpose_64x256_sp_asm.S.o: relocation R_X86_64_PC32 against symbol `PQCLEAN_MCELIECE348864_AVX_MASK5_0' can not be used when making a shared object; recompile with -fPIC","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T11:29:58Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15268625977","type":"IssueCommentEvent","actor":{"id":149199,"login":"bhess","display_login":"bhess","gravatar_id":"","url":"https://api.github.com/users/bhess","avatar_url":"https://avatars.githubusercontent.com/u/149199?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","id":813404186,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3NTU3Njc4","number":920,"title":"Update Falcon & McEliece (adding AVX)","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-02-22T11:16:48Z","updated_at":"2021-02-22T11:39:32Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/920","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/920.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/920.patch"},"body":"Could fix #896 and #917 \r\n\r\nPlease review initial commit to see changes that led to full PR (running `copy_from_upstream`)\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783313554","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920#issuecomment-783313554","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","id":783313554,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzMxMzU1NA==","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T11:39:32Z","updated_at":"2021-02-22T11:39:32Z","author_association":"CONTRIBUTOR","body":"> @bhess Are you OK with the changes done to `copy_from_upstream` (in [d0fc088](https://github.com/open-quantum-safe/liboqs/commit/d0fc088b6b9a4226ba130e97bcbb5cb326cb738a))\r\n\r\nLooks good.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T11:39:32Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15270401109","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896","id":801401722,"node_id":"MDU6SXNzdWU4MDE0MDE3MjI=","number":896,"title":"Missing AVX2 version of Classic McEliece","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-02-04T15:42:40Z","updated_at":"2021-02-22T14:02:00Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"We only pull in the vec (vectorized plain C) implementation of Classic McEliece from PQClean; we should also pull in the avx2 implementation.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783396818","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-783396818","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","id":783396818,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzM5NjgxOA==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T14:02:00Z","updated_at":"2021-02-22T14:02:00Z","author_association":"MEMBER","body":"I haven't worked on it since raising the issue with the comment above.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T14:02:00Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15270768278","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","id":813404186,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3NTU3Njc4","number":920,"title":"Update Falcon & McEliece (adding AVX)","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-02-22T11:16:48Z","updated_at":"2021-02-22T14:27:41Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/920","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/920.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/920.patch"},"body":"Could fix #896 and #917 \r\n\r\nPlease review initial commit to see changes that led to full PR (running `copy_from_upstream`)\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783413343","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920#issuecomment-783413343","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","id":783413343,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzQxMzM0Mw==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T14:27:40Z","updated_at":"2021-02-22T14:27:40Z","author_association":"MEMBER","body":"> @jschanck, @dstebila As the code is now building (improving on [#896 (comment)](https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-780596304) ) would you have time/interest to take a look as to what's happening here with address-sanitizer in (newly added) McEliece-AVX code ?\r\n\r\nIt seems like one of the keywords used in this file is a language extension, which clang with `-Wpendatic` [doesn't like](https://github.com/RIOT-OS/RIOT/issues/4560).\r\n\r\nOne fix is to add the following to `.CMake/compiler_opts.cmake` in the AddressSanitizer section:\r\n\r\n```\r\nadd_compile_options(-Wno-language-extension-token)\r\n```\r\n\r\nI verified locally that the CircleCI AddressSanitizer workflow passes with that option.  ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T14:27:41Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15272096908","type":"IssueCommentEvent","actor":{"id":25615540,"login":"jschanck","display_login":"jschanck","gravatar_id":"","url":"https://api.github.com/users/jschanck","avatar_url":"https://avatars.githubusercontent.com/u/25615540?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-22T15:55:27Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783474661","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921#issuecomment-783474661","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","id":783474661,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzQ3NDY2MQ==","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T15:55:27Z","updated_at":"2021-02-22T15:55:27Z","author_association":"CONTRIBUTOR","body":"The -7 return code is a bus error, which probably means the picnic code is violating an alignment assumption. It would help if you could run `./build/tests/test_sig picnic_L1_FS` (or any of the picnics) in a debugger to get us a stack trace. I can provide step by step instructions if necessary.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T15:55:27Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15273439478","type":"IssueCommentEvent","actor":{"id":54725951,"login":"prchander","display_login":"prchander","gravatar_id":"","url":"https://api.github.com/users/prchander","avatar_url":"https://avatars.githubusercontent.com/u/54725951?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-22T17:29:03Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783539764","html_url":"https://github.com/open-quantum-safe/openssl/issues/285#issuecomment-783539764","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","id":783539764,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzUzOTc2NA==","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T17:29:03Z","updated_at":"2021-02-22T17:29:03Z","author_association":"NONE","body":"// SPDX-License-Identifier: MIT\r\n\r\n#define OQS_VERSION_TEXT \"0.5.0-dev\"\r\n#define OQS_COMPILE_BUILD_TARGET \"x86_64-Linux-4.15.0-135-generic\"\r\n#define OQS_PORTABLE_BUILD 1\r\n\r\n#define OQS_KEM_DEFAULT OQS_KEM_alg_frodokem_640_aes\r\n#define OQS_SIG_DEFAULT OQS_SIG_alg_dilithium_2\r\n\r\n#define OQS_ENABLE_SIG_DILITHIUM 1\r\n#define OQS_ENABLE_SIG_dilithium_2 1\r\n#define OQS_ENABLE_SIG_dilithium_2_avx2 1\r\n#define OQS_ENABLE_SIG_dilithium_3 1\r\n#define OQS_ENABLE_SIG_dilithium_3_avx2 1\r\n#define OQS_ENABLE_SIG_dilithium_5 1\r\n#define OQS_ENABLE_SIG_dilithium_5_avx2 1\r\n#define OQS_ENABLE_SIG_dilithium_2_aes 1\r\n#define OQS_ENABLE_SIG_dilithium_2_aes_avx2 1\r\n#define OQS_ENABLE_SIG_dilithium_3_aes 1\r\n#define OQS_ENABLE_SIG_dilithium_3_aes_avx2 1\r\n#define OQS_ENABLE_SIG_dilithium_5_aes 1\r\n#define OQS_ENABLE_SIG_dilithium_5_aes_avx2 1\r\n\r\nSteps I used to build: \r\nGit clone liboqs\r\ngit clone openssl\r\n\r\nliboqs\r\ncmake -GNinja -DBUILD_SHARED_LIBS=ON..\r\ncmake -GNinja -DCMAKE_INSTALL_PREFIX=<OPENSSL_DIR>/oqs ..\r\nninja \r\nninja install \r\n\r\nOpenssl \r\n./Configure no-shared linux-x86_64 -lm\r\nsudo make -j\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T17:29:03Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15274305262","type":"IssueCommentEvent","actor":{"id":36664211,"login":"vt-alt","display_login":"vt-alt","gravatar_id":"","url":"https://api.github.com/users/vt-alt","avatar_url":"https://avatars.githubusercontent.com/u/36664211?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-22T18:37:05Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783584139","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921#issuecomment-783584139","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","id":783584139,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzU4NDEzOQ==","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"created_at":"2021-02-22T18:37:05Z","updated_at":"2021-02-22T18:37:05Z","author_association":"NONE","body":"@jschanck There is debug info:\r\n```\r\nbuilder@armh:~/RPM/BUILD/liboqs-0.4.0/build$ gdb -q --args tests/test_sig picnic_L1_FS\r\nReading symbols from tests/test_sig...\r\n(gdb) r\r\nStarting program: /usr/src/RPM/BUILD/liboqs-0.4.0/build/tests/test_sig picnic_L1_FS\r\nMissing separate debuginfo for /lib/ld-linux-armhf.so.3\r\nTry to install the hash file /usr/lib/debug/.build-id/e3/287234f3ff5ee7e626ed1c9d540bf78b9e2a33.debug\r\nMissing separate debuginfo for /lib/libpthread.so.0\r\nTry to install the hash file /usr/lib/debug/.build-id/89/6da01f341033dda0f970878d2bf6152ac55c05.debug\r\n[Thread debugging using libthread_db enabled]\r\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\r\nMissing separate debuginfo for /lib/libc.so.6\r\nTry to install the hash file /usr/lib/debug/.build-id/c0/6214a4cb9022db15afd570089a5ac5541009cc.debug\r\nMissing separate debuginfo for /lib/libcrypto.so.1.1\r\nTry to install the hash file /usr/lib/debug/.build-id/3a/795744a863b2d504d4fb4b56d477163810b45c.debug\r\nMissing separate debuginfo for /lib/libz.so.1\r\nTry to install the hash file /usr/lib/debug/.build-id/a5/bbc2d66aea59bbefe8e5d545fa61587db74611.debug\r\nMissing separate debuginfo for /lib/libdl.so.2\r\nTry to install the hash file /usr/lib/debug/.build-id/36/be1bc393031d6e2bf2b6ce6af22f589aac36d8.debug\r\nConfiguration info\r\n==================\r\nTarget platform:  armv8l-Linux-5.4.84-std-def-alt1\r\nCompiler:         gcc (10.2.1)\r\nCompile options:  [-Werror;-Wall;-Wextra;-Wpedantic;-Wstrict-prototypes;-Wshadow;-Wformat=2;-Wfloat-equal;-Wwrite-strings;-O3;-fomit-frame-pointer;-fdata-sections;-ffunction-sections;-Wl,--gc-sections;-Wbad-function-cast]\r\nOQS version:      0.5.0-dev\r\nGit commit:       unknown\r\nOpenSSL enabled:  Yes (OpenSSL 1.1.1i  8 Dec 2020)\r\nAES:              OpenSSL\r\nSHA-2:            OpenSSL\r\nSHA-3:            OpenSSL\r\nCPU exts active:   (portable build)\r\n\r\n[New Thread 0xf77403d0 (LWP 1140410)]\r\n================================================================================\r\nSample computation for signature picnic_L1_FS\r\n================================================================================\r\n\r\nThread 2 \"test_sig\" received signal SIGBUS, Bus error.\r\n[Switching to Thread 0xf77403d0 (LWP 1140410)]\r\noqs_sig_picnic_KeccakP1600_AddLanes (state=0xf773eec0,\r\n    data=0xf6e268df \"\\275\\262/\\213q\\377\\342\\353\\031\\250~v\\247\\070\\177\\342R{\\257\\t-\\252\\250\\026\\004\\371\\371\\312\\377^B\\326g\\326$*\\231B\\376M\\225\\257\\224\\334\\006#\\021|\\020\\337.\\001\\352\\252\\223\\235\\245\\334\\004\\371\\351\\225`\\343/Iy#8o\\331\\266r*\\362\\307{\\372\\325J\\037\\211\\363\\212\\027\\322\\376\\233_\\b\\345^\\314*\\231\\341\\025\",\r\n    laneCount=laneCount@entry=12) at ../src/sig/picnic/external/sha3/opt64/KeccakP-1600-opt64.c:140\r\n140               ((uint64_t*)state)[i+0] ^= ((uint64_t*)data)[i+0];\r\n(gdb) list\r\n135         else\r\n136     #endif\r\n137         {\r\n138           /* Otherwise... */\r\n139           for( ; (i+8)<=laneCount; i+=8) {\r\n140               ((uint64_t*)state)[i+0] ^= ((uint64_t*)data)[i+0];\r\n141               ((uint64_t*)state)[i+1] ^= ((uint64_t*)data)[i+1];\r\n142               ((uint64_t*)state)[i+2] ^= ((uint64_t*)data)[i+2];\r\n143               ((uint64_t*)state)[i+3] ^= ((uint64_t*)data)[i+3];\r\n144               ((uint64_t*)state)[i+4] ^= ((uint64_t*)data)[i+4];\r\n(gdb) bt\r\n#0  oqs_sig_picnic_KeccakP1600_AddLanes (state=0xf773eec0,\r\n    data=0xf6e268df \"\\275\\262/\\213q\\377\\342\\353\\031\\250~v\\247\\070\\177\\342R{\\257\\t-\\252\\250\\026\\004\\371\\371\\312\\377^B\\326g\\326$*\\231B\\376M\\225\\257\\224\\334\\006#\\021|\\020\\337.\\001\\352\\252\\223\\235\\245\\334\\004\\371\\351\\225`\\343/Iy#8o\\331\\266r*\\362\\307{\\372\\325J\\037\\211\\363\\212\\027\\322\\376\\233_\\b\\345^\\314*\\231\\341\\025\",\r\n    laneCount=laneCount@entry=12) at ../src/sig/picnic/external/sha3/opt64/KeccakP-1600-opt64.c:140\r\n#1  0xf7c18fba in oqs_sig_picnic_KeccakP1600_AddBytes (state=state@entry=0xf773eec0,\r\n    data=0xf6e268df \"\\275\\262/\\213q\\377\\342\\353\\031\\250~v\\247\\070\\177\\342R{\\257\\t-\\252\\250\\026\\004\\371\\371\\312\\377^B\\326g\\326$*\\231B\\376M\\225\\257\\224\\334\\006#\\021|\\020\\337.\\001\\352\\252\\223\\235\\245\\334\\004\\371\\351\\225`\\343/Iy#8o\\331\\266r*\\362\\307{\\372\\325J\\037\\211\\363\\212\\027\\322\\376\\233_\\b\\345^\\314*\\231\\341\\025\",\r\n    offset=0, length=length@entry=97) at ../src/sig/picnic/external/sha3/opt64/KeccakP-1600-opt64.c:195\r\n#2  0xf7c1835c in oqs_sig_picnic_KeccakWidth1600_SpongeAbsorb (instance=instance@entry=0xf773eec0, data=<optimized out>, dataByteLen=10512)\r\n    at ../src/sig/picnic/external/sha3/KeccakSponge.inc:198\r\n#3  0xf7c18080 in oqs_sig_picnic_Keccak_HashUpdate (instance=instance@entry=0xf773eec0, data=<optimized out>, databitlen=<optimized out>)\r\n    at ../src/sig/picnic/external/sha3/KeccakHash.c:41\r\n#4  0xf7c11510 in hash_update (size=<optimized out>, data=<optimized out>, ctx=0xf773eec0) at ../src/sig/picnic/external/kdf_shake.h:263\r\n#5  H3 (context=0xf773fbe0, prf=0xf6e09000, pp=0xf7fc27e4 <instances+100>) at ../src/sig/picnic/external/picnic_impl.c:680\r\n#6  oqs_sig_picnic_impl_sign (pp=pp@entry=0xf7fc27e4 <instances+100>, context=context@entry=0xf773fbe0, sig=sig@entry=0xf6e006e8 \"\",\r\n    siglen=siglen@entry=0xf773fd28) at ../src/sig/picnic/external/picnic_impl.c:1183\r\n#7  0xf7c0fd28 in oqs_sig_picnic_sign (sk=sk@entry=0xf773fc88,\r\n    message=message@entry=0xf6e00680 \"Q\\246\\257\\030\\333f\\vtt\\025\\243\\355\\374\\070\\004\\302\\333\\221\\250h\\336z\\264'g\\356A=\\341\\224\\342\\272v\\344\\346\\326\\022\\aHL\\201\\351\\302\\206'f\\327\\365Q\\270K\\322\\021o\\247\\032\\343\\267\\277\\071t\\271\", message_len=message_len@entry=100, signature=signature@entry=0xf6e006e8 \"\",\r\n    signature_len=<optimized out>, signature_len@entry=0xf773fd28) at ../src/sig/picnic/external/picnic.c:235\r\n#8  0xf7c0620a in common_picnic_sign (sig_len=0xf773fd28, sig=0xf6e006e8 \"\", msg_len=100,\r\n    msg=0xf6e00680 \"Q\\246\\257\\030\\333f\\vtt\\025\\243\\355\\374\\070\\004\\302\\333\\221\\250h\\336z\\264'g\\356A=\\341\\224\\342\\272v\\344\\346\\326\\022\\aHL\\201\\351\\302\\206'f\\327\\365Q\\270K\\322\\021o\\247\\032\\343\\267\\277\\071t\\271\",\r\n    priv=0xf6e00648 \"\\001m\\202M\\323\\306\\274\\202Qaw\\221R\\270\\272\\251\\235\\037\\244\\250\\305\\027\\264\\260\\210\\376\\023`^E,H%!/p\\025\\334\\330X\\017\\370G\\237\\254~\\362\\\"\\375\", parameters=Picnic_L1_FS) at ../src/sig/picnic/sig_picnic.c:97\r\n#9  OQS_SIG_picnic_L1_FS_sign (signature=0xf6e006e8 \"\", signature_len=0xf773fd28,\r\n    message=0xf6e00680 \"Q\\246\\257\\030\\333f\\vtt\\025\\243\\355\\374\\070\\004\\302\\333\\221\\250h\\336z\\264'g\\356A=\\341\\224\\342\\272v\\344\\346\\326\\022\\aHL\\201\\351\\302\\206'f\\327\\365Q\\270K\\322\\021o\\247\\032\\343\\267\\277\\071t\\271\", message_len=100, secret_key=<optimized out>) at ../src/sig/picnic/sig_picnic.c:149\r\n#10 0xf7ce90a4 in OQS_SIG_sign (sig=sig@entry=0xf6e005f8, signature=signature@entry=0xf6e006e8 \"\", signature_len=signature_len@entry=0xf773fd28,\r\n    message=message@entry=0xf6e00680 \"Q\\246\\257\\030\\333f\\vtt\\025\\243\\355\\374\\070\\004\\302\\333\\221\\250h\\336z\\264'g\\356A=\\341\\224\\342\\272v\\344\\346\\326\\022\\aHL\\201\\351\\302\\206'f\\327\\365Q\\270K\\322\\021o\\247\\032\\343\\267\\277\\071t\\271\", message_len=<optimized out>, message_len@entry=100, secret_key=<optimized out>,\r\n    secret_key@entry=0xf6e00648 \"\\001m\\202M\\323\\306\\274\\202Qaw\\221R\\270\\272\\251\\235\\037\\244\\250\\305\\027\\264\\260\\210\\376\\023`^E,H%!/p\\025\\334\\330X\\017\\370G\\237\\254~\\362\\\"\\375\") at ../src/sig/sig.c:914\r\n#11 0x00400dfc in sig_test_correctness (method_name=<optimized out>) at ../tests/test_sig.c:58\r\n#12 0x00400f6e in test_wrapper (arg=0xfffef464) at ../tests/test_sig.c:104\r\n#13 0xf7a11718 in start_thread () from /lib/libpthread.so.0\r\n#14 0xf79a8e4c in ?? () from /lib/libc.so.6\r\nBacktrace stopped: previous frame identical to this frame (corrupt stack?)\r\n(gdb) p/1 data\r\n$1 = 0xf6e268df\r\n\r\n```\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T18:37:06Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
