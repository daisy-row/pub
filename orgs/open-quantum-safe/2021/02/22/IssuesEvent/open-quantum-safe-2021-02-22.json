{"id":"15266872463","type":"IssuesEvent","actor":{"id":974662,"login":"thomwiggers","display_login":"thomwiggers","gravatar_id":"","url":"https://api.github.com/users/thomwiggers","avatar_url":"https://avatars.githubusercontent.com/u/974662?"},"repo":{"id":252143304,"name":"open-quantum-safe/liboqs-rust","url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust"},"payload":{"action":"closed","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust/issues/28","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust/issues/28/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust/issues/28/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs-rust/issues/28/events","html_url":"https://github.com/open-quantum-safe/liboqs-rust/issues/28","id":808371454,"node_id":"MDU6SXNzdWU4MDgzNzE0NTQ=","number":28,"title":"Support OQS_MINIMAL_BUILD","user":{"login":"thomwiggers","id":974662,"node_id":"MDQ6VXNlcjk3NDY2Mg==","avatar_url":"https://avatars.githubusercontent.com/u/974662?v=4","gravatar_id":"","url":"https://api.github.com/users/thomwiggers","html_url":"https://github.com/thomwiggers","followers_url":"https://api.github.com/users/thomwiggers/followers","following_url":"https://api.github.com/users/thomwiggers/following{/other_user}","gists_url":"https://api.github.com/users/thomwiggers/gists{/gist_id}","starred_url":"https://api.github.com/users/thomwiggers/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/thomwiggers/subscriptions","organizations_url":"https://api.github.com/users/thomwiggers/orgs","repos_url":"https://api.github.com/users/thomwiggers/repos","events_url":"https://api.github.com/users/thomwiggers/events{/privacy}","received_events_url":"https://api.github.com/users/thomwiggers/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-15T09:44:11Z","updated_at":"2021-02-22T09:22:31Z","closed_at":"2021-02-22T09:22:31Z","author_association":"MEMBER","active_lock_reason":null,"body":"https://github.com/Open-Quantum-Safe/liboqs/issues/903","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T09:22:31Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15268430131","type":"IssuesEvent","actor":{"id":36664211,"login":"vt-alt","display_login":"vt-alt","gravatar_id":"","url":"https://api.github.com/users/vt-alt","avatar_url":"https://avatars.githubusercontent.com/u/36664211?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"opened","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-22T11:23:17Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T11:23:17Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15270333349","type":"IssuesEvent","actor":{"id":71976077,"login":"KalgovIlya","display_login":"KalgovIlya","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","avatar_url":"https://avatars.githubusercontent.com/u/71976077?"},"repo":{"id":218087071,"name":"open-quantum-safe/oqs-demos","url":"https://api.github.com/repos/open-quantum-safe/oqs-demos"},"payload":{"action":"opened","issue":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69","repository_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/comments","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/events","html_url":"https://github.com/open-quantum-safe/oqs-demos/issues/69","id":813525454,"node_id":"MDU6SXNzdWU4MTM1MjU0NTQ=","number":69,"title":"ERR_CERT_WEAK_KEY in Pre-built Chromium binary","user":{"login":"KalgovIlya","id":71976077,"node_id":"MDQ6VXNlcjcxOTc2MDc3","avatar_url":"https://avatars.githubusercontent.com/u/71976077?v=4","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","html_url":"https://github.com/KalgovIlya","followers_url":"https://api.github.com/users/KalgovIlya/followers","following_url":"https://api.github.com/users/KalgovIlya/following{/other_user}","gists_url":"https://api.github.com/users/KalgovIlya/gists{/gist_id}","starred_url":"https://api.github.com/users/KalgovIlya/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/KalgovIlya/subscriptions","organizations_url":"https://api.github.com/users/KalgovIlya/orgs","repos_url":"https://api.github.com/users/KalgovIlya/repos","events_url":"https://api.github.com/users/KalgovIlya/events{/privacy}","received_events_url":"https://api.github.com/users/KalgovIlya/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-02-22T13:57:12Z","updated_at":"2021-02-22T13:57:12Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I see a warning about a weak key: ERR_CERT_WEAK_KEY, when connecting to test servers.\r\n![pic1](https://user-images.githubusercontent.com/71976077/108717541-706bf200-752e-11eb-928e-b0239f03b32e.png)\r\nIts happening with all signature algorithms supported by OQS-enabled Chromium build 0.4.0, except ecdsap256 and rsa3072. The secure connection symbol is missing on server page.\r\n![pic2](https://user-images.githubusercontent.com/71976077/108717578-7e217780-752e-11eb-9a56-e9284048a266.png)\r\nAlso the \"subject public key\" field in certificate details is empty. \r\n![pic3](https://user-images.githubusercontent.com/71976077/108717601-85488580-752e-11eb-838a-899533cd9d79.png)\r\nWhy does Chromium display that field incorrectly? What could be the problem and how to solve it?\r\n\r\n\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-22T13:57:13Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
