{"id":"15278187802","type":"IssueCommentEvent","actor":{"id":25615540,"login":"jschanck","display_login":"jschanck","gravatar_id":"","url":"https://api.github.com/users/jschanck","avatar_url":"https://avatars.githubusercontent.com/u/25615540?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-23T00:53:57Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/783787956","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921#issuecomment-783787956","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","id":783787956,"node_id":"MDEyOklzc3VlQ29tbWVudDc4Mzc4Nzk1Ng==","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T00:53:57Z","updated_at":"2021-02-23T00:53:57Z","author_association":"CONTRIBUTOR","body":"Thanks! This will be fixed by #922.\r\n\r\nIn the meantime, it should be sufficient to change line 73 of src/sig/picnic/CMakeLists.txt to\r\n```c\r\ntarget_compile_definitions(picnic PRIVATE PICNIC_STATIC NO_MISALIGNED_ACCESSES\r\n```\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T00:53:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15278498398","type":"IssueCommentEvent","actor":{"id":16247285,"login":"christianpaquin","display_login":"christianpaquin","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","avatar_url":"https://avatars.githubusercontent.com/u/16247285?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286/events","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","id":812948985,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3MTc5MTA0","number":286,"title":"Integrates tag 1.1.1j from upstream.","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-02-21T20:57:18Z","updated_at":"2021-02-23T01:38:02Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/286","html_url":"https://github.com/open-quantum-safe/openssl/pull/286","diff_url":"https://github.com/open-quantum-safe/openssl/pull/286.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/286.patch"},"body":"Integrates release [1.1.1j](https://github.com/openssl/openssl/tree/OpenSSL_1_1_1j) from upstream, fixes #281.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783802625","html_url":"https://github.com/open-quantum-safe/openssl/pull/286#issuecomment-783802625","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/286","id":783802625,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MzgwMjYyNQ==","user":{"login":"christianpaquin","id":16247285,"node_id":"MDQ6VXNlcjE2MjQ3Mjg1","avatar_url":"https://avatars.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T01:38:02Z","updated_at":"2021-02-23T01:38:02Z","author_association":"NONE","body":"> @christianpaquin can I ask which code base you started off with? To me this looks like `python3 oqs-template/generate.py` has not been run with the latest `generate.yml` (including the latest rainbow and dilithium algs).\r\n\r\nYeah, I think my dev env was not up to date. github is confused about not recognizing my merged files. I'll probably need to re-start fresh.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T01:38:02Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15281126745","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-23T07:36:34Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/783976378","html_url":"https://github.com/open-quantum-safe/openssl/issues/285#issuecomment-783976378","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","id":783976378,"node_id":"MDEyOklzc3VlQ29tbWVudDc4Mzk3NjM3OA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T07:36:33Z","updated_at":"2021-02-23T07:36:33Z","author_association":"MEMBER","body":"Strange - this all looks ok -- except the line `cmake -GNinja -DBUILD_SHARED_LIBS=ON..`: Why do you to this? You seem to want to run everything static. When I do all of the above (except the shared liboqs build) within docker image `openquantumsafe/ci-ubuntu-focal-x86_64`, everything builds OK and this runs fine as expected:\r\n```\r\nroot@2b0a54afbd10:~/openssl# apps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nroot@2b0a54afbd10:~/openssl# ls -l dilithium2_srv.key \r\n-rw------- 1 root root 5319 Feb 23 08:33 dilithium2_srv.key\r\n```","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T07:36:34Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15281704350","type":"IssueCommentEvent","actor":{"id":54725951,"login":"prchander","display_login":"prchander","gravatar_id":"","url":"https://api.github.com/users/prchander","avatar_url":"https://avatars.githubusercontent.com/u/54725951?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-23T08:32:13Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/784003565","html_url":"https://github.com/open-quantum-safe/openssl/issues/285#issuecomment-784003565","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","id":784003565,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDAwMzU2NQ==","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T08:32:13Z","updated_at":"2021-02-23T08:32:13Z","author_association":"NONE","body":"@baentsch Thanks for your help. I guess I just wanted to be able to use it system wide. Removing that helped and all of Dilithium works now ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T08:32:14Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15281708240","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":218087071,"name":"open-quantum-safe/oqs-demos","url":"https://api.github.com/repos/open-quantum-safe/oqs-demos"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69","repository_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/comments","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/events","html_url":"https://github.com/open-quantum-safe/oqs-demos/issues/69","id":813525454,"node_id":"MDU6SXNzdWU4MTM1MjU0NTQ=","number":69,"title":"ERR_CERT_WEAK_KEY in Pre-built Chromium binary","user":{"login":"KalgovIlya","id":71976077,"node_id":"MDQ6VXNlcjcxOTc2MDc3","avatar_url":"https://avatars.githubusercontent.com/u/71976077?v=4","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","html_url":"https://github.com/KalgovIlya","followers_url":"https://api.github.com/users/KalgovIlya/followers","following_url":"https://api.github.com/users/KalgovIlya/following{/other_user}","gists_url":"https://api.github.com/users/KalgovIlya/gists{/gist_id}","starred_url":"https://api.github.com/users/KalgovIlya/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/KalgovIlya/subscriptions","organizations_url":"https://api.github.com/users/KalgovIlya/orgs","repos_url":"https://api.github.com/users/KalgovIlya/repos","events_url":"https://api.github.com/users/KalgovIlya/events{/privacy}","received_events_url":"https://api.github.com/users/KalgovIlya/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-02-22T13:57:12Z","updated_at":"2021-02-23T08:32:34Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I see a warning about a weak key: ERR_CERT_WEAK_KEY, when connecting to test servers.\r\n![pic1](https://user-images.githubusercontent.com/71976077/108717541-706bf200-752e-11eb-928e-b0239f03b32e.png)\r\nIt’s happening with all signature algorithms supported by OQS-enabled Chromium build 0.4.0, except ecdsap256 and rsa3072. The secure connection symbol is missing on server page.\r\n![pic2](https://user-images.githubusercontent.com/71976077/108717578-7e217780-752e-11eb-9a56-e9284048a266.png)\r\nAlso the \"subject public key\" field in certificate details is empty. \r\n![pic3](https://user-images.githubusercontent.com/71976077/108717601-85488580-752e-11eb-838a-899533cd9d79.png)\r\nWhy does Chromium display that field incorrectly? What could be the problem and how to solve it?\r\n\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/comments/784003745","html_url":"https://github.com/open-quantum-safe/oqs-demos/issues/69#issuecomment-784003745","issue_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69","id":784003745,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDAwMzc0NQ==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T08:32:34Z","updated_at":"2021-02-23T08:32:34Z","author_association":"MEMBER","body":"Strange. To reproduce, can I ask how you ran the executable? Platform? As you apparently installed the cert, what does \"SubjectPublicKeyAlgorithm\" display? Did you try (especially) the supported algorithms as [documented in step 6 of the chromium deploy instructions](https://github.com/open-quantum-safe/oqs-demos/tree/main/chromium), e.g., `p256_kyber512`?","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T08:32:34Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15283237087","type":"IssueCommentEvent","actor":{"id":36664211,"login":"vt-alt","display_login":"vt-alt","gravatar_id":"","url":"https://api.github.com/users/vt-alt","avatar_url":"https://avatars.githubusercontent.com/u/36664211?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-23T10:35:49Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784102909","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921#issuecomment-784102909","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","id":784102909,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDEwMjkwOQ==","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T10:35:49Z","updated_at":"2021-02-23T10:35:49Z","author_association":"NONE","body":"@jschanck Thanks!","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T10:35:49Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15283597111","type":"IssueCommentEvent","actor":{"id":36664211,"login":"vt-alt","display_login":"vt-alt","gravatar_id":"","url":"https://api.github.com/users/vt-alt","avatar_url":"https://avatars.githubusercontent.com/u/36664211?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-23T11:04:03Z","closed_at":"2021-02-23T11:04:02Z","author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784118977","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921#issuecomment-784118977","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","id":784118977,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDExODk3Nw==","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T11:04:02Z","updated_at":"2021-02-23T11:04:02Z","author_association":"NONE","body":"Tested and there are no failures anymore on arm with the meantime fix.\r\n```\r\n====================== 504 passed, 131 skipped in 58.79s =======================\r\n```\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T11:04:03Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15284322157","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896","id":801401722,"node_id":"MDU6SXNzdWU4MDE0MDE3MjI=","number":896,"title":"Missing AVX2 version of Classic McEliece","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"assignees":[{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false}],"milestone":null,"comments":4,"created_at":"2021-02-04T15:42:40Z","updated_at":"2021-02-23T12:04:48Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"We only pull in the vec (vectorized plain C) implementation of Classic McEliece from PQClean; we should also pull in the avx2 implementation.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784153308","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-784153308","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","id":784153308,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDE1MzMwOA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T12:04:48Z","updated_at":"2021-02-23T12:04:48Z","author_association":"MEMBER","body":"FYI, #920 shall close this issue. One caveat: This is a \"quick fix\" in that it only enables import of \"vec\" and \"avx\" variants of McEliece; \"sse2\" and \"clean\" variants are explicitly suppressed: a) @bhess and @baentsch don't see much value in those variants; b) Supporting multiple optimized variants would make the \"portability logic\" _very_ convoluted.\r\n\r\nAnyone disagreeing with this logic, please either comment (negatively) on #920 and/or create a \"future-work\" item for multi-variant, portable CPU feature support. ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T12:04:48Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15285451805","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896","id":801401722,"node_id":"MDU6SXNzdWU4MDE0MDE3MjI=","number":896,"title":"Missing AVX2 version of Classic McEliece","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"assignees":[{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false}],"milestone":null,"comments":6,"created_at":"2021-02-04T15:42:40Z","updated_at":"2021-02-23T13:34:44Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"We only pull in the vec (vectorized plain C) implementation of Classic McEliece from PQClean; we should also pull in the avx2 implementation.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784206677","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896#issuecomment-784206677","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","id":784206677,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDIwNjY3Nw==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T13:34:44Z","updated_at":"2021-02-23T13:34:44Z","author_association":"MEMBER","body":"Those choices makes sense to me, Michael: AVX2 has the highest performance of the non-portable ones, and vec has the highest performance of the portable ones.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T13:34:44Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15285636959","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","id":813404186,"node_id":"MDExOlB1bGxSZXF1ZXN0NTc3NTU3Njc4","number":920,"title":"Update Falcon & McEliece (adding AVX)","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-02-22T11:16:48Z","updated_at":"2021-02-23T13:48:21Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/920","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/920.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/920.patch"},"body":"Could fix #896 and #917 \r\n\r\nPlease review initial commit to see changes that led to full PR (running `copy_from_upstream`)\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784214978","html_url":"https://github.com/open-quantum-safe/liboqs/pull/920#issuecomment-784214978","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/920","id":784214978,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDIxNDk3OA==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T13:48:21Z","updated_at":"2021-02-23T13:48:21Z","author_association":"MEMBER","body":"Oh, don't forget to update the algorithm data sheets in the docs folder.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T13:48:21Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15286823741","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/282","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/282/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/282/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/282/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/282","id":810369702,"node_id":"MDU6SXNzdWU4MTAzNjk3MDI=","number":282,"title":"Enabling all signature algorithms by default.","user":{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"assignees":[{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false},{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false}],"milestone":null,"comments":5,"created_at":"2021-02-17T17:06:43Z","updated_at":"2021-02-23T15:06:51Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"In [ssl/ssl_local.h](https://github.com/open-quantum-safe/openssl/blob/OQS-OpenSSL_1_1_1-stable/ssl/ssl_local.h#L207), there are `#define`s that assign one-hot encodings to each signature algorithm. These encodings are used in [ssl/ssl_cert_table.h](https://github.com/open-quantum-safe/openssl/blob/OQS-OpenSSL_1_1_1-stable/ssl/ssl_cert_table.h#L26), and are assigned to a uint32_t variable called `amask` [here](https://github.com/open-quantum-safe/openssl/blob/OQS-OpenSSL_1_1_1-stable/ssl/ssl_local.h#L1924).\r\n\r\nSince the encodings are one-hot, at most 32 different signature algorithms can be encoded, and since 8 bits are already used up by OpenSSL by default, at most 24 different OQS signature algorithms can be encoded and assigned to `amask` at any given instant. \r\n\r\nThis (possibly?) prevents us from enabling all signature algorithms by default, and the question is how we should deal with this.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/784267789","html_url":"https://github.com/open-quantum-safe/openssl/issues/282#issuecomment-784267789","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/282","id":784267789,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDI2Nzc4OQ==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T15:06:51Z","updated_at":"2021-02-23T15:06:51Z","author_association":"MEMBER","body":"After having just enabled all algs, this is the (not entirely surprising) response by a self-respecting compiler (OSX):\r\n\r\n```\r\nIn file included from ssl/ssl_cert.c:24:\r\nssl/ssl_cert_table.h:100:45: error: integer literal is too large to be represented in any integer type\r\n    {EVP_PKEY_P384_SPHINCSHARAKA192FSIMPLE, SSL_aP384_SPHINCSHARAKA192FSIMPLE}, /* SSL_PKEY_P384_SPHINCSHARAKA192FSIMPLE */\r\n                                            ^\r\nssl/ssl_local.h:355:43: note: expanded from macro 'SSL_aP384_SPHINCSHARAKA192FSIMPLE'\r\n#define SSL_aP384_SPHINCSHARAKA192FSIMPLE 0x400000000000000000000U\r\n```\r\n--> We'd need to \"widen\" integers beyond 64 bits, it seems. Doesn't feel right. \r\n\r\nWhat'd be the rationale behind including all algs? Do we _really_ need _all_? The count of Sphincs' algs alone made me dizzy....","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T15:06:51Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15287448980","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/917","id":810362382,"node_id":"MDU6SXNzdWU4MTAzNjIzODI=","number":917,"title":"Do a fresh pull from PQClean","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/11","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/11","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/11/labels","id":5734378,"node_id":"MDk6TWlsZXN0b25lNTczNDM3OA==","number":11,"title":"0.5.0 RC1","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":1,"closed_issues":9,"state":"open","created_at":"2020-08-05T00:29:37Z","updated_at":"2021-02-23T15:46:52Z","due_on":"2021-02-26T08:00:00Z","closed_at":null},"comments":1,"created_at":"2021-02-17T16:57:47Z","updated_at":"2021-02-23T15:46:52Z","closed_at":"2021-02-23T15:46:52Z","author_association":"MEMBER","active_lock_reason":null,"body":"","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/784297504","html_url":"https://github.com/open-quantum-safe/liboqs/issues/917#issuecomment-784297504","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917","id":784297504,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDI5NzUwNA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T15:46:52Z","updated_at":"2021-02-23T15:46:52Z","author_association":"MEMBER","body":"Closing via #920 ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T15:46:52Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15290299782","type":"IssueCommentEvent","actor":{"id":71976077,"login":"KalgovIlya","display_login":"KalgovIlya","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","avatar_url":"https://avatars.githubusercontent.com/u/71976077?"},"repo":{"id":218087071,"name":"open-quantum-safe/oqs-demos","url":"https://api.github.com/repos/open-quantum-safe/oqs-demos"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69","repository_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos","labels_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/comments","events_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69/events","html_url":"https://github.com/open-quantum-safe/oqs-demos/issues/69","id":813525454,"node_id":"MDU6SXNzdWU4MTM1MjU0NTQ=","number":69,"title":"ERR_CERT_WEAK_KEY in Pre-built Chromium binary","user":{"login":"KalgovIlya","id":71976077,"node_id":"MDQ6VXNlcjcxOTc2MDc3","avatar_url":"https://avatars.githubusercontent.com/u/71976077?v=4","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","html_url":"https://github.com/KalgovIlya","followers_url":"https://api.github.com/users/KalgovIlya/followers","following_url":"https://api.github.com/users/KalgovIlya/following{/other_user}","gists_url":"https://api.github.com/users/KalgovIlya/gists{/gist_id}","starred_url":"https://api.github.com/users/KalgovIlya/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/KalgovIlya/subscriptions","organizations_url":"https://api.github.com/users/KalgovIlya/orgs","repos_url":"https://api.github.com/users/KalgovIlya/repos","events_url":"https://api.github.com/users/KalgovIlya/events{/privacy}","received_events_url":"https://api.github.com/users/KalgovIlya/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-02-22T13:57:12Z","updated_at":"2021-02-23T19:14:57Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"I see a warning about a weak key: ERR_CERT_WEAK_KEY, when connecting to test servers.\r\n![pic1](https://user-images.githubusercontent.com/71976077/108717541-706bf200-752e-11eb-928e-b0239f03b32e.png)\r\nIt’s happening with all signature algorithms supported by OQS-enabled Chromium build 0.4.0, except ecdsap256 and rsa3072. The secure connection symbol is missing on server page.\r\n![pic2](https://user-images.githubusercontent.com/71976077/108717578-7e217780-752e-11eb-9a56-e9284048a266.png)\r\nAlso the \"subject public key\" field in certificate details is empty. \r\n![pic3](https://user-images.githubusercontent.com/71976077/108717601-85488580-752e-11eb-838a-899533cd9d79.png)\r\nWhy does Chromium display that field incorrectly? What could be the problem and how to solve it?\r\n\r\n\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/comments/784445310","html_url":"https://github.com/open-quantum-safe/oqs-demos/issues/69#issuecomment-784445310","issue_url":"https://api.github.com/repos/open-quantum-safe/oqs-demos/issues/69","id":784445310,"node_id":"MDEyOklzc3VlQ29tbWVudDc4NDQ0NTMxMA==","user":{"login":"KalgovIlya","id":71976077,"node_id":"MDQ6VXNlcjcxOTc2MDc3","avatar_url":"https://avatars.githubusercontent.com/u/71976077?v=4","gravatar_id":"","url":"https://api.github.com/users/KalgovIlya","html_url":"https://github.com/KalgovIlya","followers_url":"https://api.github.com/users/KalgovIlya/followers","following_url":"https://api.github.com/users/KalgovIlya/following{/other_user}","gists_url":"https://api.github.com/users/KalgovIlya/gists{/gist_id}","starred_url":"https://api.github.com/users/KalgovIlya/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/KalgovIlya/subscriptions","organizations_url":"https://api.github.com/users/KalgovIlya/orgs","repos_url":"https://api.github.com/users/KalgovIlya/repos","events_url":"https://api.github.com/users/KalgovIlya/events{/privacy}","received_events_url":"https://api.github.com/users/KalgovIlya/received_events","type":"User","site_admin":false},"created_at":"2021-02-23T19:14:57Z","updated_at":"2021-02-23T19:14:57Z","author_association":"NONE","body":"I used Chromium build from the releases page and ran the executable from the terminal with `./chrome` command. Platform Xubuntu 20.04. \"Subject Public Key Algorithm\" field displays following.\r\nAlgorithm combination: signature algorithm - `dilithium2`, key exchange algorithm - `p256_kyber90s512`, link - https://test.openquantumsafe.org:6299\r\n![pic4](https://user-images.githubusercontent.com/71976077/108895244-63c9c580-7624-11eb-86e8-c87f823c6eac.png)\r\n\r\n\"Subject public key\" field is empty.\r\n![pic5](https://user-images.githubusercontent.com/71976077/108895255-675d4c80-7624-11eb-8b1c-160694fa2696.png)\r\n\r\nTest pages, that uses key exchange algorithm p256_kyber512 show errors\r\n![pic6](https://user-images.githubusercontent.com/71976077/108895263-6a583d00-7624-11eb-9284-b938d588bcf3.png)\r\nI think, it's happening because Chromium didn't support this algorithm. At least it's not on the list of supported algorithms.\r\n>Therefore, only the following hybrid algorithms will work: P256_BIKE1L1CPA, P256_FRODO640AES, P256_KYBER90S512, P256_NTRU_HPS2048509, P256_LIGHTSABER, P256_SIDHP434, P256_SIKEP434.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T19:14:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
