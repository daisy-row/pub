{"id":"15283597151","type":"IssuesEvent","actor":{"id":36664211,"login":"vt-alt","display_login":"vt-alt","gravatar_id":"","url":"https://api.github.com/users/vt-alt","avatar_url":"https://avatars.githubusercontent.com/u/36664211?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"closed","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/921/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/921","id":813409050,"node_id":"MDU6SXNzdWU4MTM0MDkwNTA=","number":921,"title":"27 tests fail on ARM","user":{"login":"vt-alt","id":36664211,"node_id":"MDQ6VXNlcjM2NjY0MjEx","avatar_url":"https://avatars.githubusercontent.com/u/36664211?v=4","gravatar_id":"","url":"https://api.github.com/users/vt-alt","html_url":"https://github.com/vt-alt","followers_url":"https://api.github.com/users/vt-alt/followers","following_url":"https://api.github.com/users/vt-alt/following{/other_user}","gists_url":"https://api.github.com/users/vt-alt/gists{/gist_id}","starred_url":"https://api.github.com/users/vt-alt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vt-alt/subscriptions","organizations_url":"https://api.github.com/users/vt-alt/orgs","repos_url":"https://api.github.com/users/vt-alt/repos","events_url":"https://api.github.com/users/vt-alt/events{/privacy}","received_events_url":"https://api.github.com/users/vt-alt/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-02-22T11:23:17Z","updated_at":"2021-02-23T11:04:03Z","closed_at":"2021-02-23T11:04:02Z","author_association":"NONE","active_lock_reason":null,"body":"I try to build `liboqs` for an unstable branch of ALT Linux. There are tests failures on 32-bit ARM arch:\r\n```\r\n[00:01:54] =================================== FAILURES ===================================\r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw60] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw62] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw1] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw2] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw4] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw3] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54]         if sys.platform.startswith(\"win\") and 'APPVEYOR' in os.environ:\r\n[00:01:54]             if 'SPHINCS' in sig_name and ('192f' in sig_name or '192s' in sig_name or '256f' in sig_name or '256s' in sig_name):\r\n[00:01:54]                 pytest.skip('Skipping SPHINCS+ 192s and 256s tests on Windows AppVeyor builds')\r\n[00:01:54] >       helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('test_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_cmdline.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw29] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_FS\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_UR\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw0] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_full\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw41] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_full\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw6] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_UR'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_UR\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L3_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L3_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L1_full] ___________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_FS] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L3_UR] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_UR] ____________________________\r\n[00:01:54] [gw18] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_UR 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L5_FS] ____________________________\r\n[00:01:54] [gw61] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_FS', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_FS 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_FS] ____________________________\r\n[00:01:54] [gw16] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_FS'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L1_FS'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L1_FS\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L3_full] ___________________________\r\n[00:01:54] [gw63] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L3_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L3_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L3_full 1\r\n[00:01:54] \r\n[00:01:54] ____________________________ test_sig[picnic_L1_UR] ____________________________\r\n[00:01:54] [gw13] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L1_UR'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L1_UR', '1'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L1_UR 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw45] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)):\r\n[00:01:54]             pytest.skip('Not enabled')\r\n[00:01:54]     \r\n[00:01:54]         Path('build/mem-benchmark').mkdir(parents=True, exist_ok=True)\r\n[00:01:54]     \r\n[00:01:54]         for i in range(3):\r\n[00:01:54] >          helpers.run_subprocess([helpers.path_to_executable('test_sig_mem'), sig_name, str(i)])\r\n[00:01:54] \r\n[00:01:54] tests/test_mem.py:27: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/test_sig_mem', 'picnic_L5_full', '1']\r\n[00:01:54] working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 0\r\n[00:01:54] . > ./build/tests/test_sig_mem picnic_L5_full 1\r\n[00:01:54] \r\n[00:01:54] ___________________________ test_sig[picnic_L5_full] ___________________________\r\n[00:01:54] [gw52] linux -- Python 3.8.6 /usr/bin/python3\r\n[00:01:54] \r\n[00:01:54] sig_name = 'picnic_L5_full'\r\n[00:01:54] \r\n[00:01:54]     @helpers.filtered_test\r\n[00:01:54]     @pytest.mark.parametrize('sig_name', helpers.available_sigs_by_name())\r\n[00:01:54]     def test_sig(sig_name):\r\n[00:01:54]         kats = helpers.get_kats(\"sig\")\r\n[00:01:54]         if not(helpers.is_sig_enabled_by_name(sig_name)): pytest.skip('Not enabled')\r\n[00:01:54] >       output = helpers.run_subprocess(\r\n[00:01:54]             [helpers.path_to_executable('kat_sig'), sig_name],\r\n[00:01:54]         )\r\n[00:01:54] \r\n[00:01:54] tests/test_kat.py:30: \r\n[00:01:54] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n[00:01:54] \r\n[00:01:54] command = ['./build/tests/kat_sig', 'picnic_L5_full'], working_dir = '.'\r\n[00:01:54] env = {'G_BROKEN_FILENAMES': '1', 'HISTFILESIZE': '9999', 'HISTSIZE': '999', 'HOME': '/usr/src', ...}\r\n[00:01:54] expected_returncode = 0, input = None, ignore_returncode = False\r\n[00:01:54] \r\n[00:01:54]     def run_subprocess(command, working_dir='.', env=None, expected_returncode=0, input=None, ignore_returncode=False):\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         Helper function to run a shell command and report success/failure\r\n[00:01:54]         depending on the exit status of the shell command.\r\n[00:01:54]         \"\"\"\r\n[00:01:54]         env_ = os.environ.copy()\r\n[00:01:54]         if env is not None:\r\n[00:01:54]             env_.update(env)\r\n[00:01:54]         env = env_\r\n[00:01:54]     \r\n[00:01:54]         # Note we need to capture stdout/stderr from the subprocess,\r\n[00:01:54]         # then print it, which pytest will then capture and\r\n[00:01:54]         # buffer appropriately\r\n[00:01:54]         print(working_dir + \" > \" + \" \".join(command))\r\n[00:01:54]     \r\n[00:01:54]         result = subprocess.run(\r\n[00:01:54]                 command,\r\n[00:01:54]                 input=input,\r\n[00:01:54]                 stdout=subprocess.PIPE,\r\n[00:01:54]                 stderr=subprocess.STDOUT,\r\n[00:01:54]                 cwd=working_dir,\r\n[00:01:54]                 env=env,\r\n[00:01:54]             )\r\n[00:01:54]     \r\n[00:01:54]         if not(ignore_returncode) and (result.returncode != expected_returncode):\r\n[00:01:54]             print(result.stdout.decode('utf-8'))\r\n[00:01:54] >           assert False, \"Got unexpected return code {}\".format(result.returncode)\r\n[00:01:54] E           AssertionError: Got unexpected return code -7\r\n[00:01:54] \r\n[00:01:54] tests/helpers.py:41: AssertionError\r\n[00:01:54] ----------------------------- Captured stdout call -----------------------------\r\n[00:01:54] . > ./build/tests/kat_sig picnic_L5_full\r\n[00:01:54] \r\n[00:01:54] =========================== short test summary info ============================\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L1_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_FS] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L3_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_full] - AssertionError: Got ...\r\n[00:01:54] FAILED tests/test_cmdline.py::test_sig[picnic_L5_UR] - AssertionError: Got un...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L1_FS] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L3_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L1_UR] - AssertionError: Got unexpe...\r\n[00:01:54] FAILED tests/test_mem.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] FAILED tests/test_kat.py::test_sig[picnic_L5_full] - AssertionError: Got unex...\r\n[00:01:54] ================= 27 failed, 477 passed, 131 skipped in 45.47s =================\r\n\r\n```\r\nThere are no errors on aarch64 and x86_64.\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T11:04:03Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15284012545","type":"IssuesEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"closed","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/285/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/285","id":812940661,"node_id":"MDU6SXNzdWU4MTI5NDA2NjE=","number":285,"title":"Dilithium family not enabled. ","user":{"login":"prchander","id":54725951,"node_id":"MDQ6VXNlcjU0NzI1OTUx","avatar_url":"https://avatars.githubusercontent.com/u/54725951?v=4","gravatar_id":"","url":"https://api.github.com/users/prchander","html_url":"https://github.com/prchander","followers_url":"https://api.github.com/users/prchander/followers","following_url":"https://api.github.com/users/prchander/following{/other_user}","gists_url":"https://api.github.com/users/prchander/gists{/gist_id}","starred_url":"https://api.github.com/users/prchander/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/prchander/subscriptions","organizations_url":"https://api.github.com/users/prchander/orgs","repos_url":"https://api.github.com/users/prchander/repos","events_url":"https://api.github.com/users/prchander/events{/privacy}","received_events_url":"https://api.github.com/users/prchander/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-02-21T20:15:38Z","updated_at":"2021-02-23T11:38:20Z","closed_at":"2021-02-23T11:38:20Z","author_association":"NONE","active_lock_reason":null,"body":"I brought us this issue in #282 thinking it was related but I am just going to open another one. \r\n\r\nNone of the Dilithium family works for me and I have tried reinstalling liboqs and openssl. I have also checked generate.ylm and Dilithium looks to be enabled.\r\napps/openssl genpkey -algorithm dilithium2 -out dilithium2_srv.key\r\nWarning: OQS algorithm 'Dilithium2' not enabled.\r\nError generating key\r\n140391613919552:error:101280A5:elliptic curve routines:oqs_key_init:no such oqs algorithm:crypto/ec/oqs_meth.c:785:\r\n140391613919552:error:10132040:elliptic curve routines:pkey_oqs_keygen:fatal:crypto/ec/oqs_meth.c:1401:\r\nHowever Falcon works ","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T11:38:21Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15287434698","type":"IssuesEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"closed","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/896/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/896","id":801401722,"node_id":"MDU6SXNzdWU4MDE0MDE3MjI=","number":896,"title":"Missing AVX2 version of Classic McEliece","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"assignees":[{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false}],"milestone":null,"comments":6,"created_at":"2021-02-04T15:42:40Z","updated_at":"2021-02-23T15:45:56Z","closed_at":"2021-02-23T15:45:56Z","author_association":"MEMBER","active_lock_reason":null,"body":"We only pull in the vec (vectorized plain C) implementation of Classic McEliece from PQClean; we should also pull in the avx2 implementation.","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T15:45:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15287449016","type":"IssuesEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"closed","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/917/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/917","id":810362382,"node_id":"MDU6SXNzdWU4MTAzNjIzODI=","number":917,"title":"Do a fresh pull from PQClean","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/11","html_url":"https://github.com/open-quantum-safe/liboqs/milestone/11","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones/11/labels","id":5734378,"node_id":"MDk6TWlsZXN0b25lNTczNDM3OA==","number":11,"title":"0.5.0 RC1","description":"","creator":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"open_issues":1,"closed_issues":9,"state":"open","created_at":"2020-08-05T00:29:37Z","updated_at":"2021-02-23T15:46:52Z","due_on":"2021-02-26T08:00:00Z","closed_at":null},"comments":1,"created_at":"2021-02-17T16:57:47Z","updated_at":"2021-02-23T15:46:52Z","closed_at":"2021-02-23T15:46:52Z","author_association":"MEMBER","active_lock_reason":null,"body":"","performed_via_github_app":null}},"public":true,"created_at":"2021-02-23T15:46:52Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
