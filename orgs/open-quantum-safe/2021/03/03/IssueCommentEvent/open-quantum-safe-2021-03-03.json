{"id":"15383523439","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","id":819908727,"node_id":"MDExOlB1bGxSZXF1ZXN0NTgyOTM5NTU5","number":928,"title":"Increasing message counter during sign-benchmark","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-03-02T11:04:51Z","updated_at":"2021-03-03T02:53:50Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/928","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/928.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/928.patch"},"body":"The purpose of this PR is to better capture message-dependencies in the sign-benchmarks. Currently, the message is selected at random once and is then fixed during the benchmark run. If the runtime is message-dependent, such as in deterministic Dilithium or Rainbow, the runtimes vary across benchmark runs.\r\n\r\nTo address this issue, this code change varies the message in the benchmark-loop. This results in stable total runtimes, but captures the variance in the \"std. dev.\" column of the benchmark. To avoid the overhead of generating a new random message after each sign-iteration, a message counter is increased inside the message. This is sufficient for signatures that follow a hash-then-sign paradigm.\r\n\r\n* [ ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ ] Does this PR change the the list of algorithms available -- either adding, removing, or renaming?  (If so, PRs in OQS-OpenSSL, OQS-BoringSSL, and OQS-OpenSSH will also be required by the time this is merged.)","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/789387875","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928#issuecomment-789387875","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","id":789387875,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTM4Nzg3NQ==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T02:53:50Z","updated_at":"2021-03-03T02:53:50Z","author_association":"MEMBER","body":"I accept that we shouldn't change test suites to avoid exposing data-dependent behaviour.  But that specific concern for Dilithium has been put to bed by #923.  \r\n\r\nSo for me the question is now whether a signature timing benchmark (for messages of a fixed length) makes more sense to be run on a fixed non-random message of that length (which we're not doing), a random-once-and-then-fixed-after-that message of that length (which we are currently doing), a distinct-each-time message of that length (which is what this PR would do), or another option.\r\n\r\nI would say it's a separate issue of whether we think we should have tests that check for message-dependent signing behaviour. Doing something via Vagrind/TIMECOP Ã  la #881 is not immediately straightforward, as I understand it, since we can reasonably expect all signature schemes to accept variable length messages and thus at least depend on the length of the message being signed.","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T02:53:50Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15385590435","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","id":819908727,"node_id":"MDExOlB1bGxSZXF1ZXN0NTgyOTM5NTU5","number":928,"title":"Increasing message counter during sign-benchmark","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-03-02T11:04:51Z","updated_at":"2021-03-03T06:52:57Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/928","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/928.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/928.patch"},"body":"The purpose of this PR is to better capture message-dependencies in the sign-benchmarks. Currently, the message is selected at random once and is then fixed during the benchmark run. If the runtime is message-dependent, such as in deterministic Dilithium or Rainbow, the runtimes vary across benchmark runs.\r\n\r\nTo address this issue, this code change varies the message in the benchmark-loop. This results in stable total runtimes, but captures the variance in the \"std. dev.\" column of the benchmark. To avoid the overhead of generating a new random message after each sign-iteration, a message counter is increased inside the message. This is sufficient for signatures that follow a hash-then-sign paradigm.\r\n\r\n* [ ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ ] Does this PR change the the list of algorithms available -- either adding, removing, or renaming?  (If so, PRs in OQS-OpenSSL, OQS-BoringSSL, and OQS-OpenSSH will also be required by the time this is merged.)","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/789483884","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928#issuecomment-789483884","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","id":789483884,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTQ4Mzg4NA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T06:52:57Z","updated_at":"2021-03-03T06:52:57Z","author_association":"MEMBER","body":"> I accept that we shouldn't change test suites to avoid exposing data-dependent behaviour. \r\n\r\nThanks! In addition, changing this code here now would make all performance data points collected over the past months incomparable with new ones as indicated by\r\n\r\n> And after the PR:\r\n> \r\n> Speed test\r\n> ==========\r\n> Operation                      | Iterations | Total time (s) | Time (us): mean | pop. stdev | CPU cycles: mean          | pop. stdev\r\n> ------------------------------ | ----------:| --------------:| ---------------:| ----------:| -------------------------:| ----------:\r\n> Dilithium3                     |            |                |                 |            |                           |           \r\n> sign                           |      17937 |          3.000 |         167.257 |    106.252 |                    433349 |     275380\r\n\r\n\r\nI also agree with \r\n\r\n> we can reasonably expect all signature schemes to accept variable length messages and thus at least depend on the length of the message being signed\r\n\r\nHowever, isn't this a direct consequence of the NIST APIs? If so, pretty hard for us to change given we build on those APIs.\r\n\r\nUsing different types of contents of (same-length) messages (fixed, fully random, somewhat changing as per this PR) may be interesting. But then again, the IBM team asked a reasonable question we may want to answer first:\r\n\r\n> it would be helpful for the  OQS team to clarify what the purpose of the tests are:\r\n> \r\n> - Comparing algorithms vs Comparing algorithm evolution\r\n> - Testing algorithm runtime variation for a given message vs testing algorithms runtime over a distribution of messages\r\n\r\n-> Is it possible this whole discussion really is one about what tests should visualize rather than what this particular test does? So maybe better to create an issue in https://github.com/open-quantum-safe/profiling and work on a (re)solution together there rather than changing this test and then forgetting about it? Reason:\r\n\r\n> Capturing the variance is exactly what this PR aims to achieve. \r\n\r\nseems to indicate interest to contribute generating new numbers (and provide answers to the \"goal questions\") -- both topics of interest in the profiling subproject: What about we continue this conversation there? See https://github.com/open-quantum-safe/profiling/issues/40 \r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T06:52:57Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15388641777","type":"IssueCommentEvent","actor":{"id":149199,"login":"bhess","display_login":"bhess","gravatar_id":"","url":"https://api.github.com/users/bhess","avatar_url":"https://avatars.githubusercontent.com/u/149199?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","id":819908727,"node_id":"MDExOlB1bGxSZXF1ZXN0NTgyOTM5NTU5","number":928,"title":"Increasing message counter during sign-benchmark","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-03-02T11:04:51Z","updated_at":"2021-03-03T11:01:35Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/928","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/928.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/928.patch"},"body":"The purpose of this PR is to better capture message-dependencies in the sign-benchmarks. Currently, the message is selected at random once and is then fixed during the benchmark run. If the runtime is message-dependent, such as in deterministic Dilithium or Rainbow, the runtimes vary across benchmark runs.\r\n\r\nTo address this issue, this code change varies the message in the benchmark-loop. This results in stable total runtimes, but captures the variance in the \"std. dev.\" column of the benchmark. To avoid the overhead of generating a new random message after each sign-iteration, a message counter is increased inside the message. This is sufficient for signatures that follow a hash-then-sign paradigm.\r\n\r\n* [ ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ ] Does this PR change the the list of algorithms available -- either adding, removing, or renaming?  (If so, PRs in OQS-OpenSSL, OQS-BoringSSL, and OQS-OpenSSH will also be required by the time this is merged.)","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/789629686","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928#issuecomment-789629686","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","id":789629686,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTYyOTY4Ng==","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T11:01:35Z","updated_at":"2021-03-03T11:01:35Z","author_association":"CONTRIBUTOR","body":"> So for me the question is now whether a signature timing benchmark (for messages of a fixed length) makes more sense to be run on a fixed non-random message of that length (which we're not doing), a random-once-and-then-fixed-after-that message of that length (which we are currently doing), a distinct-each-time message of that length (which is what this PR would do), or another option.\r\n\r\nI think this is really the question that it boils down to. Shouldnât a benchmark give a ârealisticâ picture of what one can expect from the performance of an algorithm (with metrics such as mean, standard deviation, perhaps its distribution)? \r\nIâd expect that in practice, one signs distinct messages. Message lengths will also be variable. But if all algorithms first internally hash the messages, the lengths could as well be kept fixed in the benchmark.\r\nWhat about having one \"default\" benchmark (that the user runs via `speed_sig`)? And then more tests or profiling runs that address practical use cases like variable-length messages, varying CPU load, etc. (topics for open-quantum-safe/profiling#40).\r\n\r\n> I accept that we shouldn't change test suites to avoid exposing data-dependent behaviour.\r\n\r\nI donât dispute this. But it seems to imply that this PR does this, which I donât see and it was never the intention. In my previous reply I tried to show that if anything, the contrary is the case.\r\n\r\n> What about we continue this conversation there? See [open-quantum-safe/profiling#40](https://github.com/open-quantum-safe/profiling/issues/40)\r\n\r\nAgreed!","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T11:01:35Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15391015822","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":288761656,"name":"open-quantum-safe/profiling","url":"https://api.github.com/repos/open-quantum-safe/profiling"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","repository_url":"https://api.github.com/repos/open-quantum-safe/profiling","labels_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/comments","events_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/events","html_url":"https://github.com/open-quantum-safe/profiling/issues/40","id":820806365,"node_id":"MDU6SXNzdWU4MjA4MDYzNjU=","number":40,"title":"Agree goals of tests and visualization","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-03-03T06:49:23Z","updated_at":"2021-03-03T14:06:25Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Following up on discussions in https://github.com/open-quantum-safe/liboqs/pull/928 : \r\n\r\n> it would be helpful for the  OQS team to clarify what the purpose of the tests are:\r\n> \r\n> - Comparing algorithms vs Comparing algorithm evolution\r\n> - Testing algorithm runtime variation for a given message vs testing algorithms runtime over a distribution of messages\r\n\r\nMy personal initial attempt to answer:\r\n\r\nAlgorithm evolution may not be as interesting as a comparison across algorithms (and their variants)\r\nRuntime variations for any algorithm (or algorithm variant) with any kind of dependency would be interesting to highlight (possibly as a new set of tests and visualizations).","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/comments/789738337","html_url":"https://github.com/open-quantum-safe/profiling/issues/40#issuecomment-789738337","issue_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","id":789738337,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTczODMzNw==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T14:06:25Z","updated_at":"2021-03-03T14:06:25Z","author_association":"MEMBER","body":"For item 1, I'd say the purpose is comparing algorithms, not comparing algorithm evolution. In fact many of the evolutions observed in our performance data are really consequences of us improving infrastructure, shared code, build options, etc. Useful for us to know that our changes are making things better, but not scientifically interesting.\r\n\r\nFor item 2, I'd lean towards \"over a distribution of messages\", but indeed it would be interesting to highlight algorithms with atypical dependency.  It might be worth checking SUPERCOP's approach to message generation for signature benchmarking.","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T14:06:25Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15393083537","type":"IssueCommentEvent","actor":{"id":149199,"login":"bhess","display_login":"bhess","gravatar_id":"","url":"https://api.github.com/users/bhess","avatar_url":"https://avatars.githubusercontent.com/u/149199?"},"repo":{"id":288761656,"name":"open-quantum-safe/profiling","url":"https://api.github.com/repos/open-quantum-safe/profiling"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","repository_url":"https://api.github.com/repos/open-quantum-safe/profiling","labels_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/comments","events_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/events","html_url":"https://github.com/open-quantum-safe/profiling/issues/40","id":820806365,"node_id":"MDU6SXNzdWU4MjA4MDYzNjU=","number":40,"title":"Agree goals of tests and visualization","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-03-03T06:49:23Z","updated_at":"2021-03-03T16:19:34Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Following up on discussions in https://github.com/open-quantum-safe/liboqs/pull/928 : \r\n\r\n> it would be helpful for the  OQS team to clarify what the purpose of the tests are:\r\n> \r\n> - Comparing algorithms vs Comparing algorithm evolution\r\n> - Testing algorithm runtime variation for a given message vs testing algorithms runtime over a distribution of messages\r\n\r\nMy personal initial attempt to answer:\r\n\r\nAlgorithm evolution may not be as interesting as a comparison across algorithms (and their variants)\r\nRuntime variations for any algorithm (or algorithm variant) with any kind of dependency would be interesting to highlight (possibly as a new set of tests and visualizations).","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/comments/789835900","html_url":"https://github.com/open-quantum-safe/profiling/issues/40#issuecomment-789835900","issue_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","id":789835900,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTgzNTkwMA==","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T16:19:34Z","updated_at":"2021-03-03T16:19:34Z","author_association":"NONE","body":"> It might be worth checking SUPERCOP's approach to message generation for signature benchmarking.\r\n\r\nSUPERCOP combines several variables in the signature benchmark: (1) message lengths up to 100000 bytes, (2) distinct message each time (randomly pre-generated for each iteration), (3) distinct key-pairs for each iteration.\r\nhttps://github.com/jedisct1/supercop/blob/master/crypto_sign/measure.c\r\n\r\nWe could use the same approach as SUPERCOP by default. For special additional tests, we could add command-line options to `speed_sig` that allow to fix certain parameters.","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T16:19:34Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15393897329","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":288761656,"name":"open-quantum-safe/profiling","url":"https://api.github.com/repos/open-quantum-safe/profiling"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","repository_url":"https://api.github.com/repos/open-quantum-safe/profiling","labels_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/comments","events_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40/events","html_url":"https://github.com/open-quantum-safe/profiling/issues/40","id":820806365,"node_id":"MDU6SXNzdWU4MjA4MDYzNjU=","number":40,"title":"Agree goals of tests and visualization","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2021-03-03T06:49:23Z","updated_at":"2021-03-03T17:15:02Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"Following up on discussions in https://github.com/open-quantum-safe/liboqs/pull/928 : \r\n\r\n> it would be helpful for the  OQS team to clarify what the purpose of the tests are:\r\n> \r\n> - Comparing algorithms vs Comparing algorithm evolution\r\n> - Testing algorithm runtime variation for a given message vs testing algorithms runtime over a distribution of messages\r\n\r\nMy personal initial attempt to answer:\r\n\r\nAlgorithm evolution may not be as interesting as a comparison across algorithms (and their variants)\r\nRuntime variations for any algorithm (or algorithm variant) with any kind of dependency would be interesting to highlight (possibly as a new set of tests and visualizations).","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/comments/789899862","html_url":"https://github.com/open-quantum-safe/profiling/issues/40#issuecomment-789899862","issue_url":"https://api.github.com/repos/open-quantum-safe/profiling/issues/40","id":789899862,"node_id":"MDEyOklzc3VlQ29tbWVudDc4OTg5OTg2Mg==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T17:15:01Z","updated_at":"2021-03-03T17:15:01Z","author_association":"MEMBER","body":"> We could use the same approach as SUPERCOP by default.\r\n\r\nSilly question: What is missing in the SUPERCOP benchmarks? Or asked the other way: How can we avoid to replicate what's already been done? Do you have a link where they visualize their results? [This](https://bench.cr.yp.to/primitives-sign.html) is worse in terms of visualization than [oqs-profiling](https://openquantumsafe.org/benchmarking/visualization/speed_sig_series.html)'s surely less-than-great visuals -- there must be something better for SUPERCOP. Also: Is there a way to compare across algorithms at one glance?\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T17:15:02Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15397797080","type":"IssueCommentEvent","actor":{"id":8843219,"login":"dstebila","display_login":"dstebila","gravatar_id":"","url":"https://api.github.com/users/dstebila","avatar_url":"https://avatars.githubusercontent.com/u/8843219?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/932","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/932/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/932/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/932/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/932","id":821345648,"node_id":"MDExOlB1bGxSZXF1ZXN0NTg0MTUyODQ0","number":932,"title":"Resolve some McEliece AVX build issues","user":{"login":"jschanck","id":25615540,"node_id":"MDQ6VXNlcjI1NjE1NTQw","avatar_url":"https://avatars.githubusercontent.com/u/25615540?v=4","gravatar_id":"","url":"https://api.github.com/users/jschanck","html_url":"https://github.com/jschanck","followers_url":"https://api.github.com/users/jschanck/followers","following_url":"https://api.github.com/users/jschanck/following{/other_user}","gists_url":"https://api.github.com/users/jschanck/gists{/gist_id}","starred_url":"https://api.github.com/users/jschanck/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jschanck/subscriptions","organizations_url":"https://api.github.com/users/jschanck/orgs","repos_url":"https://api.github.com/users/jschanck/repos","events_url":"https://api.github.com/users/jschanck/events{/privacy}","received_events_url":"https://api.github.com/users/jschanck/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-03-03T17:54:23Z","updated_at":"2021-03-03T22:46:08Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/932","html_url":"https://github.com/open-quantum-safe/liboqs/pull/932","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/932.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/932.patch"},"body":"The first commit makes it possible to do an OQS_MINIMAL_BUILD with just the avx McEliece code. The minimal build feature uses an allowlist for platform specific symbol suffixes, the commit just adds \"_avx\" to that list.\r\n\r\nThe second commit is an attempt to resolve #930. Declaring the constants with \".hidden\" keeps them out of the global offset table and is an alternative to using \"-Wl,-Bsymbolic\". CI passing here will not indicate whether this resolves #930, but this solution is preferable to Bsymbolic in any case.\r\n\r\nThe third commit replaces casts to __m256i_u* with casts to __m256i*. The __m256i_u type is a gcc extension, and was preventing us from building the McEliece avx code with clang <9.\r\n\r\nThe fourth commit is just a nit-pick.\r\n","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/790126608","html_url":"https://github.com/open-quantum-safe/liboqs/pull/932#issuecomment-790126608","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/932","id":790126608,"node_id":"MDEyOklzc3VlQ29tbWVudDc5MDEyNjYwOA==","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"created_at":"2021-03-03T22:46:08Z","updated_at":"2021-03-03T22:46:08Z","author_association":"MEMBER","body":"If I understand correctly, this is all a temporary fix for now, since it would get wiped out by copy\\_from\\_upstream and long-term solution is to either push these changes back into PQClean or add patches in copy\\_from\\_upstream.  ","performed_via_github_app":null}},"public":true,"created_at":"2021-03-03T22:46:08Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
