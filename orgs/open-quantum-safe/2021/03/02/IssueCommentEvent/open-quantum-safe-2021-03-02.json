{"id":"15374314682","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","id":819908727,"node_id":"MDExOlB1bGxSZXF1ZXN0NTgyOTM5NTU5","number":928,"title":"Increasing message counter during sign-benchmark","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2021-03-02T11:04:51Z","updated_at":"2021-03-02T13:41:40Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/928","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/928.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/928.patch"},"body":"The purpose of this PR is to better capture message-dependencies in the sign-benchmarks. Currently, the message is selected at random once and is then fixed during the benchmark run. If the runtime is message-dependent, such as in deterministic Dilithium or Rainbow, the runtimes vary across benchmark runs.\r\n\r\nTo address this issue, this code change varies the message in the benchmark-loop. This results in stable total runtimes, but captures the variance in the \"std. dev.\" column of the benchmark. To avoid the overhead of generating a new random message after each sign-iteration, a message counter is increased inside the message. This is sufficient for signatures that follow a hash-then-sign paradigm.\r\n\r\n* [ ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ ] Does this PR change the the list of algorithms available -- either adding, removing, or renaming?  (If so, PRs in OQS-OpenSSL, OQS-BoringSSL, and OQS-OpenSSH will also be required by the time this is merged.)","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/788917231","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928#issuecomment-788917231","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","id":788917231,"node_id":"MDEyOklzc3VlQ29tbWVudDc4ODkxNzIzMQ==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-03-02T13:41:39Z","updated_at":"2021-03-02T13:41:39Z","author_association":"MEMBER","body":"Allow me to repeat one more time publicly what I kept saying in personal communication now for more than a year: I think it is not a good idea to change a test to allow single algorithms vulnerable to side channel attacks (in this case: That have a runtime strongly dependent on the message) to hide/let this property go unnoticed when being tested. \r\n\r\nActually, this test was the reason that unearthed (at least for me and what I still perceive as) a practical cryptographic weakness of the original Dilithium code base. This has been resolved via the now available randomized signing variant which clearly does not need this change as visible here (who can spot the day of merging Dilithium 3.1 without deterministic signing :-)?\r\n![grafik](https://user-images.githubusercontent.com/57787676/109655667-d4606d00-7b63-11eb-8750-bd729608fb81.png)\r\n\r\nI thus won't approve this PR. To the contrary, I'd even propose creating more tests checking for data-dependencies of these algorithms: \"Classic\" crypto has gone through many pains of fixing such issues, sometimes only after attackers exploited such implementations. Wouldn't it be a reasonable goal for our project to try to expose/help fix such problems before exploitation?\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-03-02T13:41:40Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"15375621503","type":"IssueCommentEvent","actor":{"id":149199,"login":"bhess","display_login":"bhess","gravatar_id":"","url":"https://api.github.com/users/bhess","avatar_url":"https://avatars.githubusercontent.com/u/149199?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928/events","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","id":819908727,"node_id":"MDExOlB1bGxSZXF1ZXN0NTgyOTM5NTU5","number":928,"title":"Increasing message counter during sign-benchmark","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-03-02T11:04:51Z","updated_at":"2021-03-02T15:07:15Z","closed_at":null,"author_association":"CONTRIBUTOR","active_lock_reason":null,"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/928","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/928.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/928.patch"},"body":"The purpose of this PR is to better capture message-dependencies in the sign-benchmarks. Currently, the message is selected at random once and is then fixed during the benchmark run. If the runtime is message-dependent, such as in deterministic Dilithium or Rainbow, the runtimes vary across benchmark runs.\r\n\r\nTo address this issue, this code change varies the message in the benchmark-loop. This results in stable total runtimes, but captures the variance in the \"std. dev.\" column of the benchmark. To avoid the overhead of generating a new random message after each sign-iteration, a message counter is increased inside the message. This is sufficient for signatures that follow a hash-then-sign paradigm.\r\n\r\n* [ ] Does this PR change the input/output behaviour of a cryptographic algorithm (i.e., does it change known answer test values)?  (If so, a version bump will be required from *x.y.z* to *x.(y+1).0*.)\r\n* [ ] Does this PR change the the list of algorithms available -- either adding, removing, or renaming?  (If so, PRs in OQS-OpenSSL, OQS-BoringSSL, and OQS-OpenSSH will also be required by the time this is merged.)","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/788975464","html_url":"https://github.com/open-quantum-safe/liboqs/pull/928#issuecomment-788975464","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/928","id":788975464,"node_id":"MDEyOklzc3VlQ29tbWVudDc4ODk3NTQ2NA==","user":{"login":"bhess","id":149199,"node_id":"MDQ6VXNlcjE0OTE5OQ==","avatar_url":"https://avatars.githubusercontent.com/u/149199?v=4","gravatar_id":"","url":"https://api.github.com/users/bhess","html_url":"https://github.com/bhess","followers_url":"https://api.github.com/users/bhess/followers","following_url":"https://api.github.com/users/bhess/following{/other_user}","gists_url":"https://api.github.com/users/bhess/gists{/gist_id}","starred_url":"https://api.github.com/users/bhess/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bhess/subscriptions","organizations_url":"https://api.github.com/users/bhess/orgs","repos_url":"https://api.github.com/users/bhess/repos","events_url":"https://api.github.com/users/bhess/events{/privacy}","received_events_url":"https://api.github.com/users/bhess/received_events","type":"User","site_admin":false},"created_at":"2021-03-02T15:07:15Z","updated_at":"2021-03-02T15:07:15Z","author_association":"CONTRIBUTOR","body":"> Allow me to repeat one more time publicly what I kept saying in personal communication now for more than a year: I think it is not a good idea to change a test to allow single algorithms vulnerable to side channel attacks (in this case: That have a runtime strongly dependent on the message) to hide/let this property go unnoticed when being tested.\r\n\r\nCapturing the variance is exactly what this PR aims to achieve. Consider a benchmark with (deterministic) Dilithium before this PR:\r\n\r\n```\r\nSpeed test\r\n==========\r\nOperation                      | Iterations | Total time (s) | Time (us): mean | pop. stdev | CPU cycles: mean          | pop. stdev\r\n------------------------------ | ----------:| --------------:| ---------------:| ----------:| -------------------------:| ----------:\r\nDilithium3                     |            |                |                 |            |                           |           \r\nsign                           |      24926 |          3.000 |         120.360 |      9.955 |                    311817 |      25680\r\n```\r\n\r\nAnd after the PR:\r\n```\r\nSpeed test\r\n==========\r\nOperation                      | Iterations | Total time (s) | Time (us): mean | pop. stdev | CPU cycles: mean          | pop. stdev\r\n------------------------------ | ----------:| --------------:| ---------------:| ----------:| -------------------------:| ----------:\r\nDilithium3                     |            |                |                 |            |                           |           \r\nsign                           |      17937 |          3.000 |         167.257 |    106.252 |                    433349 |     275380\r\n```\r\n\r\nNotice the difference in \"pop. stdev\", which can be interpreted without the need for a time series.\r\n\r\n> I'd even propose creating more tests checking for data-dependencies of these algorithms: \"Classic\" crypto has gone through many pains of fixing such issues, sometimes only after attackers exploited such implementations. Wouldn't it be a reasonable goal for our project to try to expose/help fix such problems before exploitation?\r\n\r\nCreating an extra test is a good idea. Message-dependency is something to be aware of (and the Dilithium specification properly documents this for its deterministic version).\r\nBut in a benchmark I'd expect the timing mean plus the std. dev. to get a picture how it behaves in practice.","performed_via_github_app":null}},"public":true,"created_at":"2021-03-02T15:07:16Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
