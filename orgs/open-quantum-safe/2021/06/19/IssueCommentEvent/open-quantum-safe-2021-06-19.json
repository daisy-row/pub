{"id":"16844306077","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/318","id":925107062,"node_id":"MDU6SXNzdWU5MjUxMDcwNjI=","number":318,"title":"Overwriting method call through ENGINE","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-06-18T18:06:50Z","updated_at":"2021-06-19T06:16:47Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\nI am working on a PoC application, where we want to overwrite the keygen method calls so that, when an OQS Signature keygen method is called through `EVP_PKEY_keygen()`, our method, registered in `pmeth->keygen`, will be invoked.\r\n\r\nI was looking for a way to overwrite the `ctx->pmeth->keygen`  value before passed to `int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)` method.\r\n\r\nI can achieve the above behaviour with RSA through ENGINE. It was a relatively easy setup, but I wasn't able to replicate it with OQS signatures, e.g. Dilithium. Existing code within oqs-engine project (not supported anymore) can do this but I couldn't get it to run with the latest version of OQS-OpenSSL.\r\n\r\nI read about, oqs-engine not being supported under OQS-OpenSSL anymore and it was advised to use Providers with the OpenSSL3.0 instead, but for our PoC, I need to work with the engine on OpenSSL 1.1.1 and OQS.\r\n\r\nIs it possible to achieve the behaviour described above through ENGINE for OQS signatures?\r\n\r\nAny help/lead is appreciated.\r\nRegards.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/864362960","html_url":"https://github.com/open-quantum-safe/openssl/issues/318#issuecomment-864362960","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","id":864362960,"node_id":"MDEyOklzc3VlQ29tbWVudDg2NDM2Mjk2MA==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-06-19T06:16:47Z","updated_at":"2021-06-19T06:16:47Z","author_association":"MEMBER","body":"Thanks for your interest to use OQS for your project and the description of your problem. Unfortunately, I'm not entirely sure I understand what you try to do:  Do you simply want to execute some \"custom code\" when keygen with a QSC algorithm is invoked? If so, why don't you do this before `EVP_keygen` is called? Or do you want to register a callback that is regularly called during (long-running) keygen operations? Or do you want to completely replace the algorithm-specific QSC keygen code with your own code? Probably not, as that would destroy the functionality of the system... \r\n\r\nSo, if you could describe the goal of your project, maybe we can come up with a solution. In the worst case, you could fork this project and change the code [here](https://github.com/open-quantum-safe/openssl/blob/5eea990c64f28fd3cffba29d07961959fd5f2718/crypto/ec/oqs_meth.c#L1392). Alternatively, what about you provide maintenance to https://github.com/open-quantum-safe/oqs-engine (which I personally unfortunately have no experience with) if this code basically allows you to do what you want?","performed_via_github_app":null}},"public":true,"created_at":"2021-06-19T06:16:48Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"16844542592","type":"IssueCommentEvent","actor":{"id":85164885,"login":"erdem-cqc","display_login":"erdem-cqc","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","avatar_url":"https://avatars.githubusercontent.com/u/85164885?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/318","id":925107062,"node_id":"MDU6SXNzdWU5MjUxMDcwNjI=","number":318,"title":"Overwriting method call through ENGINE","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2021-06-18T18:06:50Z","updated_at":"2021-06-19T07:26:35Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\nI am working on a PoC application, where we want to overwrite the keygen method calls so that, when an OQS Signature keygen method is called through `EVP_PKEY_keygen()`, our method, registered in `pmeth->keygen`, will be invoked.\r\n\r\nI was looking for a way to overwrite the `ctx->pmeth->keygen`  value before passed to `int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)` method.\r\n\r\nI can achieve the above behaviour with RSA through ENGINE. It was a relatively easy setup, but I wasn't able to replicate it with OQS signatures, e.g. Dilithium. Existing code within oqs-engine project (not supported anymore) can do this but I couldn't get it to run with the latest version of OQS-OpenSSL.\r\n\r\nI read about, oqs-engine not being supported under OQS-OpenSSL anymore and it was advised to use Providers with the OpenSSL3.0 instead, but for our PoC, I need to work with the engine on OpenSSL 1.1.1 and OQS.\r\n\r\nIs it possible to achieve the behaviour described above through ENGINE for OQS signatures?\r\n\r\nAny help/lead is appreciated.\r\nRegards.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/864369458","html_url":"https://github.com/open-quantum-safe/openssl/issues/318#issuecomment-864369458","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","id":864369458,"node_id":"MDEyOklzc3VlQ29tbWVudDg2NDM2OTQ1OA==","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"created_at":"2021-06-19T07:26:35Z","updated_at":"2021-06-19T07:26:35Z","author_association":"NONE","body":"Thanks for your reply, as a short reply to your question, I do want to replace the existing keygen() with my callback, the actual key generation will be deferred to another application. I was planning to keep `apps/openssl` UI the same so that, users do not need to change their existing code and consume the OQS generated keys as usual. \r\n\r\nI sort of achieved this with RSA case. Below is a segment from my RSA engine code, when `openssl genpkey -algorithm rsa -engine our_rsa_engine` is executed, with below registration, `our_generate_multi_prime_key()` method is called\r\n```\r\nRSA_METHOD *get_rsa_method(void)\r\n{\r\n    static RSA_METHOD *ops = NULL;\r\n    if(ops == NULL) {\r\n        ops = RSA_meth_new(\"cqc rsa\", 0);\r\n        ...\r\n        RSA_meth_set_multi_prime_keygen(ops, cqc_generate_multi_prime_key);\r\n        ...\r\n    }\r\n    return ops;\r\n}\r\n```\r\nI was hoping to register my callbacks for OQS sig keys, dilithium2 was my first trial, similar to the RSA case above, so that when `openssl genpkey -algorithm dilithium2 -engine our_oqs_engine` is executed, our registered callback was to be invoked. \r\n\r\nI started working with oqs-engine (abandoned on Apr 2020) but couldnt get it to work with latest version of the OQS-OpenSSL fork. Its test_oqse runs fine linking against its own tagged/older OQS. However the test code makes explicit call with engine generated ctx\r\n\r\n```\r\n   ...\r\n   kctx = EVP_PKEY_CTX_new(params, engine);\r\n   ...\r\n   if (!EVP_PKEY_keygen_init(kctx)){\r\n   ...\r\n    /* Generate the key */\r\n    if (!EVP_PKEY_keygen(kctx, pkey)){  \r\n```\r\nIt is fine for the test to do so and it is stepping into engine registered keygen() method. I was hoping to achieve the same, that the engine generated ctx which contains the overwritten method for `pmeth->keygen`, will be passed down to `EVP_PKEY_keygen()` when `-engine our_engine` param is present. This would have been perfect and I wouldn't need to modify apps/openssl, to replicate the behaviour of the oqse_test code.\r\n\r\nIf there is no way to pass down a ctx object to EVP_PKEY_keygen() when engine is present, then the only option left is to fork and modify apps/openssl, as you have suggested.\r\nRegards.\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-06-19T07:26:36Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"16844711910","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/318","id":925107062,"node_id":"MDU6SXNzdWU5MjUxMDcwNjI=","number":318,"title":"Overwriting method call through ENGINE","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2021-06-18T18:06:50Z","updated_at":"2021-06-19T08:15:13Z","closed_at":null,"author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\nI am working on a PoC application, where we want to overwrite the keygen method calls so that, when an OQS Signature keygen method is called through `EVP_PKEY_keygen()`, our method, registered in `pmeth->keygen`, will be invoked.\r\n\r\nI was looking for a way to overwrite the `ctx->pmeth->keygen`  value before passed to `int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)` method.\r\n\r\nI can achieve the above behaviour with RSA through ENGINE. It was a relatively easy setup, but I wasn't able to replicate it with OQS signatures, e.g. Dilithium. Existing code within oqs-engine project (not supported anymore) can do this but I couldn't get it to run with the latest version of OQS-OpenSSL.\r\n\r\nI read about, oqs-engine not being supported under OQS-OpenSSL anymore and it was advised to use Providers with the OpenSSL3.0 instead, but for our PoC, I need to work with the engine on OpenSSL 1.1.1 and OQS.\r\n\r\nIs it possible to achieve the behaviour described above through ENGINE for OQS signatures?\r\n\r\nAny help/lead is appreciated.\r\nRegards.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/864374292","html_url":"https://github.com/open-quantum-safe/openssl/issues/318#issuecomment-864374292","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","id":864374292,"node_id":"MDEyOklzc3VlQ29tbWVudDg2NDM3NDI5Mg==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-06-19T08:15:13Z","updated_at":"2021-06-19T08:15:13Z","author_association":"MEMBER","body":"Thanks for the additional background. I understand more, but not yet this:\r\n\r\n> couldnt get it to work with latest version of the OQS-OpenSSL fork\r\n\r\nWhy do you try this? Isn't the whole point of `oqs-engine` to work with a stock (non-OQS) OpenSSL? Sorry for the possibly stupid question, but I try to understand whether your problem originates with (upstream) OpenSSL (possible), `oqs-engine` (probable) or `liboqs` (unlikely). It should not have to do with `oqs-openssl`, right?\r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-06-19T08:15:13Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"16844749022","type":"IssueCommentEvent","actor":{"id":57787676,"login":"baentsch","display_login":"baentsch","gravatar_id":"","url":"https://api.github.com/users/baentsch","avatar_url":"https://avatars.githubusercontent.com/u/57787676?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1025","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1025/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1025/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1025/events","html_url":"https://github.com/open-quantum-safe/liboqs/issues/1025","id":924448728,"node_id":"MDU6SXNzdWU5MjQ0NDg3Mjg=","number":1025,"title":"Deal with CI backlog","user":{"login":"dstebila","id":8843219,"node_id":"MDQ6VXNlcjg4NDMyMTk=","avatar_url":"https://avatars.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false},"assignees":[{"login":"xvzcf","id":21228961,"node_id":"MDQ6VXNlcjIxMjI4OTYx","avatar_url":"https://avatars.githubusercontent.com/u/21228961?v=4","gravatar_id":"","url":"https://api.github.com/users/xvzcf","html_url":"https://github.com/xvzcf","followers_url":"https://api.github.com/users/xvzcf/followers","following_url":"https://api.github.com/users/xvzcf/following{/other_user}","gists_url":"https://api.github.com/users/xvzcf/gists{/gist_id}","starred_url":"https://api.github.com/users/xvzcf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xvzcf/subscriptions","organizations_url":"https://api.github.com/users/xvzcf/orgs","repos_url":"https://api.github.com/users/xvzcf/repos","events_url":"https://api.github.com/users/xvzcf/events{/privacy}","received_events_url":"https://api.github.com/users/xvzcf/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2021-06-18T00:59:57Z","updated_at":"2021-06-19T08:25:19Z","closed_at":null,"author_association":"MEMBER","active_lock_reason":null,"body":"@xvzcf You had some concerns about backlog of incomplete coverage in CI, e.g. some algorithms being disabled on AppVeyor.  Can you document those in this issue?","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments/864375312","html_url":"https://github.com/open-quantum-safe/liboqs/issues/1025#issuecomment-864375312","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/1025","id":864375312,"node_id":"MDEyOklzc3VlQ29tbWVudDg2NDM3NTMxMg==","user":{"login":"baentsch","id":57787676,"node_id":"MDQ6VXNlcjU3Nzg3Njc2","avatar_url":"https://avatars.githubusercontent.com/u/57787676?v=4","gravatar_id":"","url":"https://api.github.com/users/baentsch","html_url":"https://github.com/baentsch","followers_url":"https://api.github.com/users/baentsch/followers","following_url":"https://api.github.com/users/baentsch/following{/other_user}","gists_url":"https://api.github.com/users/baentsch/gists{/gist_id}","starred_url":"https://api.github.com/users/baentsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/baentsch/subscriptions","organizations_url":"https://api.github.com/users/baentsch/orgs","repos_url":"https://api.github.com/users/baentsch/repos","events_url":"https://api.github.com/users/baentsch/events{/privacy}","received_events_url":"https://api.github.com/users/baentsch/received_events","type":"User","site_admin":false},"created_at":"2021-06-19T08:25:19Z","updated_at":"2021-06-19T08:25:19Z","author_association":"MEMBER","body":"If I get it right, every single item above was triggered by the need to save (CI) time, either because the algorithms are too slow (i.e., we effectively did pick (on :) \"losers\") or the tests are too time-consuming/not adding serious value (to warrant their regular execution).\r\n\r\nSo I see some alternatives for resolution:\r\n1) We buy more CCI resources (for parallel execution).\r\n2) We create a more convoluted \"tier system\" of tests (PR run, audit-run, release-run, etc.) with different levels of \"thoroughness\" (i.e., time/resource demands)\r\n3) We \"mix\" testing options, i.e., not doing full matrix tests, but do testing of specific features/algorithms only on specific setups (say, Rainbow only on shared x86 builds and Sphincs only on static arm builds). Absolutely non-ideal but may allow us to test more within the given CI resource budget.\r\n4) We switch to a completely different CI mechanism, e.g., one permitting addition of \"self\"-maintained executors: We might then use machines (and architectures) we chose (also adding IBM (\"donated\" :) mainframes for `s390`, IBM Power machines for `ppc64le`, AWS cloud for mainstream `x64` or `arm64`). But that'd be a major undertaking.....\r\n\r\nI intentionally didn't list the fifth option to _add_ another CI system (for on-demand or release-only testing): It would make our system even harder to maintain/remain consistent.\r\n\r\nFurther ideas very welcome. \r\n","performed_via_github_app":null}},"public":true,"created_at":"2021-06-19T08:25:19Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"16845054403","type":"IssueCommentEvent","actor":{"id":85164885,"login":"erdem-cqc","display_login":"erdem-cqc","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","avatar_url":"https://avatars.githubusercontent.com/u/85164885?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","repository_url":"https://api.github.com/repos/open-quantum-safe/openssl","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/comments","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318/events","html_url":"https://github.com/open-quantum-safe/openssl/issues/318","id":925107062,"node_id":"MDU6SXNzdWU5MjUxMDcwNjI=","number":318,"title":"Overwriting method call through ENGINE","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2021-06-18T18:06:50Z","updated_at":"2021-06-19T09:47:01Z","closed_at":"2021-06-19T09:47:01Z","author_association":"NONE","active_lock_reason":null,"body":"Hi,\r\nI am working on a PoC application, where we want to overwrite the keygen method calls so that, when an OQS Signature keygen method is called through `EVP_PKEY_keygen()`, our method, registered in `pmeth->keygen`, will be invoked.\r\n\r\nI was looking for a way to overwrite the `ctx->pmeth->keygen`  value before passed to `int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)` method.\r\n\r\nI can achieve the above behaviour with RSA through ENGINE. It was a relatively easy setup, but I wasn't able to replicate it with OQS signatures, e.g. Dilithium. Existing code within oqs-engine project (not supported anymore) can do this but I couldn't get it to run with the latest version of OQS-OpenSSL.\r\n\r\nI read about, oqs-engine not being supported under OQS-OpenSSL anymore and it was advised to use Providers with the OpenSSL3.0 instead, but for our PoC, I need to work with the engine on OpenSSL 1.1.1 and OQS.\r\n\r\nIs it possible to achieve the behaviour described above through ENGINE for OQS signatures?\r\n\r\nAny help/lead is appreciated.\r\nRegards.","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments/864383539","html_url":"https://github.com/open-quantum-safe/openssl/issues/318#issuecomment-864383539","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/318","id":864383539,"node_id":"MDEyOklzc3VlQ29tbWVudDg2NDM4MzUzOQ==","user":{"login":"erdem-cqc","id":85164885,"node_id":"MDQ6VXNlcjg1MTY0ODg1","avatar_url":"https://avatars.githubusercontent.com/u/85164885?v=4","gravatar_id":"","url":"https://api.github.com/users/erdem-cqc","html_url":"https://github.com/erdem-cqc","followers_url":"https://api.github.com/users/erdem-cqc/followers","following_url":"https://api.github.com/users/erdem-cqc/following{/other_user}","gists_url":"https://api.github.com/users/erdem-cqc/gists{/gist_id}","starred_url":"https://api.github.com/users/erdem-cqc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/erdem-cqc/subscriptions","organizations_url":"https://api.github.com/users/erdem-cqc/orgs","repos_url":"https://api.github.com/users/erdem-cqc/repos","events_url":"https://api.github.com/users/erdem-cqc/events{/privacy}","received_events_url":"https://api.github.com/users/erdem-cqc/received_events","type":"User","site_admin":false},"created_at":"2021-06-19T09:47:01Z","updated_at":"2021-06-19T09:47:01Z","author_association":"NONE","body":"The aim to use latest OQS-OpenSSL fork is to benefit from the ongoing development around quantum crypto algorithms. \r\nAfter talking to you, I managed to run the oqse-engine with apps/openssl (haven't tried it up until now) as to check if the oqse-engine is being utilised when used as below\r\n```\r\nopenssl genpkey -algorithm dilithium2 -engine liboqse\r\n```\r\nand it didn't call the method registered in the oqs-engine. I think oqs-engine is not designed or meant to work as above. Their test code was working because it is making explicit call with the ctx object from engine. I think they designed it so that an external application can make calls to OQS utilising the OpenSSL engine structure. At least this is my limited understanding.\r\n\r\nI don't think there is a problem with any of the components, oqs-engine, OQS-OpenSSL or vanilla OpenSSL. Its just my expectation to get things running through engine as I did with RSA. Sorry, I might have wasted your time alongside who ever is watching this thread/issue.","performed_via_github_app":null}},"public":true,"created_at":"2021-06-19T09:47:01Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
