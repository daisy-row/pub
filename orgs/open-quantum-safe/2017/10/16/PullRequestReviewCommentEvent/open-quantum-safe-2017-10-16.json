{"id":"6721817715","type":"PullRequestReviewCommentEvent","actor":{"id":1345502,"login":"tlepoint","display_login":"tlepoint","gravatar_id":"","url":"https://api.github.com/users/tlepoint","avatar_url":"https://avatars.githubusercontent.com/u/1345502?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144841854","pull_request_review_id":69554370,"id":144841854,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {\n++\tOQS_KEX *k = malloc(sizeof(OQS_KEX));\n++\tif (k == NULL) {\n++\t\treturn NULL;\n++\t}\n++\tk->method_name = strdup(\"RLWE NewHope AVX2\");\n++\tk->estimated_classical_security = 229; // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known classical\n++\tk->estimated_quantum_security = 206;   // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known quantum\n++\tk->seed = NULL;\n++\tk->seed_len = 0;\n++\tk->named_parameters = 0;\n++\tk->rand = rand;\n++\tk->params = NULL;\n++\tk->alice_0 = &OQS_KEX_rlwe_newhope_avx2_alice_0;\n++\tk->bob = &OQS_KEX_rlwe_newhope_avx2_bob;\n++\tk->alice_1 = &OQS_KEX_rlwe_newhope_avx2_alice_1;\n++\tk->alice_priv_free = &OQS_KEX_rlwe_newhope_avx2_alice_priv_free;\n++\tk->free = &OQS_KEX_rlwe_newhope_avx2_free;\n++\treturn k;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(UNUSED OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len) {\n++\n++\tint ret;\n++\n++\t/* allocate public/private key pair */\n++\t*alice_msg = malloc(NEWHOPE_SENDABYTES);\n++\tif (*alice_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*alice_priv = malloc(sizeof(poly));\n++\tif (*alice_priv == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate public/private key pair */\n++\tnewhope_keygen(*alice_msg, (poly *) (*alice_priv));\n++\t*alice_msg_len = NEWHOPE_SENDABYTES;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*alice_msg);\n++\t*alice_msg = NULL;\n++\tfree(*alice_priv);\n++\t*alice_priv = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_bob(UNUSED OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (alice_msg_len != NEWHOPE_SENDABYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate message and session key */\n++\t*bob_msg = malloc(NEWHOPE_SENDBBYTES);\n++\tif (*bob_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Bob's response */\n++\tnewhope_sharedb(*key, *bob_msg, alice_msg);\n++\t*bob_msg_len = NEWHOPE_SENDBBYTES;\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*bob_msg);\n++\t*bob_msg = NULL;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(UNUSED OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (bob_msg_len != NEWHOPE_SENDBBYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate session key */\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Alice's session key */\n++\tnewhope_shareda(*key, (poly *) alice_priv, bob_msg);\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(UNUSED OQS_KEX *k, void *alice_priv) {\n++\tif (alice_priv) {\n++\t\tfree(alice_priv);\n++\t}\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k) {\n++\tif (k) {\n++\t\tfree(k->named_parameters);\n++\t\tk->named_parameters = NULL;\n++\t\tfree(k->method_name);\n++\t\tk->method_name = NULL;\n++\t}\n++\tfree(k);\n++}\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+new file mode 100644\n+index 0000000..6ab8921\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+@@ -0,0 +1,24 @@\n++/**\n++ * \\file kex_rlwe_newhope.h\n++ * \\brief Header for ring-LWE key exchange protocol NewHope\n++ */\n++\n++#ifndef __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++#define __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++\n++#include <stddef.h>\n++#include <stdint.h>\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand);\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len);\n++int OQS_KEX_rlwe_newhope_avx2_bob(OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len);\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len);\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(OQS_KEX *k, void *alice_priv);\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k);\n++\n++#endif\n+diff --git a/src/kex_rlwe_newhope/avx2/bitrev.s b/src/kex_rlwe_newhope/avx2/bitrev.s\n+index 002a1ee..faff35f 100644\n+--- a/src/kex_rlwe_newhope/avx2/bitrev.s\n++++ b/src/kex_rlwe_newhope/avx2/bitrev.s\n+@@ -37,10 +37,10 @@\n+ \n+ # qhasm: enter bitrev_vector\n+ .p2align 5\n+-.global _bitrev_vector\n+-.global bitrev_vector\n+-_bitrev_vector:\n+-bitrev_vector:\n++.global OQS_bitrev_vector\n++.global OQS_bitrev_vector\n++OQS_bitrev_vector:\n++OQS_bitrev_vector:\n+ movq %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/cbd.s b/src/kex_rlwe_newhope/avx2/cbd.s\n+index 7619a31..f2be41b 100644\n+--- a/src/kex_rlwe_newhope/avx2/cbd.s\n++++ b/src/kex_rlwe_newhope/avx2/cbd.s\n+@@ -59,10 +59,10 @@\n+ \n+ # qhasm: enter cbd\n+ .p2align 5\n+-.global _cbd\n+-.global cbd\n+-_cbd:\n+-cbd:\n++.global OQS_cbd\n++.global OQS_cbd\n++OQS_cbd:\n++OQS_cbd:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/chacha.S b/src/kex_rlwe_newhope/avx2/chacha.S\n+index 4597b5a..9a79f72 100644\n+--- a/src/kex_rlwe_newhope/avx2/chacha.S\n++++ b/src/kex_rlwe_newhope/avx2/chacha.S\n+@@ -18,14 +18,14 @@\n+ \r\n+ .text\r\n+ \r\n+-GLOBAL(chacha)\r\n+-GLOBAL(xchacha)\r\n+-GLOBAL(hchacha)\r\n+-GLOBAL(chacha_blocks)\r\n++GLOBAL(OQS_chacha)\r\n++GLOBAL(OQS_xchacha)\r\n++GLOBAL(OQS_hchacha)\r\n++GLOBAL(OQS_chacha_blocks)\r\n+ \r\n+ /* Windows 64 calling convention fixups */\r\n+ #if defined(_WIN64) || defined(__CYGWIN64__)\r\n+-FN(chacha)\r\n++FN(OQS_chacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -60,9 +60,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha)\r\n++ENDFN(OQS_chacha)\r\n+ \r\n+-FN(xchacha)\r\n++FN(OQS_xchacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -97,9 +97,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(xchacha)\r\n++ENDFN(OQS_xchacha)\r\n+ \r\n+-FN(chacha_blocks)\r\n++FN(OQS_chacha_blocks)\r\n+ subq $184, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movdqa %xmm7, 16(%rsp)\r\n+@@ -132,9 +132,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha_blocks)\r\n++ENDFN(OQS_chacha_blocks)\r\n+ \r\n+-FN(hchacha)\r\n++FN(OQS_hchacha)\r\n+ subq $40, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movq %rdi, 16(%rsp)\r\n+@@ -149,7 +149,7 @@ movq 16(%rsp), %rdi\n+ movq 24(%rsp), %rsi\r\n+ addq $40, %rsp\r\n+ ret\r\n+-ENDFN(hchacha)\r\n++ENDFN(OQS_hchacha)\r\n+ \r\n+ #define chacha chacha_thunk\r\n+ #define xchacha xchacha_thunk\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+index 48159c2..b0a84c6 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+@@ -217,7 +217,7 @@ static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned cha\n+   return inlen;\n+ }\n+ \n+-static const char iv[32] = {\n++static const unsigned iv[32] = {\n+   0x6a,0x09,0xe6,0x67,\n+   0xbb,0x67,0xae,0x85,\n+   0x3c,0x6e,0xf3,0x72,\n+@@ -228,7 +228,7 @@ static const char iv[32] = {\n+   0x5b,0xe0,0xcd,0x19,\n+ } ;\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n+ {\n+   unsigned char h[32];\n+   unsigned char padded[128];\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+index 4717f09..800ab4c 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+@@ -1,9 +1,9 @@\n+ #ifndef CRYPTO_HASH_SHA256_H\n+ #define CRYPTO_HASH_SHA256_H\n+ \n+-int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);static\n+ \n+ #define crypto_hash_sha256_BYTES 32\n+ \n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream.h b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+index aab8052..2053382 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+@@ -5,12 +5,12 @@\n+   #include \"crypto_stream_chacha20.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 8\n+-  #define crypto_stream crypto_stream_chacha20\n++  #define crypto_stream OQS_crypto_stream_chacha20\n+ #else\n+   #include \"crypto_stream_aes256ctr.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 16\n+-  #define crypto_stream crypto_stream_aes256ctr\n++  #define crypto_stream OQS_crypto_stream_aes256ctr\n+ #endif\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n+deleted file mode 100644\n+index 3b74551..0000000\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n++++ /dev/null\n+@@ -1,242 +0,0 @@\n+-/*\r\n+-  aesenc-int.c version $Date: 2014/08/22 16:49:12 $\r\n+-  AES-CTR\r\n+-  Romain Dolbeau\r\n+-  Public Domain\r\n+-*/\r\n+-\r\n+-#include <stdio.h>\r\n+-#include <stdlib.h>\r\n+-#include <string.h>\r\n+-#include <immintrin.h>\r\n+-#include \"crypto_stream_aes256ctr.h\"\r\n+-\r\n+-#ifdef __INTEL_COMPILER\r\n+-#define ALIGN16 __declspec(align(16))\r\n+-#define ALIGN32 __declspec(align(32))\r\n+-#define ALIGN64 __declspec(align(64))\r\n+-#else // assume GCC\r\n+-#define ALIGN16  __attribute__((aligned(16)))\r\n+-#define ALIGN32  __attribute__((aligned(32)))\r\n+-#define ALIGN64  __attribute__((aligned(64)))\r\n+-#define _bswap64(a) __builtin_bswap64(a)\r\n+-#define _bswap(a) __builtin_bswap(a)\r\n+-#endif\r\n+-\r\n+-static inline void aesni_key256_expand(const unsigned char* key, __m128 rkeys[16]) {\r\n+-  __m128 key0 = _mm_loadu_ps((const float *)(key+0));\r\n+-  __m128 key1 = _mm_loadu_ps((const float *)(key+16));\r\n+-  __m128 temp0, temp1, temp2, temp4;\r\n+-  int idx = 0;\r\n+-\r\n+-  rkeys[idx++] = key0;\r\n+-  temp0 = key0;\r\n+-  temp2 = key1;\r\n+-  temp4 = _mm_setzero_ps();\r\n+-\r\n+-  /* why single precision floating-point rather than integer instructions ?\r\n+-     because _mm_shuffle_ps takes two inputs, while _mm_shuffle_epi32 only\r\n+-     takes one - it doesn't perform the same computation...\r\n+-     _mm_shuffle_ps takes the lower 64 bits of the result from the first\r\n+-     operand, and the higher 64 bits of the result from the second operand\r\n+-     (in both cases, all four input floats are accessible).\r\n+-     I don't like the non-orthogonal naming scheme :-(\r\n+-     \r\n+-     This is all strongly inspired by the openssl assembly code.\r\n+-  */\r\n+-#define BLOCK1(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp2, IMM);       \\\r\n+-  rkeys[idx++] = temp2;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x10);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x8c);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xff);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp1)\r\n+-  \r\n+-#define BLOCK2(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp0, IMM);       \\\r\n+-  rkeys[idx++] = temp0;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x10);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x8c);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xaa);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp1)\r\n+-  \r\n+-  BLOCK1(0x01);\r\n+-  BLOCK2(0x01);\r\n+-\r\n+-  BLOCK1(0x02);\r\n+-  BLOCK2(0x02);\r\n+-\r\n+-  BLOCK1(0x04);\r\n+-  BLOCK2(0x04);\r\n+-\r\n+-  BLOCK1(0x08);\r\n+-  BLOCK2(0x08);\r\n+-\r\n+-  BLOCK1(0x10);\r\n+-  BLOCK2(0x10);\r\n+-\r\n+-  BLOCK1(0x20);\r\n+-  BLOCK2(0x20);\r\n+-\r\n+-  BLOCK1(0x40);\r\n+-  rkeys[idx++] = temp0;\r\n+-}\r\n+-\r\n+-/** single, by-the-book AES encryption with AES-NI */\r\n+-static inline void aesni_encrypt1(unsigned char *out, unsigned char *n, __m128i rkeys[16]) {\r\n+-  __m128i nv = _mm_load_si128((const __m128i *)n);\r\n+-  int i;\r\n+-  __m128i temp = _mm_xor_si128(nv, rkeys[0]);\r\n+-#pragma unroll(13)\r\n+-  for (i = 1 ; i < 14 ; i++) {\r\n+-    temp = _mm_aesenc_si128(temp, rkeys[i]);\r\n+-  }\r\n+-  temp = _mm_aesenclast_si128(temp, rkeys[14]);\r\n+-  _mm_store_si128((__m128i*)(out), temp);\r\n+-}\r\n+-\r\n+-/** increment the 16-bytes nonce ;\r\n+-    this really should be improved somehow...\r\n+-    but it's not yet time-critical, because we\r\n+-    use the vector variant anyway  */\r\n+-static inline void incle(unsigned char n[16]) {\r\n+-/*   unsigned long long out; */\r\n+-/*   unsigned char carry; */\r\n+-  unsigned long long *n_ = (unsigned long long*)n;\r\n+-  n_[1]++;\r\n+-  if (n_[1] == 0)\r\n+-    n_[0] ++;\r\n+-  /* perhaps this will be efficient on broadwell ? */\r\n+-  /*   carry = _addcarry_u64(0, n_[1], 1ULL, &out); */\r\n+-  /*   carry = _addcarry_u64(carry, n_[0], 0ULL, &out); */\r\n+-}\r\n+-\r\n+-/** multiple-blocks-at-once AES encryption with AES-NI ;\r\n+-    on Haswell, aesenc as a latency of 7 and a througput of 1\r\n+-    so the sequence of aesenc should be bubble-free, if you\r\n+-    have at least 8 blocks. Let's build an arbitratry-sized\r\n+-    function */\r\n+-/* Step 1 : loading the nonce */\r\n+-/* load & increment the n vector (non-vectorized, unused for now) */\r\n+-#define NVx(a)                                                  \\\r\n+-  __m128i nv##a = _mm_shuffle_epi8(_mm_load_si128((const __m128i *)n), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7)); incle(n)\r\n+-/* load the incremented n vector (vectorized, probably buggy) */\r\n+-#define NVxV_DEC(a)                                                     \\\r\n+-  __m128i nv##a;\r\n+-#define NVxV_NOWRAP(a)                                                  \\\r\n+-  nv##a = _mm_shuffle_epi8(_mm_add_epi64(nv0i, _mm_set_epi64x(a,0)), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-#define NVxV_WRAP(a)                                                    \\\r\n+-  __m128i ad##a = _mm_add_epi64(nv0i, _mm_set_epi64x(a,a>=wrapnumber?1:0)); \\\r\n+-  nv##a = _mm_shuffle_epi8(ad##a, _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-\r\n+-/* Step 2 : define value in round one (xor with subkey #0, aka key) */\r\n+-#define TEMPx(a)                                        \\\r\n+-  __m128i temp##a = _mm_xor_si128(nv##a, rkeys[0])\r\n+-\r\n+-/* Step 3: one round of AES */\r\n+-#define AESENCx(a)                                      \\\r\n+-  temp##a =  _mm_aesenc_si128(temp##a, rkeys[i]);\r\n+-\r\n+-/* Step 4: last round of AES */\r\n+-#define AESENCLASTx(a)                                  \\\r\n+-  temp##a = _mm_aesenclast_si128(temp##a, rkeys[14]);\r\n+-\r\n+-/* Step 5: store result */\r\n+-#define STOREx(a)                                       \\\r\n+-  _mm_store_si128((__m128i*)(out+(a*16)), temp##a);\r\n+-\r\n+-/* all the MAKE* macros are for automatic explicit unrolling */\r\n+-#define MAKE4(X)                                \\\r\n+-  X(0);X(1);X(2);X(3)\r\n+-\r\n+-#define MAKE6(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5)\r\n+-\r\n+-#define MAKE7(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6)\r\n+-\r\n+-#define MAKE8(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7)\r\n+-\r\n+-#define MAKE10(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9)\r\n+-\r\n+-#define MAKE12(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9);X(10);X(11)\r\n+-\r\n+-/* create a function of unrolling N ; the MAKEN is the unrolling\r\n+-   macro, defined above. The N in MAKEN must match N, obviously. */\r\n+-#define FUNC(N, MAKEN)                          \\\r\n+-  static inline void aesni_encrypt##N(unsigned char *out, unsigned char *n, __m128i rkeys[16]) { \\\r\n+-    __m128i nv0i = _mm_load_si128((const __m128i *)n);                  \\\r\n+-    long long nl = *(long long*)&n[8];                                  \\\r\n+-    MAKEN(NVxV_DEC);                                                    \\\r\n+-    /* check for nonce wraparound */                                    \\\r\n+-    if ((nl < 0) && (nl + (N-1)) >= 0) {                                \\\r\n+-      int wrapnumber = (int)(N - (nl+N));                               \\\r\n+-      MAKEN(NVxV_WRAP);                                                 \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,1))); \\\r\n+-    } else {                                                            \\\r\n+-      MAKEN(NVxV_NOWRAP);                                               \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,0))); \\\r\n+-    }                                                                   \\\r\n+-    int i;                                                              \\\r\n+-    MAKEN(TEMPx);                                                       \\\r\n+-    for (i = 1 ; i < 14 ; i++) {                                        \\\r\n+-      MAKEN(AESENCx);                                                   \\\r\n+-    }                                                                   \\\r\n+-    MAKEN(AESENCLASTx);                                                 \\\r\n+-    MAKEN(STOREx);                                                      \\\r\n+-  }\r\n+-\r\n+-/* and now building our unrolled function is trivial */\r\n+-FUNC(4, MAKE4)\r\n+-FUNC(6, MAKE6)\r\n+-FUNC(7, MAKE7)\r\n+-FUNC(8, MAKE8)\r\n+-FUNC(10, MAKE10)\r\n+-FUNC(12, MAKE12)\r\n+-\r\n+-int crypto_stream_aes256ctr(\r\n+-unsigned char *out,\r\n+-unsigned long long outlen,\r\n+-const unsigned char *n,\r\n+-const unsigned char *k\r\n+-)\r\n+-{\r\n+-  __m128 rkeys[16];\r\n+-  ALIGN16 unsigned char n2[16];\r\n+-  unsigned long long i, j;\r\n+-  aesni_key256_expand(k, rkeys);\r\n+-  /* n2 is in byte-reversed (i.e., native little endian)\r\n+-     order to make increment/testing easier */\r\n+-  (*(unsigned long long*)&n2[8]) = _bswap64((*(unsigned long long*)&n[8]));\r\n+-  (*(unsigned long long*)&n2[0]) = _bswap64((*(unsigned long long*)&n[0]));\r\n+-  \r\n+-#define LOOP(iter)                                       \\\r\n+-  int lb = iter * 16;                                    \\\r\n+-  for (i = 0 ; i < outlen ; i+= lb) {                    \\\r\n+-    ALIGN16 unsigned char outni[lb];       \\\r\n+-    aesni_encrypt##iter(outni, n2, (__m128i*)rkeys);     \\\r\n+-    unsigned long long mj = lb;                          \\\r\n+-    if ((i+mj)>=outlen)                                  \\\r\n+-      mj = outlen-i;                                     \\\r\n+-    for (j = 0 ; j < mj ; j++)                           \\\r\n+-      out[i+j] = outni[j];                               \\\r\n+-  }\r\n+-  \r\n+-  LOOP(8);\r\n+-\r\n+-  return 0;\r\n+-}\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+index 9be2881..f694dc9 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+@@ -1,6 +1,6 @@\n+ #ifndef CRYPTO_STREAM_AES256CTR_H\r\n+ #define CRYPTO_STREAM_AES256CTR_H\r\n+ \r\n+-int crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n++int OQS_crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+index 0b56a2b..0c0b1db 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+@@ -4,9 +4,9 @@\n+ \t.text\n+ .LHOTB11:\n+ \t.p2align 4,,15\n+-\t.globl\tcrypto_stream_aes256ctr\n+-\t.type\tcrypto_stream_aes256ctr, @function\n+-crypto_stream_aes256ctr:\n++\t.globl\tOQS_crypto_stream_aes256ctr\n++\t.type\tOQS_crypto_stream_aes256ctr, @function\n++OQS_crypto_stream_aes256ctr:\n+ .LFB2248:\n+ \t.cfi_startproc\n+ \tpushq\t%rbp\n+@@ -328,7 +328,7 @@ crypto_stream_aes256ctr:\n+ \tret\n+ \t.cfi_endproc\n+ .LFE2248:\n+-\t.size\tcrypto_stream_aes256ctr, .-crypto_stream_aes256ctr\n++\t.size\tOQS_crypto_stream_aes256ctr, .-OQS_crypto_stream_aes256ctr\n+ \t.section\t.text.unlikely\n+ .LCOLDE11:\n+ \t.text\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+index a3ffee1..d4e511b 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+@@ -1,10 +1,10 @@\n+ #include \"crypto_stream_chacha20.h\"\n+ #include <stddef.h>\n+ \n+-extern void chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n++extern void OQS_chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n+ \n+-int crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k) \n++int OQS_crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k)\n+ {\n+-\tchacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n++\tOQS_chacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n+ \treturn 0;\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.c b/src/kex_rlwe_newhope/avx2/error_correction.c\n+index 0970e6f..eaf2952 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.c\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.c\n+@@ -3,7 +3,7 @@\n+ \n+ //See paper for details on the error reconciliation\n+ \n+-extern void hr(poly *c, const poly *v, unsigned char rand[32]);\n++extern void OQS_hr(poly *c, const poly *v, unsigned char rand[32]);\n+ \n+ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce)\n+ {\n+@@ -17,5 +17,5 @@ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char no\n+ \n+   crypto_stream(rand,32,n,seed);\n+ \n+-  hr(c, v, rand);\n++  OQS_hr(c, v, rand);\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.h b/src/kex_rlwe_newhope/avx2/error_correction.h\n+index 488c105..c0e913d 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.h\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.h\n+@@ -9,7 +9,7 @@\n+ #include \"poly.h\"\n+ #include <stdio.h>\n+ \n+-void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n+-void rec(unsigned char *key, const poly *v, const poly *c);\n++static void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n++void OQS_rec(unsigned char *key, const poly *v, const poly *c);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.c b/src/kex_rlwe_newhope/avx2/fips202.c\n+index f649a7d..b83029c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.c\n++++ b/src/kex_rlwe_newhope/avx2/fips202.c\n+@@ -60,7 +60,7 @@ static const uint64_t KeccakF_RoundConstants[NROUNDS] =\n+     (uint64_t)0x8000000080008008ULL\n+ };\n+ \n+-void KeccakF1600_StatePermute(uint64_t * state)\n++static void KeccakF1600_StatePermute(uint64_t * state)\n+ {\n+   int round;\n+ \n+@@ -381,19 +381,19 @@ static void keccak_squeezeblocks(unsigned char *h, unsigned long long int nblock\n+ }\n+ \n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   keccak_absorb(s, SHAKE128_RATE, input, inputByteLen, 0x1F);\n+ }\n+ \n+ \n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n+ {\n+   keccak_squeezeblocks(output, nblocks, s, SHAKE128_RATE);\n+ }\n+ \n+ \n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   assert(!(outputByteLen%SHAKE128_RATE));\n+@@ -402,7 +402,7 @@ void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned\n+ }\n+ \n+ \n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   unsigned char t[SHA3_256_RATE];\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.h b/src/kex_rlwe_newhope/avx2/fips202.h\n+index b564434..d02ec7c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.h\n++++ b/src/kex_rlwe_newhope/avx2/fips202.h\n+@@ -4,9 +4,9 @@\n+ #define SHAKE128_RATE 168\n+ #define SHA3_256_RATE 136\n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/hr.s b/src/kex_rlwe_newhope/avx2/hr.s\n+index beb93fe..7eac399 100644\n+--- a/src/kex_rlwe_newhope/avx2/hr.s\n++++ b/src/kex_rlwe_newhope/avx2/hr.s\n+@@ -81,10 +81,10 @@\n+ \n+ # qhasm: enter hr\n+ .p2align 5\n+-.global _hr\n+-.global hr\n+-_hr:\n+-hr:\n++.global OQS_hr\n++.global OQS_hr\n++OQS_hr:\n++OQS_hr:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/newhope.c b/src/kex_rlwe_newhope/avx2/newhope.c\n+index b9f7a6c..f0c5ad9 100644\n+--- a/src/kex_rlwe_newhope/avx2/newhope.c\n++++ b/src/kex_rlwe_newhope/avx2/newhope.c\n+@@ -1,7 +1,5 @@\n+-#include \"poly.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"error_correction.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"poly.c\"\r\n++#include \"error_correction.c\"\r\n+ \r\n+ static void encode_a(unsigned char *r, const poly *pk, const unsigned char *seed)\r\n+ {\r\n+@@ -48,7 +46,7 @@ static void gen_a(poly *a, const unsigned char *seed)\n+ \r\n+ // API FUNCTIONS \r\n+ \r\n+-void newhope_keygen(unsigned char *send, poly *sk)\r\n++static void newhope_keygen(unsigned char *send, poly *sk)\r\n+ {\r\n+   poly a, e, r, pk;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -66,14 +64,14 @@ void newhope_keygen(unsigned char *send, poly *sk)\n+   poly_getnoise(&e,noiseseed,1);\r\n+   poly_ntt(&e);\r\n+ \r\n+-  poly_pointwise(&r,sk,&a);\r\n++  OQS_poly_pointwise(&r,sk,&a);\r\n+   poly_add(&pk,&e,&r);\r\n+ \r\n+   encode_a(send, &pk, seed);\r\n+ }\r\n+ \r\n+ \r\n+-void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n++static void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n+ {\r\n+   poly sp, ep, v, a, pka, c, epp, bp;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -89,10 +87,10 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+   poly_getnoise(&ep,noiseseed,1);\r\n+   poly_ntt(&ep);\r\n+ \r\n+-  poly_pointwise(&bp, &a, &sp);\r\n++  OQS_poly_pointwise(&bp, &a, &sp);\r\n+   poly_add(&bp, &bp, &ep);\r\n+   \r\n+-  poly_pointwise(&v, &pka, &sp);\r\n++  OQS_poly_pointwise(&v, &pka, &sp);\r\n+   poly_invntt(&v);\r\n+ \r\n+   poly_getnoise(&epp,noiseseed,2);\r\n+@@ -102,7 +100,7 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ \r\n+   encode_b(send, &bp, &c);\r\n+   \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32);\r\n+@@ -110,16 +108,16 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ }\r\n+ \r\n+ \r\n+-void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n++static void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n+ {\r\n+   poly v,bp, c;\r\n+ \r\n+   decode_b(&bp, &c, received);\r\n+ \r\n+-  poly_pointwise(&v,sk,&bp);\r\n++  OQS_poly_pointwise(&v,sk,&bp);\r\n+   poly_invntt(&v);\r\n+  \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32); \r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt.h b/src/kex_rlwe_newhope/avx2/ntt.h\n+index c24b137..1cb540a 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt.h\n++++ b/src/kex_rlwe_newhope/avx2/ntt.h\n+@@ -8,8 +8,8 @@ extern int32_t psis_inv[];\n+ extern double omegas_double[];\r\n+ extern double omegas_inv_double[];\r\n+ \r\n+-void bitrev_vector(int32_t* poly);\r\n+-void pwmul_double(int32_t* poly, const int32_t* factors);\r\n+-void ntt_double(int32_t*,const double*,const double*);\r\n++void OQS_bitrev_vector(int32_t* poly);\r\n++void OQS_pwmul_double(int32_t* poly, const int32_t* factors);\r\n++void OQS_ntt_double(int32_t*,const double*,const double*);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt_double.s b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+index 1ec429f..d876550 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt_double.s\n++++ b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+@@ -76,9 +76,9 @@\n+ # qhasm: enter ntt_double\n+ .p2align 5\n+ .global _ntt_double\n+-.global ntt_double\n++.global OQS_ntt_double\n+ _ntt_double:\n+-ntt_double:\n++OQS_ntt_double:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/poly.c b/src/kex_rlwe_newhope/avx2/poly.c\n+index 43c0df2..44b0956 100644\n+--- a/src/kex_rlwe_newhope/avx2/poly.c\n++++ b/src/kex_rlwe_newhope/avx2/poly.c\n+@@ -1,7 +1,7 @@\n+ #include \"poly.h\"\r\n+ #include \"ntt.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"randombytes.c\"\r\n++#include \"fips202.c\"\r\n+ #include \"crypto_stream.h\"\r\n+ \r\n+ static uint16_t barrett_reduce(uint16_t a)\r\n+@@ -14,7 +14,7 @@ static uint16_t barrett_reduce(uint16_t a)\n+   return a;\r\n+ }\r\n+ \r\n+-void poly_frombytes(poly *r, const unsigned char *a)\r\n++static void poly_frombytes(poly *r, const unsigned char *a)\r\n+ {\r\n+   int i;\r\n+   for(i=0;i<PARAM_N/4;i++)\r\n+@@ -26,7 +26,7 @@ void poly_frombytes(poly *r, const unsigned char *a)\n+   }\r\n+ }\r\n+ \r\n+-void poly_tobytes(unsigned char *r, const poly *p)\r\n++static void poly_tobytes(unsigned char *r, const poly *p)\r\n+ {\r\n+   int i;\r\n+   uint16_t t0,t1,t2,t3,m;\r\n+@@ -70,7 +70,7 @@ void poly_tobytes(unsigned char *r, const poly *p)\n+ \r\n+ \r\n+ \r\n+-void poly_uniform(poly *a, const unsigned char *seed)\r\n++static void poly_uniform(poly *a, const unsigned char *seed)\r\n+ {\r\n+   unsigned int pos=0, ctr=0;\r\n+   uint16_t val;\r\n+@@ -99,9 +99,9 @@ void poly_uniform(poly *a, const unsigned char *seed)\n+ }\r\n+ \r\n+ \r\n+-extern void cbd(poly *r, unsigned char *b);\r\n++extern void OQS_cbd(poly *r, unsigned char *b);\r","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":940,"original_position":940,"commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"tlepoint","id":1345502,"avatar_url":"https://avatars3.githubusercontent.com/u/1345502?v=4","gravatar_id":"","url":"https://api.github.com/users/tlepoint","html_url":"https://github.com/tlepoint","followers_url":"https://api.github.com/users/tlepoint/followers","following_url":"https://api.github.com/users/tlepoint/following{/other_user}","gists_url":"https://api.github.com/users/tlepoint/gists{/gist_id}","starred_url":"https://api.github.com/users/tlepoint/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlepoint/subscriptions","organizations_url":"https://api.github.com/users/tlepoint/orgs","repos_url":"https://api.github.com/users/tlepoint/repos","events_url":"https://api.github.com/users/tlepoint/events{/privacy}","received_events_url":"https://api.github.com/users/tlepoint/received_events","type":"User","site_admin":false},"body":"Should that be `static` (after including the c file rather than renaming the function)?","created_at":"2017-10-16T13:12:14Z","updated_at":"2017-10-16T13:12:14Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144841854","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144841854"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144841854"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}}},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T13:12:14Z","closed_at":null,"merged_at":null,"merge_commit_sha":"5ee0ddb658666f8e218f74d7296cf00815f6e2dd","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T13:12:14Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6721819984","type":"PullRequestReviewCommentEvent","actor":{"id":1345502,"login":"tlepoint","display_login":"tlepoint","gravatar_id":"","url":"https://api.github.com/users/tlepoint","avatar_url":"https://avatars.githubusercontent.com/u/1345502?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144841960","pull_request_review_id":69554486,"id":144841960,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {\n++\tOQS_KEX *k = malloc(sizeof(OQS_KEX));\n++\tif (k == NULL) {\n++\t\treturn NULL;\n++\t}\n++\tk->method_name = strdup(\"RLWE NewHope AVX2\");\n++\tk->estimated_classical_security = 229; // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known classical\n++\tk->estimated_quantum_security = 206;   // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known quantum\n++\tk->seed = NULL;\n++\tk->seed_len = 0;\n++\tk->named_parameters = 0;\n++\tk->rand = rand;\n++\tk->params = NULL;\n++\tk->alice_0 = &OQS_KEX_rlwe_newhope_avx2_alice_0;\n++\tk->bob = &OQS_KEX_rlwe_newhope_avx2_bob;\n++\tk->alice_1 = &OQS_KEX_rlwe_newhope_avx2_alice_1;\n++\tk->alice_priv_free = &OQS_KEX_rlwe_newhope_avx2_alice_priv_free;\n++\tk->free = &OQS_KEX_rlwe_newhope_avx2_free;\n++\treturn k;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(UNUSED OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len) {\n++\n++\tint ret;\n++\n++\t/* allocate public/private key pair */\n++\t*alice_msg = malloc(NEWHOPE_SENDABYTES);\n++\tif (*alice_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*alice_priv = malloc(sizeof(poly));\n++\tif (*alice_priv == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate public/private key pair */\n++\tnewhope_keygen(*alice_msg, (poly *) (*alice_priv));\n++\t*alice_msg_len = NEWHOPE_SENDABYTES;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*alice_msg);\n++\t*alice_msg = NULL;\n++\tfree(*alice_priv);\n++\t*alice_priv = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_bob(UNUSED OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (alice_msg_len != NEWHOPE_SENDABYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate message and session key */\n++\t*bob_msg = malloc(NEWHOPE_SENDBBYTES);\n++\tif (*bob_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Bob's response */\n++\tnewhope_sharedb(*key, *bob_msg, alice_msg);\n++\t*bob_msg_len = NEWHOPE_SENDBBYTES;\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*bob_msg);\n++\t*bob_msg = NULL;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(UNUSED OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (bob_msg_len != NEWHOPE_SENDBBYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate session key */\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Alice's session key */\n++\tnewhope_shareda(*key, (poly *) alice_priv, bob_msg);\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(UNUSED OQS_KEX *k, void *alice_priv) {\n++\tif (alice_priv) {\n++\t\tfree(alice_priv);\n++\t}\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k) {\n++\tif (k) {\n++\t\tfree(k->named_parameters);\n++\t\tk->named_parameters = NULL;\n++\t\tfree(k->method_name);\n++\t\tk->method_name = NULL;\n++\t}\n++\tfree(k);\n++}\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+new file mode 100644\n+index 0000000..6ab8921\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+@@ -0,0 +1,24 @@\n++/**\n++ * \\file kex_rlwe_newhope.h\n++ * \\brief Header for ring-LWE key exchange protocol NewHope\n++ */\n++\n++#ifndef __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++#define __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++\n++#include <stddef.h>\n++#include <stdint.h>\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand);\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len);\n++int OQS_KEX_rlwe_newhope_avx2_bob(OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len);\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len);\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(OQS_KEX *k, void *alice_priv);\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k);\n++\n++#endif\n+diff --git a/src/kex_rlwe_newhope/avx2/bitrev.s b/src/kex_rlwe_newhope/avx2/bitrev.s\n+index 002a1ee..faff35f 100644\n+--- a/src/kex_rlwe_newhope/avx2/bitrev.s\n++++ b/src/kex_rlwe_newhope/avx2/bitrev.s\n+@@ -37,10 +37,10 @@\n+ \n+ # qhasm: enter bitrev_vector\n+ .p2align 5\n+-.global _bitrev_vector\n+-.global bitrev_vector\n+-_bitrev_vector:\n+-bitrev_vector:\n++.global OQS_bitrev_vector\n++.global OQS_bitrev_vector\n++OQS_bitrev_vector:\n++OQS_bitrev_vector:\n+ movq %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/cbd.s b/src/kex_rlwe_newhope/avx2/cbd.s\n+index 7619a31..f2be41b 100644\n+--- a/src/kex_rlwe_newhope/avx2/cbd.s\n++++ b/src/kex_rlwe_newhope/avx2/cbd.s\n+@@ -59,10 +59,10 @@\n+ \n+ # qhasm: enter cbd\n+ .p2align 5\n+-.global _cbd\n+-.global cbd\n+-_cbd:\n+-cbd:\n++.global OQS_cbd\n++.global OQS_cbd\n++OQS_cbd:\n++OQS_cbd:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/chacha.S b/src/kex_rlwe_newhope/avx2/chacha.S\n+index 4597b5a..9a79f72 100644\n+--- a/src/kex_rlwe_newhope/avx2/chacha.S\n++++ b/src/kex_rlwe_newhope/avx2/chacha.S\n+@@ -18,14 +18,14 @@\n+ \r\n+ .text\r\n+ \r\n+-GLOBAL(chacha)\r\n+-GLOBAL(xchacha)\r\n+-GLOBAL(hchacha)\r\n+-GLOBAL(chacha_blocks)\r\n++GLOBAL(OQS_chacha)\r\n++GLOBAL(OQS_xchacha)\r\n++GLOBAL(OQS_hchacha)\r\n++GLOBAL(OQS_chacha_blocks)\r\n+ \r\n+ /* Windows 64 calling convention fixups */\r\n+ #if defined(_WIN64) || defined(__CYGWIN64__)\r\n+-FN(chacha)\r\n++FN(OQS_chacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -60,9 +60,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha)\r\n++ENDFN(OQS_chacha)\r\n+ \r\n+-FN(xchacha)\r\n++FN(OQS_xchacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -97,9 +97,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(xchacha)\r\n++ENDFN(OQS_xchacha)\r\n+ \r\n+-FN(chacha_blocks)\r\n++FN(OQS_chacha_blocks)\r\n+ subq $184, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movdqa %xmm7, 16(%rsp)\r\n+@@ -132,9 +132,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha_blocks)\r\n++ENDFN(OQS_chacha_blocks)\r\n+ \r\n+-FN(hchacha)\r\n++FN(OQS_hchacha)\r\n+ subq $40, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movq %rdi, 16(%rsp)\r\n+@@ -149,7 +149,7 @@ movq 16(%rsp), %rdi\n+ movq 24(%rsp), %rsi\r\n+ addq $40, %rsp\r\n+ ret\r\n+-ENDFN(hchacha)\r\n++ENDFN(OQS_hchacha)\r\n+ \r\n+ #define chacha chacha_thunk\r\n+ #define xchacha xchacha_thunk\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+index 48159c2..b0a84c6 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+@@ -217,7 +217,7 @@ static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned cha\n+   return inlen;\n+ }\n+ \n+-static const char iv[32] = {\n++static const unsigned iv[32] = {\n+   0x6a,0x09,0xe6,0x67,\n+   0xbb,0x67,0xae,0x85,\n+   0x3c,0x6e,0xf3,0x72,\n+@@ -228,7 +228,7 @@ static const char iv[32] = {\n+   0x5b,0xe0,0xcd,0x19,\n+ } ;\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n+ {\n+   unsigned char h[32];\n+   unsigned char padded[128];\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+index 4717f09..800ab4c 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+@@ -1,9 +1,9 @@\n+ #ifndef CRYPTO_HASH_SHA256_H\n+ #define CRYPTO_HASH_SHA256_H\n+ \n+-int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);static\n+ \n+ #define crypto_hash_sha256_BYTES 32\n+ \n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream.h b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+index aab8052..2053382 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+@@ -5,12 +5,12 @@\n+   #include \"crypto_stream_chacha20.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 8\n+-  #define crypto_stream crypto_stream_chacha20\n++  #define crypto_stream OQS_crypto_stream_chacha20\n+ #else\n+   #include \"crypto_stream_aes256ctr.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 16\n+-  #define crypto_stream crypto_stream_aes256ctr\n++  #define crypto_stream OQS_crypto_stream_aes256ctr\n+ #endif\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n+deleted file mode 100644\n+index 3b74551..0000000\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n++++ /dev/null\n+@@ -1,242 +0,0 @@\n+-/*\r\n+-  aesenc-int.c version $Date: 2014/08/22 16:49:12 $\r\n+-  AES-CTR\r\n+-  Romain Dolbeau\r\n+-  Public Domain\r\n+-*/\r\n+-\r\n+-#include <stdio.h>\r\n+-#include <stdlib.h>\r\n+-#include <string.h>\r\n+-#include <immintrin.h>\r\n+-#include \"crypto_stream_aes256ctr.h\"\r\n+-\r\n+-#ifdef __INTEL_COMPILER\r\n+-#define ALIGN16 __declspec(align(16))\r\n+-#define ALIGN32 __declspec(align(32))\r\n+-#define ALIGN64 __declspec(align(64))\r\n+-#else // assume GCC\r\n+-#define ALIGN16  __attribute__((aligned(16)))\r\n+-#define ALIGN32  __attribute__((aligned(32)))\r\n+-#define ALIGN64  __attribute__((aligned(64)))\r\n+-#define _bswap64(a) __builtin_bswap64(a)\r\n+-#define _bswap(a) __builtin_bswap(a)\r\n+-#endif\r\n+-\r\n+-static inline void aesni_key256_expand(const unsigned char* key, __m128 rkeys[16]) {\r\n+-  __m128 key0 = _mm_loadu_ps((const float *)(key+0));\r\n+-  __m128 key1 = _mm_loadu_ps((const float *)(key+16));\r\n+-  __m128 temp0, temp1, temp2, temp4;\r\n+-  int idx = 0;\r\n+-\r\n+-  rkeys[idx++] = key0;\r\n+-  temp0 = key0;\r\n+-  temp2 = key1;\r\n+-  temp4 = _mm_setzero_ps();\r\n+-\r\n+-  /* why single precision floating-point rather than integer instructions ?\r\n+-     because _mm_shuffle_ps takes two inputs, while _mm_shuffle_epi32 only\r\n+-     takes one - it doesn't perform the same computation...\r\n+-     _mm_shuffle_ps takes the lower 64 bits of the result from the first\r\n+-     operand, and the higher 64 bits of the result from the second operand\r\n+-     (in both cases, all four input floats are accessible).\r\n+-     I don't like the non-orthogonal naming scheme :-(\r\n+-     \r\n+-     This is all strongly inspired by the openssl assembly code.\r\n+-  */\r\n+-#define BLOCK1(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp2, IMM);       \\\r\n+-  rkeys[idx++] = temp2;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x10);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x8c);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xff);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp1)\r\n+-  \r\n+-#define BLOCK2(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp0, IMM);       \\\r\n+-  rkeys[idx++] = temp0;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x10);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x8c);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xaa);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp1)\r\n+-  \r\n+-  BLOCK1(0x01);\r\n+-  BLOCK2(0x01);\r\n+-\r\n+-  BLOCK1(0x02);\r\n+-  BLOCK2(0x02);\r\n+-\r\n+-  BLOCK1(0x04);\r\n+-  BLOCK2(0x04);\r\n+-\r\n+-  BLOCK1(0x08);\r\n+-  BLOCK2(0x08);\r\n+-\r\n+-  BLOCK1(0x10);\r\n+-  BLOCK2(0x10);\r\n+-\r\n+-  BLOCK1(0x20);\r\n+-  BLOCK2(0x20);\r\n+-\r\n+-  BLOCK1(0x40);\r\n+-  rkeys[idx++] = temp0;\r\n+-}\r\n+-\r\n+-/** single, by-the-book AES encryption with AES-NI */\r\n+-static inline void aesni_encrypt1(unsigned char *out, unsigned char *n, __m128i rkeys[16]) {\r\n+-  __m128i nv = _mm_load_si128((const __m128i *)n);\r\n+-  int i;\r\n+-  __m128i temp = _mm_xor_si128(nv, rkeys[0]);\r\n+-#pragma unroll(13)\r\n+-  for (i = 1 ; i < 14 ; i++) {\r\n+-    temp = _mm_aesenc_si128(temp, rkeys[i]);\r\n+-  }\r\n+-  temp = _mm_aesenclast_si128(temp, rkeys[14]);\r\n+-  _mm_store_si128((__m128i*)(out), temp);\r\n+-}\r\n+-\r\n+-/** increment the 16-bytes nonce ;\r\n+-    this really should be improved somehow...\r\n+-    but it's not yet time-critical, because we\r\n+-    use the vector variant anyway  */\r\n+-static inline void incle(unsigned char n[16]) {\r\n+-/*   unsigned long long out; */\r\n+-/*   unsigned char carry; */\r\n+-  unsigned long long *n_ = (unsigned long long*)n;\r\n+-  n_[1]++;\r\n+-  if (n_[1] == 0)\r\n+-    n_[0] ++;\r\n+-  /* perhaps this will be efficient on broadwell ? */\r\n+-  /*   carry = _addcarry_u64(0, n_[1], 1ULL, &out); */\r\n+-  /*   carry = _addcarry_u64(carry, n_[0], 0ULL, &out); */\r\n+-}\r\n+-\r\n+-/** multiple-blocks-at-once AES encryption with AES-NI ;\r\n+-    on Haswell, aesenc as a latency of 7 and a througput of 1\r\n+-    so the sequence of aesenc should be bubble-free, if you\r\n+-    have at least 8 blocks. Let's build an arbitratry-sized\r\n+-    function */\r\n+-/* Step 1 : loading the nonce */\r\n+-/* load & increment the n vector (non-vectorized, unused for now) */\r\n+-#define NVx(a)                                                  \\\r\n+-  __m128i nv##a = _mm_shuffle_epi8(_mm_load_si128((const __m128i *)n), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7)); incle(n)\r\n+-/* load the incremented n vector (vectorized, probably buggy) */\r\n+-#define NVxV_DEC(a)                                                     \\\r\n+-  __m128i nv##a;\r\n+-#define NVxV_NOWRAP(a)                                                  \\\r\n+-  nv##a = _mm_shuffle_epi8(_mm_add_epi64(nv0i, _mm_set_epi64x(a,0)), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-#define NVxV_WRAP(a)                                                    \\\r\n+-  __m128i ad##a = _mm_add_epi64(nv0i, _mm_set_epi64x(a,a>=wrapnumber?1:0)); \\\r\n+-  nv##a = _mm_shuffle_epi8(ad##a, _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-\r\n+-/* Step 2 : define value in round one (xor with subkey #0, aka key) */\r\n+-#define TEMPx(a)                                        \\\r\n+-  __m128i temp##a = _mm_xor_si128(nv##a, rkeys[0])\r\n+-\r\n+-/* Step 3: one round of AES */\r\n+-#define AESENCx(a)                                      \\\r\n+-  temp##a =  _mm_aesenc_si128(temp##a, rkeys[i]);\r\n+-\r\n+-/* Step 4: last round of AES */\r\n+-#define AESENCLASTx(a)                                  \\\r\n+-  temp##a = _mm_aesenclast_si128(temp##a, rkeys[14]);\r\n+-\r\n+-/* Step 5: store result */\r\n+-#define STOREx(a)                                       \\\r\n+-  _mm_store_si128((__m128i*)(out+(a*16)), temp##a);\r\n+-\r\n+-/* all the MAKE* macros are for automatic explicit unrolling */\r\n+-#define MAKE4(X)                                \\\r\n+-  X(0);X(1);X(2);X(3)\r\n+-\r\n+-#define MAKE6(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5)\r\n+-\r\n+-#define MAKE7(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6)\r\n+-\r\n+-#define MAKE8(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7)\r\n+-\r\n+-#define MAKE10(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9)\r\n+-\r\n+-#define MAKE12(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9);X(10);X(11)\r\n+-\r\n+-/* create a function of unrolling N ; the MAKEN is the unrolling\r\n+-   macro, defined above. The N in MAKEN must match N, obviously. */\r\n+-#define FUNC(N, MAKEN)                          \\\r\n+-  static inline void aesni_encrypt##N(unsigned char *out, unsigned char *n, __m128i rkeys[16]) { \\\r\n+-    __m128i nv0i = _mm_load_si128((const __m128i *)n);                  \\\r\n+-    long long nl = *(long long*)&n[8];                                  \\\r\n+-    MAKEN(NVxV_DEC);                                                    \\\r\n+-    /* check for nonce wraparound */                                    \\\r\n+-    if ((nl < 0) && (nl + (N-1)) >= 0) {                                \\\r\n+-      int wrapnumber = (int)(N - (nl+N));                               \\\r\n+-      MAKEN(NVxV_WRAP);                                                 \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,1))); \\\r\n+-    } else {                                                            \\\r\n+-      MAKEN(NVxV_NOWRAP);                                               \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,0))); \\\r\n+-    }                                                                   \\\r\n+-    int i;                                                              \\\r\n+-    MAKEN(TEMPx);                                                       \\\r\n+-    for (i = 1 ; i < 14 ; i++) {                                        \\\r\n+-      MAKEN(AESENCx);                                                   \\\r\n+-    }                                                                   \\\r\n+-    MAKEN(AESENCLASTx);                                                 \\\r\n+-    MAKEN(STOREx);                                                      \\\r\n+-  }\r\n+-\r\n+-/* and now building our unrolled function is trivial */\r\n+-FUNC(4, MAKE4)\r\n+-FUNC(6, MAKE6)\r\n+-FUNC(7, MAKE7)\r\n+-FUNC(8, MAKE8)\r\n+-FUNC(10, MAKE10)\r\n+-FUNC(12, MAKE12)\r\n+-\r\n+-int crypto_stream_aes256ctr(\r\n+-unsigned char *out,\r\n+-unsigned long long outlen,\r\n+-const unsigned char *n,\r\n+-const unsigned char *k\r\n+-)\r\n+-{\r\n+-  __m128 rkeys[16];\r\n+-  ALIGN16 unsigned char n2[16];\r\n+-  unsigned long long i, j;\r\n+-  aesni_key256_expand(k, rkeys);\r\n+-  /* n2 is in byte-reversed (i.e., native little endian)\r\n+-     order to make increment/testing easier */\r\n+-  (*(unsigned long long*)&n2[8]) = _bswap64((*(unsigned long long*)&n[8]));\r\n+-  (*(unsigned long long*)&n2[0]) = _bswap64((*(unsigned long long*)&n[0]));\r\n+-  \r\n+-#define LOOP(iter)                                       \\\r\n+-  int lb = iter * 16;                                    \\\r\n+-  for (i = 0 ; i < outlen ; i+= lb) {                    \\\r\n+-    ALIGN16 unsigned char outni[lb];       \\\r\n+-    aesni_encrypt##iter(outni, n2, (__m128i*)rkeys);     \\\r\n+-    unsigned long long mj = lb;                          \\\r\n+-    if ((i+mj)>=outlen)                                  \\\r\n+-      mj = outlen-i;                                     \\\r\n+-    for (j = 0 ; j < mj ; j++)                           \\\r\n+-      out[i+j] = outni[j];                               \\\r\n+-  }\r\n+-  \r\n+-  LOOP(8);\r\n+-\r\n+-  return 0;\r\n+-}\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+index 9be2881..f694dc9 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+@@ -1,6 +1,6 @@\n+ #ifndef CRYPTO_STREAM_AES256CTR_H\r\n+ #define CRYPTO_STREAM_AES256CTR_H\r\n+ \r\n+-int crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n++int OQS_crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+index 0b56a2b..0c0b1db 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+@@ -4,9 +4,9 @@\n+ \t.text\n+ .LHOTB11:\n+ \t.p2align 4,,15\n+-\t.globl\tcrypto_stream_aes256ctr\n+-\t.type\tcrypto_stream_aes256ctr, @function\n+-crypto_stream_aes256ctr:\n++\t.globl\tOQS_crypto_stream_aes256ctr\n++\t.type\tOQS_crypto_stream_aes256ctr, @function\n++OQS_crypto_stream_aes256ctr:\n+ .LFB2248:\n+ \t.cfi_startproc\n+ \tpushq\t%rbp\n+@@ -328,7 +328,7 @@ crypto_stream_aes256ctr:\n+ \tret\n+ \t.cfi_endproc\n+ .LFE2248:\n+-\t.size\tcrypto_stream_aes256ctr, .-crypto_stream_aes256ctr\n++\t.size\tOQS_crypto_stream_aes256ctr, .-OQS_crypto_stream_aes256ctr\n+ \t.section\t.text.unlikely\n+ .LCOLDE11:\n+ \t.text\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+index a3ffee1..d4e511b 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+@@ -1,10 +1,10 @@\n+ #include \"crypto_stream_chacha20.h\"\n+ #include <stddef.h>\n+ \n+-extern void chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n++extern void OQS_chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n+ \n+-int crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k) \n++int OQS_crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k)\n+ {\n+-\tchacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n++\tOQS_chacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n+ \treturn 0;\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.c b/src/kex_rlwe_newhope/avx2/error_correction.c\n+index 0970e6f..eaf2952 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.c\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.c\n+@@ -3,7 +3,7 @@\n+ \n+ //See paper for details on the error reconciliation\n+ \n+-extern void hr(poly *c, const poly *v, unsigned char rand[32]);\n++extern void OQS_hr(poly *c, const poly *v, unsigned char rand[32]);\n+ \n+ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce)\n+ {\n+@@ -17,5 +17,5 @@ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char no\n+ \n+   crypto_stream(rand,32,n,seed);\n+ \n+-  hr(c, v, rand);\n++  OQS_hr(c, v, rand);\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.h b/src/kex_rlwe_newhope/avx2/error_correction.h\n+index 488c105..c0e913d 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.h\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.h\n+@@ -9,7 +9,7 @@\n+ #include \"poly.h\"\n+ #include <stdio.h>\n+ \n+-void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n+-void rec(unsigned char *key, const poly *v, const poly *c);\n++static void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n++void OQS_rec(unsigned char *key, const poly *v, const poly *c);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.c b/src/kex_rlwe_newhope/avx2/fips202.c\n+index f649a7d..b83029c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.c\n++++ b/src/kex_rlwe_newhope/avx2/fips202.c\n+@@ -60,7 +60,7 @@ static const uint64_t KeccakF_RoundConstants[NROUNDS] =\n+     (uint64_t)0x8000000080008008ULL\n+ };\n+ \n+-void KeccakF1600_StatePermute(uint64_t * state)\n++static void KeccakF1600_StatePermute(uint64_t * state)\n+ {\n+   int round;\n+ \n+@@ -381,19 +381,19 @@ static void keccak_squeezeblocks(unsigned char *h, unsigned long long int nblock\n+ }\n+ \n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   keccak_absorb(s, SHAKE128_RATE, input, inputByteLen, 0x1F);\n+ }\n+ \n+ \n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n+ {\n+   keccak_squeezeblocks(output, nblocks, s, SHAKE128_RATE);\n+ }\n+ \n+ \n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   assert(!(outputByteLen%SHAKE128_RATE));\n+@@ -402,7 +402,7 @@ void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned\n+ }\n+ \n+ \n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   unsigned char t[SHA3_256_RATE];\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.h b/src/kex_rlwe_newhope/avx2/fips202.h\n+index b564434..d02ec7c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.h\n++++ b/src/kex_rlwe_newhope/avx2/fips202.h\n+@@ -4,9 +4,9 @@\n+ #define SHAKE128_RATE 168\n+ #define SHA3_256_RATE 136\n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/hr.s b/src/kex_rlwe_newhope/avx2/hr.s\n+index beb93fe..7eac399 100644\n+--- a/src/kex_rlwe_newhope/avx2/hr.s\n++++ b/src/kex_rlwe_newhope/avx2/hr.s\n+@@ -81,10 +81,10 @@\n+ \n+ # qhasm: enter hr\n+ .p2align 5\n+-.global _hr\n+-.global hr\n+-_hr:\n+-hr:\n++.global OQS_hr\n++.global OQS_hr\n++OQS_hr:\n++OQS_hr:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/newhope.c b/src/kex_rlwe_newhope/avx2/newhope.c\n+index b9f7a6c..f0c5ad9 100644\n+--- a/src/kex_rlwe_newhope/avx2/newhope.c\n++++ b/src/kex_rlwe_newhope/avx2/newhope.c\n+@@ -1,7 +1,5 @@\n+-#include \"poly.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"error_correction.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"poly.c\"\r\n++#include \"error_correction.c\"\r\n+ \r\n+ static void encode_a(unsigned char *r, const poly *pk, const unsigned char *seed)\r\n+ {\r\n+@@ -48,7 +46,7 @@ static void gen_a(poly *a, const unsigned char *seed)\n+ \r\n+ // API FUNCTIONS \r\n+ \r\n+-void newhope_keygen(unsigned char *send, poly *sk)\r\n++static void newhope_keygen(unsigned char *send, poly *sk)\r\n+ {\r\n+   poly a, e, r, pk;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -66,14 +64,14 @@ void newhope_keygen(unsigned char *send, poly *sk)\n+   poly_getnoise(&e,noiseseed,1);\r\n+   poly_ntt(&e);\r\n+ \r\n+-  poly_pointwise(&r,sk,&a);\r\n++  OQS_poly_pointwise(&r,sk,&a);\r\n+   poly_add(&pk,&e,&r);\r\n+ \r\n+   encode_a(send, &pk, seed);\r\n+ }\r\n+ \r\n+ \r\n+-void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n++static void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n+ {\r\n+   poly sp, ep, v, a, pka, c, epp, bp;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -89,10 +87,10 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+   poly_getnoise(&ep,noiseseed,1);\r\n+   poly_ntt(&ep);\r\n+ \r\n+-  poly_pointwise(&bp, &a, &sp);\r\n++  OQS_poly_pointwise(&bp, &a, &sp);\r\n+   poly_add(&bp, &bp, &ep);\r\n+   \r\n+-  poly_pointwise(&v, &pka, &sp);\r\n++  OQS_poly_pointwise(&v, &pka, &sp);\r\n+   poly_invntt(&v);\r\n+ \r\n+   poly_getnoise(&epp,noiseseed,2);\r\n+@@ -102,7 +100,7 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ \r\n+   encode_b(send, &bp, &c);\r\n+   \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32);\r\n+@@ -110,16 +108,16 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ }\r\n+ \r\n+ \r\n+-void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n++static void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n+ {\r\n+   poly v,bp, c;\r\n+ \r\n+   decode_b(&bp, &c, received);\r\n+ \r\n+-  poly_pointwise(&v,sk,&bp);\r\n++  OQS_poly_pointwise(&v,sk,&bp);\r\n+   poly_invntt(&v);\r\n+  \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32); \r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt.h b/src/kex_rlwe_newhope/avx2/ntt.h\n+index c24b137..1cb540a 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt.h\n++++ b/src/kex_rlwe_newhope/avx2/ntt.h\n+@@ -8,8 +8,8 @@ extern int32_t psis_inv[];\n+ extern double omegas_double[];\r\n+ extern double omegas_inv_double[];\r\n+ \r\n+-void bitrev_vector(int32_t* poly);\r\n+-void pwmul_double(int32_t* poly, const int32_t* factors);\r\n+-void ntt_double(int32_t*,const double*,const double*);\r\n++void OQS_bitrev_vector(int32_t* poly);\r\n++void OQS_pwmul_double(int32_t* poly, const int32_t* factors);\r\n++void OQS_ntt_double(int32_t*,const double*,const double*);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt_double.s b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+index 1ec429f..d876550 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt_double.s\n++++ b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+@@ -76,9 +76,9 @@\n+ # qhasm: enter ntt_double\n+ .p2align 5\n+ .global _ntt_double\n+-.global ntt_double\n++.global OQS_ntt_double\n+ _ntt_double:\n+-ntt_double:\n++OQS_ntt_double:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/poly.c b/src/kex_rlwe_newhope/avx2/poly.c\n+index 43c0df2..44b0956 100644\n+--- a/src/kex_rlwe_newhope/avx2/poly.c\n++++ b/src/kex_rlwe_newhope/avx2/poly.c\n+@@ -1,7 +1,7 @@\n+ #include \"poly.h\"\r\n+ #include \"ntt.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"randombytes.c\"\r\n++#include \"fips202.c\"\r\n+ #include \"crypto_stream.h\"\r\n+ \r\n+ static uint16_t barrett_reduce(uint16_t a)\r\n+@@ -14,7 +14,7 @@ static uint16_t barrett_reduce(uint16_t a)\n+   return a;\r\n+ }\r\n+ \r\n+-void poly_frombytes(poly *r, const unsigned char *a)\r\n++static void poly_frombytes(poly *r, const unsigned char *a)\r\n+ {\r\n+   int i;\r\n+   for(i=0;i<PARAM_N/4;i++)\r\n+@@ -26,7 +26,7 @@ void poly_frombytes(poly *r, const unsigned char *a)\n+   }\r\n+ }\r\n+ \r\n+-void poly_tobytes(unsigned char *r, const poly *p)\r\n++static void poly_tobytes(unsigned char *r, const poly *p)\r\n+ {\r\n+   int i;\r\n+   uint16_t t0,t1,t2,t3,m;\r\n+@@ -70,7 +70,7 @@ void poly_tobytes(unsigned char *r, const poly *p)\n+ \r\n+ \r\n+ \r\n+-void poly_uniform(poly *a, const unsigned char *seed)\r\n++static void poly_uniform(poly *a, const unsigned char *seed)\r\n+ {\r\n+   unsigned int pos=0, ctr=0;\r\n+   uint16_t val;\r\n+@@ -99,9 +99,9 @@ void poly_uniform(poly *a, const unsigned char *seed)\n+ }\r\n+ \r\n+ \r\n+-extern void cbd(poly *r, unsigned char *b);\r\n++extern void OQS_cbd(poly *r, unsigned char *b);\r","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":940,"original_position":940,"commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"tlepoint","id":1345502,"avatar_url":"https://avatars3.githubusercontent.com/u/1345502?v=4","gravatar_id":"","url":"https://api.github.com/users/tlepoint","html_url":"https://github.com/tlepoint","followers_url":"https://api.github.com/users/tlepoint/followers","following_url":"https://api.github.com/users/tlepoint/following{/other_user}","gists_url":"https://api.github.com/users/tlepoint/gists{/gist_id}","starred_url":"https://api.github.com/users/tlepoint/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlepoint/subscriptions","organizations_url":"https://api.github.com/users/tlepoint/orgs","repos_url":"https://api.github.com/users/tlepoint/repos","events_url":"https://api.github.com/users/tlepoint/events{/privacy}","received_events_url":"https://api.github.com/users/tlepoint/received_events","type":"User","site_admin":false},"body":"Oh, is it because it is in assembly?","created_at":"2017-10-16T13:12:43Z","updated_at":"2017-10-16T13:12:43Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144841960","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144841960"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144841960"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144841854},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T13:12:43Z","closed_at":null,"merged_at":null,"merge_commit_sha":"5ee0ddb658666f8e218f74d7296cf00815f6e2dd","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T13:12:43Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6721831268","type":"PullRequestReviewCommentEvent","actor":{"id":1345502,"login":"tlepoint","display_login":"tlepoint","gravatar_id":"","url":"https://api.github.com/users/tlepoint","avatar_url":"https://avatars.githubusercontent.com/u/1345502?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144842560","pull_request_review_id":69555197,"id":144842560,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":28,"original_position":28,"commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"tlepoint","id":1345502,"avatar_url":"https://avatars3.githubusercontent.com/u/1345502?v=4","gravatar_id":"","url":"https://api.github.com/users/tlepoint","html_url":"https://github.com/tlepoint","followers_url":"https://api.github.com/users/tlepoint/followers","following_url":"https://api.github.com/users/tlepoint/following{/other_user}","gists_url":"https://api.github.com/users/tlepoint/gists{/gist_id}","starred_url":"https://api.github.com/users/tlepoint/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlepoint/subscriptions","organizations_url":"https://api.github.com/users/tlepoint/orgs","repos_url":"https://api.github.com/users/tlepoint/repos","events_url":"https://api.github.com/users/tlepoint/events{/privacy}","received_events_url":"https://api.github.com/users/tlepoint/received_events","type":"User","site_admin":false},"body":"I meant, should these two files be in the patch?","created_at":"2017-10-16T13:15:06Z","updated_at":"2017-10-16T13:15:06Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144842560","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144842560"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144842560"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144732841},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T13:15:06Z","closed_at":null,"merged_at":null,"merge_commit_sha":"5ee0ddb658666f8e218f74d7296cf00815f6e2dd","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T13:15:06Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6721833371","type":"PullRequestReviewCommentEvent","actor":{"id":1345502,"login":"tlepoint","display_login":"tlepoint","gravatar_id":"","url":"https://api.github.com/users/tlepoint","avatar_url":"https://avatars.githubusercontent.com/u/1345502?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144842649","pull_request_review_id":69555317,"id":144842649,"diff_hunk":"@@ -0,0 +1,18 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/Makefile.am b/src/kex_rlwe_newhope/avx2/Makefile.am\n+new file mode 100644\n+index 0000000..baced33\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/Makefile.am","path":"patches/kex_rlwe_newhope_avx2/patch0.patch","position":5,"original_position":5,"commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"tlepoint","id":1345502,"avatar_url":"https://avatars3.githubusercontent.com/u/1345502?v=4","gravatar_id":"","url":"https://api.github.com/users/tlepoint","html_url":"https://github.com/tlepoint","followers_url":"https://api.github.com/users/tlepoint/followers","following_url":"https://api.github.com/users/tlepoint/following{/other_user}","gists_url":"https://api.github.com/users/tlepoint/gists{/gist_id}","starred_url":"https://api.github.com/users/tlepoint/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlepoint/subscriptions","organizations_url":"https://api.github.com/users/tlepoint/orgs","repos_url":"https://api.github.com/users/tlepoint/repos","events_url":"https://api.github.com/users/tlepoint/events{/privacy}","received_events_url":"https://api.github.com/users/tlepoint/received_events","type":"User","site_admin":false},"body":"Same here, should that be in the patch?","created_at":"2017-10-16T13:15:31Z","updated_at":"2017-10-16T13:15:31Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144842649","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144842649"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144842649"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}}},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T13:15:31Z","closed_at":null,"merged_at":null,"merge_commit_sha":"5ee0ddb658666f8e218f74d7296cf00815f6e2dd","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T12:41:37Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/e351f52c441344abb465b4303dc1bb06bc622423"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T13:15:31Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6722801568","type":"PullRequestReviewCommentEvent","actor":{"id":32465481,"login":"s24mishra","display_login":"s24mishra","gravatar_id":"","url":"https://api.github.com/users/s24mishra","avatar_url":"https://avatars.githubusercontent.com/u/32465481?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144894707","pull_request_review_id":69615734,"id":144894707,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":28,"original_position":28,"commit_id":"206d69c26fd34855adb111b05c2d9c27290aae80","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"s24mishra","id":32465481,"avatar_url":"https://avatars3.githubusercontent.com/u/32465481?v=4","gravatar_id":"","url":"https://api.github.com/users/s24mishra","html_url":"https://github.com/s24mishra","followers_url":"https://api.github.com/users/s24mishra/followers","following_url":"https://api.github.com/users/s24mishra/following{/other_user}","gists_url":"https://api.github.com/users/s24mishra/gists{/gist_id}","starred_url":"https://api.github.com/users/s24mishra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s24mishra/subscriptions","organizations_url":"https://api.github.com/users/s24mishra/orgs","repos_url":"https://api.github.com/users/s24mishra/repos","events_url":"https://api.github.com/users/s24mishra/events{/privacy}","received_events_url":"https://api.github.com/users/s24mishra/received_events","type":"User","site_admin":false},"body":"Removed the binary files from under test directory.\r\nAll the files and changes in the patch should be there because the aim is to keep the external original code untouched as much as possible. ","created_at":"2017-10-16T16:16:24Z","updated_at":"2017-10-16T16:16:24Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144894707","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144894707"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144894707"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144732841},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T16:16:24Z","closed_at":null,"merged_at":null,"merge_commit_sha":"60ca9f2a04acb7ac59560a4e1d1d0cf5c638d841","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"206d69c26fd34855adb111b05c2d9c27290aae80","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T16:16:24Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6722807509","type":"PullRequestReviewCommentEvent","actor":{"id":32465481,"login":"s24mishra","display_login":"s24mishra","gravatar_id":"","url":"https://api.github.com/users/s24mishra","avatar_url":"https://avatars.githubusercontent.com/u/32465481?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895071","pull_request_review_id":69616088,"id":144895071,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {\n++\tOQS_KEX *k = malloc(sizeof(OQS_KEX));\n++\tif (k == NULL) {\n++\t\treturn NULL;\n++\t}\n++\tk->method_name = strdup(\"RLWE NewHope AVX2\");\n++\tk->estimated_classical_security = 229; // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known classical\n++\tk->estimated_quantum_security = 206;   // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known quantum\n++\tk->seed = NULL;\n++\tk->seed_len = 0;\n++\tk->named_parameters = 0;\n++\tk->rand = rand;\n++\tk->params = NULL;\n++\tk->alice_0 = &OQS_KEX_rlwe_newhope_avx2_alice_0;\n++\tk->bob = &OQS_KEX_rlwe_newhope_avx2_bob;\n++\tk->alice_1 = &OQS_KEX_rlwe_newhope_avx2_alice_1;\n++\tk->alice_priv_free = &OQS_KEX_rlwe_newhope_avx2_alice_priv_free;\n++\tk->free = &OQS_KEX_rlwe_newhope_avx2_free;\n++\treturn k;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(UNUSED OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len) {\n++\n++\tint ret;\n++\n++\t/* allocate public/private key pair */\n++\t*alice_msg = malloc(NEWHOPE_SENDABYTES);\n++\tif (*alice_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*alice_priv = malloc(sizeof(poly));\n++\tif (*alice_priv == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate public/private key pair */\n++\tnewhope_keygen(*alice_msg, (poly *) (*alice_priv));\n++\t*alice_msg_len = NEWHOPE_SENDABYTES;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*alice_msg);\n++\t*alice_msg = NULL;\n++\tfree(*alice_priv);\n++\t*alice_priv = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_bob(UNUSED OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (alice_msg_len != NEWHOPE_SENDABYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate message and session key */\n++\t*bob_msg = malloc(NEWHOPE_SENDBBYTES);\n++\tif (*bob_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Bob's response */\n++\tnewhope_sharedb(*key, *bob_msg, alice_msg);\n++\t*bob_msg_len = NEWHOPE_SENDBBYTES;\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*bob_msg);\n++\t*bob_msg = NULL;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(UNUSED OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (bob_msg_len != NEWHOPE_SENDBBYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate session key */\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Alice's session key */\n++\tnewhope_shareda(*key, (poly *) alice_priv, bob_msg);\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(UNUSED OQS_KEX *k, void *alice_priv) {\n++\tif (alice_priv) {\n++\t\tfree(alice_priv);\n++\t}\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k) {\n++\tif (k) {\n++\t\tfree(k->named_parameters);\n++\t\tk->named_parameters = NULL;\n++\t\tfree(k->method_name);\n++\t\tk->method_name = NULL;\n++\t}\n++\tfree(k);\n++}\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+new file mode 100644\n+index 0000000..6ab8921\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+@@ -0,0 +1,24 @@\n++/**\n++ * \\file kex_rlwe_newhope.h\n++ * \\brief Header for ring-LWE key exchange protocol NewHope\n++ */\n++\n++#ifndef __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++#define __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++\n++#include <stddef.h>\n++#include <stdint.h>\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand);\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len);\n++int OQS_KEX_rlwe_newhope_avx2_bob(OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len);\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len);\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(OQS_KEX *k, void *alice_priv);\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k);\n++\n++#endif\n+diff --git a/src/kex_rlwe_newhope/avx2/bitrev.s b/src/kex_rlwe_newhope/avx2/bitrev.s\n+index 002a1ee..faff35f 100644\n+--- a/src/kex_rlwe_newhope/avx2/bitrev.s\n++++ b/src/kex_rlwe_newhope/avx2/bitrev.s\n+@@ -37,10 +37,10 @@\n+ \n+ # qhasm: enter bitrev_vector\n+ .p2align 5\n+-.global _bitrev_vector\n+-.global bitrev_vector\n+-_bitrev_vector:\n+-bitrev_vector:\n++.global OQS_bitrev_vector\n++.global OQS_bitrev_vector\n++OQS_bitrev_vector:\n++OQS_bitrev_vector:\n+ movq %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/cbd.s b/src/kex_rlwe_newhope/avx2/cbd.s\n+index 7619a31..f2be41b 100644\n+--- a/src/kex_rlwe_newhope/avx2/cbd.s\n++++ b/src/kex_rlwe_newhope/avx2/cbd.s\n+@@ -59,10 +59,10 @@\n+ \n+ # qhasm: enter cbd\n+ .p2align 5\n+-.global _cbd\n+-.global cbd\n+-_cbd:\n+-cbd:\n++.global OQS_cbd\n++.global OQS_cbd\n++OQS_cbd:\n++OQS_cbd:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/chacha.S b/src/kex_rlwe_newhope/avx2/chacha.S\n+index 4597b5a..9a79f72 100644\n+--- a/src/kex_rlwe_newhope/avx2/chacha.S\n++++ b/src/kex_rlwe_newhope/avx2/chacha.S\n+@@ -18,14 +18,14 @@\n+ \r\n+ .text\r\n+ \r\n+-GLOBAL(chacha)\r\n+-GLOBAL(xchacha)\r\n+-GLOBAL(hchacha)\r\n+-GLOBAL(chacha_blocks)\r\n++GLOBAL(OQS_chacha)\r\n++GLOBAL(OQS_xchacha)\r\n++GLOBAL(OQS_hchacha)\r\n++GLOBAL(OQS_chacha_blocks)\r\n+ \r\n+ /* Windows 64 calling convention fixups */\r\n+ #if defined(_WIN64) || defined(__CYGWIN64__)\r\n+-FN(chacha)\r\n++FN(OQS_chacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -60,9 +60,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha)\r\n++ENDFN(OQS_chacha)\r\n+ \r\n+-FN(xchacha)\r\n++FN(OQS_xchacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -97,9 +97,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(xchacha)\r\n++ENDFN(OQS_xchacha)\r\n+ \r\n+-FN(chacha_blocks)\r\n++FN(OQS_chacha_blocks)\r\n+ subq $184, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movdqa %xmm7, 16(%rsp)\r\n+@@ -132,9 +132,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha_blocks)\r\n++ENDFN(OQS_chacha_blocks)\r\n+ \r\n+-FN(hchacha)\r\n++FN(OQS_hchacha)\r\n+ subq $40, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movq %rdi, 16(%rsp)\r\n+@@ -149,7 +149,7 @@ movq 16(%rsp), %rdi\n+ movq 24(%rsp), %rsi\r\n+ addq $40, %rsp\r\n+ ret\r\n+-ENDFN(hchacha)\r\n++ENDFN(OQS_hchacha)\r\n+ \r\n+ #define chacha chacha_thunk\r\n+ #define xchacha xchacha_thunk\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+index 48159c2..b0a84c6 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+@@ -217,7 +217,7 @@ static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned cha\n+   return inlen;\n+ }\n+ \n+-static const char iv[32] = {\n++static const unsigned iv[32] = {\n+   0x6a,0x09,0xe6,0x67,\n+   0xbb,0x67,0xae,0x85,\n+   0x3c,0x6e,0xf3,0x72,\n+@@ -228,7 +228,7 @@ static const char iv[32] = {\n+   0x5b,0xe0,0xcd,0x19,\n+ } ;\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n+ {\n+   unsigned char h[32];\n+   unsigned char padded[128];\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+index 4717f09..800ab4c 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+@@ -1,9 +1,9 @@\n+ #ifndef CRYPTO_HASH_SHA256_H\n+ #define CRYPTO_HASH_SHA256_H\n+ \n+-int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);static\n+ \n+ #define crypto_hash_sha256_BYTES 32\n+ \n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream.h b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+index aab8052..2053382 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+@@ -5,12 +5,12 @@\n+   #include \"crypto_stream_chacha20.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 8\n+-  #define crypto_stream crypto_stream_chacha20\n++  #define crypto_stream OQS_crypto_stream_chacha20\n+ #else\n+   #include \"crypto_stream_aes256ctr.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 16\n+-  #define crypto_stream crypto_stream_aes256ctr\n++  #define crypto_stream OQS_crypto_stream_aes256ctr\n+ #endif\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n+deleted file mode 100644\n+index 3b74551..0000000\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n++++ /dev/null\n+@@ -1,242 +0,0 @@\n+-/*\r\n+-  aesenc-int.c version $Date: 2014/08/22 16:49:12 $\r\n+-  AES-CTR\r\n+-  Romain Dolbeau\r\n+-  Public Domain\r\n+-*/\r\n+-\r\n+-#include <stdio.h>\r\n+-#include <stdlib.h>\r\n+-#include <string.h>\r\n+-#include <immintrin.h>\r\n+-#include \"crypto_stream_aes256ctr.h\"\r\n+-\r\n+-#ifdef __INTEL_COMPILER\r\n+-#define ALIGN16 __declspec(align(16))\r\n+-#define ALIGN32 __declspec(align(32))\r\n+-#define ALIGN64 __declspec(align(64))\r\n+-#else // assume GCC\r\n+-#define ALIGN16  __attribute__((aligned(16)))\r\n+-#define ALIGN32  __attribute__((aligned(32)))\r\n+-#define ALIGN64  __attribute__((aligned(64)))\r\n+-#define _bswap64(a) __builtin_bswap64(a)\r\n+-#define _bswap(a) __builtin_bswap(a)\r\n+-#endif\r\n+-\r\n+-static inline void aesni_key256_expand(const unsigned char* key, __m128 rkeys[16]) {\r\n+-  __m128 key0 = _mm_loadu_ps((const float *)(key+0));\r\n+-  __m128 key1 = _mm_loadu_ps((const float *)(key+16));\r\n+-  __m128 temp0, temp1, temp2, temp4;\r\n+-  int idx = 0;\r\n+-\r\n+-  rkeys[idx++] = key0;\r\n+-  temp0 = key0;\r\n+-  temp2 = key1;\r\n+-  temp4 = _mm_setzero_ps();\r\n+-\r\n+-  /* why single precision floating-point rather than integer instructions ?\r\n+-     because _mm_shuffle_ps takes two inputs, while _mm_shuffle_epi32 only\r\n+-     takes one - it doesn't perform the same computation...\r\n+-     _mm_shuffle_ps takes the lower 64 bits of the result from the first\r\n+-     operand, and the higher 64 bits of the result from the second operand\r\n+-     (in both cases, all four input floats are accessible).\r\n+-     I don't like the non-orthogonal naming scheme :-(\r\n+-     \r\n+-     This is all strongly inspired by the openssl assembly code.\r\n+-  */\r\n+-#define BLOCK1(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp2, IMM);       \\\r\n+-  rkeys[idx++] = temp2;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x10);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x8c);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xff);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp1)\r\n+-  \r\n+-#define BLOCK2(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp0, IMM);       \\\r\n+-  rkeys[idx++] = temp0;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x10);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x8c);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xaa);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp1)\r\n+-  \r\n+-  BLOCK1(0x01);\r\n+-  BLOCK2(0x01);\r\n+-\r\n+-  BLOCK1(0x02);\r\n+-  BLOCK2(0x02);\r\n+-\r\n+-  BLOCK1(0x04);\r\n+-  BLOCK2(0x04);\r\n+-\r\n+-  BLOCK1(0x08);\r\n+-  BLOCK2(0x08);\r\n+-\r\n+-  BLOCK1(0x10);\r\n+-  BLOCK2(0x10);\r\n+-\r\n+-  BLOCK1(0x20);\r\n+-  BLOCK2(0x20);\r\n+-\r\n+-  BLOCK1(0x40);\r\n+-  rkeys[idx++] = temp0;\r\n+-}\r\n+-\r\n+-/** single, by-the-book AES encryption with AES-NI */\r\n+-static inline void aesni_encrypt1(unsigned char *out, unsigned char *n, __m128i rkeys[16]) {\r\n+-  __m128i nv = _mm_load_si128((const __m128i *)n);\r\n+-  int i;\r\n+-  __m128i temp = _mm_xor_si128(nv, rkeys[0]);\r\n+-#pragma unroll(13)\r\n+-  for (i = 1 ; i < 14 ; i++) {\r\n+-    temp = _mm_aesenc_si128(temp, rkeys[i]);\r\n+-  }\r\n+-  temp = _mm_aesenclast_si128(temp, rkeys[14]);\r\n+-  _mm_store_si128((__m128i*)(out), temp);\r\n+-}\r\n+-\r\n+-/** increment the 16-bytes nonce ;\r\n+-    this really should be improved somehow...\r\n+-    but it's not yet time-critical, because we\r\n+-    use the vector variant anyway  */\r\n+-static inline void incle(unsigned char n[16]) {\r\n+-/*   unsigned long long out; */\r\n+-/*   unsigned char carry; */\r\n+-  unsigned long long *n_ = (unsigned long long*)n;\r\n+-  n_[1]++;\r\n+-  if (n_[1] == 0)\r\n+-    n_[0] ++;\r\n+-  /* perhaps this will be efficient on broadwell ? */\r\n+-  /*   carry = _addcarry_u64(0, n_[1], 1ULL, &out); */\r\n+-  /*   carry = _addcarry_u64(carry, n_[0], 0ULL, &out); */\r\n+-}\r\n+-\r\n+-/** multiple-blocks-at-once AES encryption with AES-NI ;\r\n+-    on Haswell, aesenc as a latency of 7 and a througput of 1\r\n+-    so the sequence of aesenc should be bubble-free, if you\r\n+-    have at least 8 blocks. Let's build an arbitratry-sized\r\n+-    function */\r\n+-/* Step 1 : loading the nonce */\r\n+-/* load & increment the n vector (non-vectorized, unused for now) */\r\n+-#define NVx(a)                                                  \\\r\n+-  __m128i nv##a = _mm_shuffle_epi8(_mm_load_si128((const __m128i *)n), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7)); incle(n)\r\n+-/* load the incremented n vector (vectorized, probably buggy) */\r\n+-#define NVxV_DEC(a)                                                     \\\r\n+-  __m128i nv##a;\r\n+-#define NVxV_NOWRAP(a)                                                  \\\r\n+-  nv##a = _mm_shuffle_epi8(_mm_add_epi64(nv0i, _mm_set_epi64x(a,0)), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-#define NVxV_WRAP(a)                                                    \\\r\n+-  __m128i ad##a = _mm_add_epi64(nv0i, _mm_set_epi64x(a,a>=wrapnumber?1:0)); \\\r\n+-  nv##a = _mm_shuffle_epi8(ad##a, _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-\r\n+-/* Step 2 : define value in round one (xor with subkey #0, aka key) */\r\n+-#define TEMPx(a)                                        \\\r\n+-  __m128i temp##a = _mm_xor_si128(nv##a, rkeys[0])\r\n+-\r\n+-/* Step 3: one round of AES */\r\n+-#define AESENCx(a)                                      \\\r\n+-  temp##a =  _mm_aesenc_si128(temp##a, rkeys[i]);\r\n+-\r\n+-/* Step 4: last round of AES */\r\n+-#define AESENCLASTx(a)                                  \\\r\n+-  temp##a = _mm_aesenclast_si128(temp##a, rkeys[14]);\r\n+-\r\n+-/* Step 5: store result */\r\n+-#define STOREx(a)                                       \\\r\n+-  _mm_store_si128((__m128i*)(out+(a*16)), temp##a);\r\n+-\r\n+-/* all the MAKE* macros are for automatic explicit unrolling */\r\n+-#define MAKE4(X)                                \\\r\n+-  X(0);X(1);X(2);X(3)\r\n+-\r\n+-#define MAKE6(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5)\r\n+-\r\n+-#define MAKE7(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6)\r\n+-\r\n+-#define MAKE8(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7)\r\n+-\r\n+-#define MAKE10(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9)\r\n+-\r\n+-#define MAKE12(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9);X(10);X(11)\r\n+-\r\n+-/* create a function of unrolling N ; the MAKEN is the unrolling\r\n+-   macro, defined above. The N in MAKEN must match N, obviously. */\r\n+-#define FUNC(N, MAKEN)                          \\\r\n+-  static inline void aesni_encrypt##N(unsigned char *out, unsigned char *n, __m128i rkeys[16]) { \\\r\n+-    __m128i nv0i = _mm_load_si128((const __m128i *)n);                  \\\r\n+-    long long nl = *(long long*)&n[8];                                  \\\r\n+-    MAKEN(NVxV_DEC);                                                    \\\r\n+-    /* check for nonce wraparound */                                    \\\r\n+-    if ((nl < 0) && (nl + (N-1)) >= 0) {                                \\\r\n+-      int wrapnumber = (int)(N - (nl+N));                               \\\r\n+-      MAKEN(NVxV_WRAP);                                                 \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,1))); \\\r\n+-    } else {                                                            \\\r\n+-      MAKEN(NVxV_NOWRAP);                                               \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,0))); \\\r\n+-    }                                                                   \\\r\n+-    int i;                                                              \\\r\n+-    MAKEN(TEMPx);                                                       \\\r\n+-    for (i = 1 ; i < 14 ; i++) {                                        \\\r\n+-      MAKEN(AESENCx);                                                   \\\r\n+-    }                                                                   \\\r\n+-    MAKEN(AESENCLASTx);                                                 \\\r\n+-    MAKEN(STOREx);                                                      \\\r\n+-  }\r\n+-\r\n+-/* and now building our unrolled function is trivial */\r\n+-FUNC(4, MAKE4)\r\n+-FUNC(6, MAKE6)\r\n+-FUNC(7, MAKE7)\r\n+-FUNC(8, MAKE8)\r\n+-FUNC(10, MAKE10)\r\n+-FUNC(12, MAKE12)\r\n+-\r\n+-int crypto_stream_aes256ctr(\r\n+-unsigned char *out,\r\n+-unsigned long long outlen,\r\n+-const unsigned char *n,\r\n+-const unsigned char *k\r\n+-)\r\n+-{\r\n+-  __m128 rkeys[16];\r\n+-  ALIGN16 unsigned char n2[16];\r\n+-  unsigned long long i, j;\r\n+-  aesni_key256_expand(k, rkeys);\r\n+-  /* n2 is in byte-reversed (i.e., native little endian)\r\n+-     order to make increment/testing easier */\r\n+-  (*(unsigned long long*)&n2[8]) = _bswap64((*(unsigned long long*)&n[8]));\r\n+-  (*(unsigned long long*)&n2[0]) = _bswap64((*(unsigned long long*)&n[0]));\r\n+-  \r\n+-#define LOOP(iter)                                       \\\r\n+-  int lb = iter * 16;                                    \\\r\n+-  for (i = 0 ; i < outlen ; i+= lb) {                    \\\r\n+-    ALIGN16 unsigned char outni[lb];       \\\r\n+-    aesni_encrypt##iter(outni, n2, (__m128i*)rkeys);     \\\r\n+-    unsigned long long mj = lb;                          \\\r\n+-    if ((i+mj)>=outlen)                                  \\\r\n+-      mj = outlen-i;                                     \\\r\n+-    for (j = 0 ; j < mj ; j++)                           \\\r\n+-      out[i+j] = outni[j];                               \\\r\n+-  }\r\n+-  \r\n+-  LOOP(8);\r\n+-\r\n+-  return 0;\r\n+-}\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+index 9be2881..f694dc9 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+@@ -1,6 +1,6 @@\n+ #ifndef CRYPTO_STREAM_AES256CTR_H\r\n+ #define CRYPTO_STREAM_AES256CTR_H\r\n+ \r\n+-int crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n++int OQS_crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+index 0b56a2b..0c0b1db 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+@@ -4,9 +4,9 @@\n+ \t.text\n+ .LHOTB11:\n+ \t.p2align 4,,15\n+-\t.globl\tcrypto_stream_aes256ctr\n+-\t.type\tcrypto_stream_aes256ctr, @function\n+-crypto_stream_aes256ctr:\n++\t.globl\tOQS_crypto_stream_aes256ctr\n++\t.type\tOQS_crypto_stream_aes256ctr, @function\n++OQS_crypto_stream_aes256ctr:\n+ .LFB2248:\n+ \t.cfi_startproc\n+ \tpushq\t%rbp\n+@@ -328,7 +328,7 @@ crypto_stream_aes256ctr:\n+ \tret\n+ \t.cfi_endproc\n+ .LFE2248:\n+-\t.size\tcrypto_stream_aes256ctr, .-crypto_stream_aes256ctr\n++\t.size\tOQS_crypto_stream_aes256ctr, .-OQS_crypto_stream_aes256ctr\n+ \t.section\t.text.unlikely\n+ .LCOLDE11:\n+ \t.text\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+index a3ffee1..d4e511b 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+@@ -1,10 +1,10 @@\n+ #include \"crypto_stream_chacha20.h\"\n+ #include <stddef.h>\n+ \n+-extern void chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n++extern void OQS_chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n+ \n+-int crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k) \n++int OQS_crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k)\n+ {\n+-\tchacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n++\tOQS_chacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n+ \treturn 0;\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.c b/src/kex_rlwe_newhope/avx2/error_correction.c\n+index 0970e6f..eaf2952 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.c\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.c\n+@@ -3,7 +3,7 @@\n+ \n+ //See paper for details on the error reconciliation\n+ \n+-extern void hr(poly *c, const poly *v, unsigned char rand[32]);\n++extern void OQS_hr(poly *c, const poly *v, unsigned char rand[32]);\n+ \n+ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce)\n+ {\n+@@ -17,5 +17,5 @@ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char no\n+ \n+   crypto_stream(rand,32,n,seed);\n+ \n+-  hr(c, v, rand);\n++  OQS_hr(c, v, rand);\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.h b/src/kex_rlwe_newhope/avx2/error_correction.h\n+index 488c105..c0e913d 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.h\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.h\n+@@ -9,7 +9,7 @@\n+ #include \"poly.h\"\n+ #include <stdio.h>\n+ \n+-void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n+-void rec(unsigned char *key, const poly *v, const poly *c);\n++static void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n++void OQS_rec(unsigned char *key, const poly *v, const poly *c);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.c b/src/kex_rlwe_newhope/avx2/fips202.c\n+index f649a7d..b83029c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.c\n++++ b/src/kex_rlwe_newhope/avx2/fips202.c\n+@@ -60,7 +60,7 @@ static const uint64_t KeccakF_RoundConstants[NROUNDS] =\n+     (uint64_t)0x8000000080008008ULL\n+ };\n+ \n+-void KeccakF1600_StatePermute(uint64_t * state)\n++static void KeccakF1600_StatePermute(uint64_t * state)\n+ {\n+   int round;\n+ \n+@@ -381,19 +381,19 @@ static void keccak_squeezeblocks(unsigned char *h, unsigned long long int nblock\n+ }\n+ \n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   keccak_absorb(s, SHAKE128_RATE, input, inputByteLen, 0x1F);\n+ }\n+ \n+ \n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":723,"original_position":723,"commit_id":"206d69c26fd34855adb111b05c2d9c27290aae80","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"s24mishra","id":32465481,"avatar_url":"https://avatars3.githubusercontent.com/u/32465481?v=4","gravatar_id":"","url":"https://api.github.com/users/s24mishra","html_url":"https://github.com/s24mishra","followers_url":"https://api.github.com/users/s24mishra/followers","following_url":"https://api.github.com/users/s24mishra/following{/other_user}","gists_url":"https://api.github.com/users/s24mishra/gists{/gist_id}","starred_url":"https://api.github.com/users/s24mishra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s24mishra/subscriptions","organizations_url":"https://api.github.com/users/s24mishra/orgs","repos_url":"https://api.github.com/users/s24mishra/repos","events_url":"https://api.github.com/users/s24mishra/events{/privacy}","received_events_url":"https://api.github.com/users/s24mishra/received_events","type":"User","site_admin":false},"body":"All the function which are public and part of API and of course implemented in assembly have to be OQS_ prefixed.","created_at":"2017-10-16T16:17:36Z","updated_at":"2017-10-16T16:17:36Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895071","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895071"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895071"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144732799},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T16:17:36Z","closed_at":null,"merged_at":null,"merge_commit_sha":"60ca9f2a04acb7ac59560a4e1d1d0cf5c638d841","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"206d69c26fd34855adb111b05c2d9c27290aae80","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T16:17:36Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6722809274","type":"PullRequestReviewCommentEvent","actor":{"id":32465481,"login":"s24mishra","display_login":"s24mishra","gravatar_id":"","url":"https://api.github.com/users/s24mishra","avatar_url":"https://avatars.githubusercontent.com/u/32465481?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895171","pull_request_review_id":69616209,"id":144895171,"diff_hunk":"@@ -0,0 +1,1073 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+new file mode 100644\n+index 0000000..5e750c3\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.c\n+@@ -0,0 +1,159 @@\n++#if defined(WINDOWS)\n++#define UNUSED\n++// __attribute__ not supported in VS, is there something else I should define?\n++#else\n++#define UNUSED __attribute__((unused))\n++#endif\n++\n++#include <stdlib.h>\n++#include <string.h>\n++#if !defined(WINDOWS)\n++#include <strings.h>\n++#include <unistd.h>\n++#endif\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++#include \"kex_rlwe_newhope_avx2.h\"\n++#include \"newhope.c\"\n++#include \"params.h\"\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand) {\n++\tOQS_KEX *k = malloc(sizeof(OQS_KEX));\n++\tif (k == NULL) {\n++\t\treturn NULL;\n++\t}\n++\tk->method_name = strdup(\"RLWE NewHope AVX2\");\n++\tk->estimated_classical_security = 229; // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known classical\n++\tk->estimated_quantum_security = 206;   // http://eprint.iacr.org/2015/1092.pdf Table 1 NewHope dual known quantum\n++\tk->seed = NULL;\n++\tk->seed_len = 0;\n++\tk->named_parameters = 0;\n++\tk->rand = rand;\n++\tk->params = NULL;\n++\tk->alice_0 = &OQS_KEX_rlwe_newhope_avx2_alice_0;\n++\tk->bob = &OQS_KEX_rlwe_newhope_avx2_bob;\n++\tk->alice_1 = &OQS_KEX_rlwe_newhope_avx2_alice_1;\n++\tk->alice_priv_free = &OQS_KEX_rlwe_newhope_avx2_alice_priv_free;\n++\tk->free = &OQS_KEX_rlwe_newhope_avx2_free;\n++\treturn k;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(UNUSED OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len) {\n++\n++\tint ret;\n++\n++\t/* allocate public/private key pair */\n++\t*alice_msg = malloc(NEWHOPE_SENDABYTES);\n++\tif (*alice_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*alice_priv = malloc(sizeof(poly));\n++\tif (*alice_priv == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate public/private key pair */\n++\tnewhope_keygen(*alice_msg, (poly *) (*alice_priv));\n++\t*alice_msg_len = NEWHOPE_SENDABYTES;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*alice_msg);\n++\t*alice_msg = NULL;\n++\tfree(*alice_priv);\n++\t*alice_priv = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_bob(UNUSED OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (alice_msg_len != NEWHOPE_SENDABYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate message and session key */\n++\t*bob_msg = malloc(NEWHOPE_SENDBBYTES);\n++\tif (*bob_msg == NULL) {\n++\t\tgoto err;\n++\t}\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Bob's response */\n++\tnewhope_sharedb(*key, *bob_msg, alice_msg);\n++\t*bob_msg_len = NEWHOPE_SENDBBYTES;\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*bob_msg);\n++\t*bob_msg = NULL;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(UNUSED OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len) {\n++\n++\tint ret;\n++\n++\tif (bob_msg_len != NEWHOPE_SENDBBYTES) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* allocate session key */\n++\t*key = malloc(32);\n++\tif (*key == NULL) {\n++\t\tgoto err;\n++\t}\n++\n++\t/* generate Alice's session key */\n++\tnewhope_shareda(*key, (poly *) alice_priv, bob_msg);\n++\t*key_len = 32;\n++\n++\tret = 1;\n++\tgoto cleanup;\n++\n++err:\n++\tret = 0;\n++\tfree(*key);\n++\t*key = NULL;\n++\n++cleanup:\n++\n++\treturn ret;\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(UNUSED OQS_KEX *k, void *alice_priv) {\n++\tif (alice_priv) {\n++\t\tfree(alice_priv);\n++\t}\n++}\n++\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k) {\n++\tif (k) {\n++\t\tfree(k->named_parameters);\n++\t\tk->named_parameters = NULL;\n++\t\tfree(k->method_name);\n++\t\tk->method_name = NULL;\n++\t}\n++\tfree(k);\n++}\n+diff --git a/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+new file mode 100644\n+index 0000000..6ab8921\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/kex_rlwe_newhope_avx2.h\n+@@ -0,0 +1,24 @@\n++/**\n++ * \\file kex_rlwe_newhope.h\n++ * \\brief Header for ring-LWE key exchange protocol NewHope\n++ */\n++\n++#ifndef __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++#define __OQS_KEX_RLWE_NEWHOPE_AVX2_H\n++\n++#include <stddef.h>\n++#include <stdint.h>\n++\n++#include <oqs/kex.h>\n++#include <oqs/rand.h>\n++\n++OQS_KEX *OQS_KEX_rlwe_newhope_avx2_new(OQS_RAND *rand);\n++\n++int OQS_KEX_rlwe_newhope_avx2_alice_0(OQS_KEX *k, void **alice_priv, uint8_t **alice_msg, size_t *alice_msg_len);\n++int OQS_KEX_rlwe_newhope_avx2_bob(OQS_KEX *k, const uint8_t *alice_msg, const size_t alice_msg_len, uint8_t **bob_msg, size_t *bob_msg_len, uint8_t **key, size_t *key_len);\n++int OQS_KEX_rlwe_newhope_avx2_alice_1(OQS_KEX *k, const void *alice_priv, const uint8_t *bob_msg, const size_t bob_msg_len, uint8_t **key, size_t *key_len);\n++\n++void OQS_KEX_rlwe_newhope_avx2_alice_priv_free(OQS_KEX *k, void *alice_priv);\n++void OQS_KEX_rlwe_newhope_avx2_free(OQS_KEX *k);\n++\n++#endif\n+diff --git a/src/kex_rlwe_newhope/avx2/bitrev.s b/src/kex_rlwe_newhope/avx2/bitrev.s\n+index 002a1ee..faff35f 100644\n+--- a/src/kex_rlwe_newhope/avx2/bitrev.s\n++++ b/src/kex_rlwe_newhope/avx2/bitrev.s\n+@@ -37,10 +37,10 @@\n+ \n+ # qhasm: enter bitrev_vector\n+ .p2align 5\n+-.global _bitrev_vector\n+-.global bitrev_vector\n+-_bitrev_vector:\n+-bitrev_vector:\n++.global OQS_bitrev_vector\n++.global OQS_bitrev_vector\n++OQS_bitrev_vector:\n++OQS_bitrev_vector:\n+ movq %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/cbd.s b/src/kex_rlwe_newhope/avx2/cbd.s\n+index 7619a31..f2be41b 100644\n+--- a/src/kex_rlwe_newhope/avx2/cbd.s\n++++ b/src/kex_rlwe_newhope/avx2/cbd.s\n+@@ -59,10 +59,10 @@\n+ \n+ # qhasm: enter cbd\n+ .p2align 5\n+-.global _cbd\n+-.global cbd\n+-_cbd:\n+-cbd:\n++.global OQS_cbd\n++.global OQS_cbd\n++OQS_cbd:\n++OQS_cbd:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/chacha.S b/src/kex_rlwe_newhope/avx2/chacha.S\n+index 4597b5a..9a79f72 100644\n+--- a/src/kex_rlwe_newhope/avx2/chacha.S\n++++ b/src/kex_rlwe_newhope/avx2/chacha.S\n+@@ -18,14 +18,14 @@\n+ \r\n+ .text\r\n+ \r\n+-GLOBAL(chacha)\r\n+-GLOBAL(xchacha)\r\n+-GLOBAL(hchacha)\r\n+-GLOBAL(chacha_blocks)\r\n++GLOBAL(OQS_chacha)\r\n++GLOBAL(OQS_xchacha)\r\n++GLOBAL(OQS_hchacha)\r\n++GLOBAL(OQS_chacha_blocks)\r\n+ \r\n+ /* Windows 64 calling convention fixups */\r\n+ #if defined(_WIN64) || defined(__CYGWIN64__)\r\n+-FN(chacha)\r\n++FN(OQS_chacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -60,9 +60,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha)\r\n++ENDFN(OQS_chacha)\r\n+ \r\n+-FN(xchacha)\r\n++FN(OQS_xchacha)\r\n+ subq $184, %rsp\r\n+ vmovdqa %xmm6, 0(%rsp)\r\n+ vmovdqa %xmm7, 16(%rsp)\r\n+@@ -97,9 +97,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(xchacha)\r\n++ENDFN(OQS_xchacha)\r\n+ \r\n+-FN(chacha_blocks)\r\n++FN(OQS_chacha_blocks)\r\n+ subq $184, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movdqa %xmm7, 16(%rsp)\r\n+@@ -132,9 +132,9 @@ movq 160(%rsp), %rdi\n+ movq 168(%rsp), %rsi\r\n+ addq $184, %rsp\r\n+ ret\r\n+-ENDFN(chacha_blocks)\r\n++ENDFN(OQS_chacha_blocks)\r\n+ \r\n+-FN(hchacha)\r\n++FN(OQS_hchacha)\r\n+ subq $40, %rsp\r\n+ movdqa %xmm6, 0(%rsp)\r\n+ movq %rdi, 16(%rsp)\r\n+@@ -149,7 +149,7 @@ movq 16(%rsp), %rdi\n+ movq 24(%rsp), %rsi\r\n+ addq $40, %rsp\r\n+ ret\r\n+-ENDFN(hchacha)\r\n++ENDFN(OQS_hchacha)\r\n+ \r\n+ #define chacha chacha_thunk\r\n+ #define xchacha xchacha_thunk\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+index 48159c2..b0a84c6 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.c\n+@@ -217,7 +217,7 @@ static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned cha\n+   return inlen;\n+ }\n+ \n+-static const char iv[32] = {\n++static const unsigned iv[32] = {\n+   0x6a,0x09,0xe6,0x67,\n+   0xbb,0x67,0xae,0x85,\n+   0x3c,0x6e,0xf3,0x72,\n+@@ -228,7 +228,7 @@ static const char iv[32] = {\n+   0x5b,0xe0,0xcd,0x19,\n+ } ;\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen)\n+ {\n+   unsigned char h[32];\n+   unsigned char padded[128];\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+index 4717f09..800ab4c 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_hash_sha256.h\n+@@ -1,9 +1,9 @@\n+ #ifndef CRYPTO_HASH_SHA256_H\n+ #define CRYPTO_HASH_SHA256_H\n+ \n+-int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hashblocks_sha256(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen);\n+ \n+-int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);\n++static int crypto_hash_sha256(unsigned char *out,const unsigned char *in,unsigned long long inlen);static\n+ \n+ #define crypto_hash_sha256_BYTES 32\n+ \n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream.h b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+index aab8052..2053382 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream.h\n+@@ -5,12 +5,12 @@\n+   #include \"crypto_stream_chacha20.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 8\n+-  #define crypto_stream crypto_stream_chacha20\n++  #define crypto_stream OQS_crypto_stream_chacha20\n+ #else\n+   #include \"crypto_stream_aes256ctr.h\"\n+   #define CRYPTO_STREAM_KEYBYTES 32\n+   #define CRYPTO_STREAM_NONCEBYTES 16\n+-  #define crypto_stream crypto_stream_aes256ctr\n++  #define crypto_stream OQS_crypto_stream_aes256ctr\n+ #endif\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n+deleted file mode 100644\n+index 3b74551..0000000\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.c\n++++ /dev/null\n+@@ -1,242 +0,0 @@\n+-/*\r\n+-  aesenc-int.c version $Date: 2014/08/22 16:49:12 $\r\n+-  AES-CTR\r\n+-  Romain Dolbeau\r\n+-  Public Domain\r\n+-*/\r\n+-\r\n+-#include <stdio.h>\r\n+-#include <stdlib.h>\r\n+-#include <string.h>\r\n+-#include <immintrin.h>\r\n+-#include \"crypto_stream_aes256ctr.h\"\r\n+-\r\n+-#ifdef __INTEL_COMPILER\r\n+-#define ALIGN16 __declspec(align(16))\r\n+-#define ALIGN32 __declspec(align(32))\r\n+-#define ALIGN64 __declspec(align(64))\r\n+-#else // assume GCC\r\n+-#define ALIGN16  __attribute__((aligned(16)))\r\n+-#define ALIGN32  __attribute__((aligned(32)))\r\n+-#define ALIGN64  __attribute__((aligned(64)))\r\n+-#define _bswap64(a) __builtin_bswap64(a)\r\n+-#define _bswap(a) __builtin_bswap(a)\r\n+-#endif\r\n+-\r\n+-static inline void aesni_key256_expand(const unsigned char* key, __m128 rkeys[16]) {\r\n+-  __m128 key0 = _mm_loadu_ps((const float *)(key+0));\r\n+-  __m128 key1 = _mm_loadu_ps((const float *)(key+16));\r\n+-  __m128 temp0, temp1, temp2, temp4;\r\n+-  int idx = 0;\r\n+-\r\n+-  rkeys[idx++] = key0;\r\n+-  temp0 = key0;\r\n+-  temp2 = key1;\r\n+-  temp4 = _mm_setzero_ps();\r\n+-\r\n+-  /* why single precision floating-point rather than integer instructions ?\r\n+-     because _mm_shuffle_ps takes two inputs, while _mm_shuffle_epi32 only\r\n+-     takes one - it doesn't perform the same computation...\r\n+-     _mm_shuffle_ps takes the lower 64 bits of the result from the first\r\n+-     operand, and the higher 64 bits of the result from the second operand\r\n+-     (in both cases, all four input floats are accessible).\r\n+-     I don't like the non-orthogonal naming scheme :-(\r\n+-     \r\n+-     This is all strongly inspired by the openssl assembly code.\r\n+-  */\r\n+-#define BLOCK1(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp2, IMM);       \\\r\n+-  rkeys[idx++] = temp2;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x10);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp0, 0x8c);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xff);                           \\\r\n+-  temp0 = _mm_xor_ps(temp0, temp1)\r\n+-  \r\n+-#define BLOCK2(IMM)                                                     \\\r\n+-  temp1 = (__m128)_mm_aeskeygenassist_si128((__m128i)temp0, IMM);       \\\r\n+-  rkeys[idx++] = temp0;                                                 \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x10);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp4 = _mm_shuffle_ps(temp4, temp2, 0x8c);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp4);                                     \\\r\n+-  temp1 = _mm_shuffle_ps(temp1, temp1, 0xaa);                           \\\r\n+-  temp2 = _mm_xor_ps(temp2, temp1)\r\n+-  \r\n+-  BLOCK1(0x01);\r\n+-  BLOCK2(0x01);\r\n+-\r\n+-  BLOCK1(0x02);\r\n+-  BLOCK2(0x02);\r\n+-\r\n+-  BLOCK1(0x04);\r\n+-  BLOCK2(0x04);\r\n+-\r\n+-  BLOCK1(0x08);\r\n+-  BLOCK2(0x08);\r\n+-\r\n+-  BLOCK1(0x10);\r\n+-  BLOCK2(0x10);\r\n+-\r\n+-  BLOCK1(0x20);\r\n+-  BLOCK2(0x20);\r\n+-\r\n+-  BLOCK1(0x40);\r\n+-  rkeys[idx++] = temp0;\r\n+-}\r\n+-\r\n+-/** single, by-the-book AES encryption with AES-NI */\r\n+-static inline void aesni_encrypt1(unsigned char *out, unsigned char *n, __m128i rkeys[16]) {\r\n+-  __m128i nv = _mm_load_si128((const __m128i *)n);\r\n+-  int i;\r\n+-  __m128i temp = _mm_xor_si128(nv, rkeys[0]);\r\n+-#pragma unroll(13)\r\n+-  for (i = 1 ; i < 14 ; i++) {\r\n+-    temp = _mm_aesenc_si128(temp, rkeys[i]);\r\n+-  }\r\n+-  temp = _mm_aesenclast_si128(temp, rkeys[14]);\r\n+-  _mm_store_si128((__m128i*)(out), temp);\r\n+-}\r\n+-\r\n+-/** increment the 16-bytes nonce ;\r\n+-    this really should be improved somehow...\r\n+-    but it's not yet time-critical, because we\r\n+-    use the vector variant anyway  */\r\n+-static inline void incle(unsigned char n[16]) {\r\n+-/*   unsigned long long out; */\r\n+-/*   unsigned char carry; */\r\n+-  unsigned long long *n_ = (unsigned long long*)n;\r\n+-  n_[1]++;\r\n+-  if (n_[1] == 0)\r\n+-    n_[0] ++;\r\n+-  /* perhaps this will be efficient on broadwell ? */\r\n+-  /*   carry = _addcarry_u64(0, n_[1], 1ULL, &out); */\r\n+-  /*   carry = _addcarry_u64(carry, n_[0], 0ULL, &out); */\r\n+-}\r\n+-\r\n+-/** multiple-blocks-at-once AES encryption with AES-NI ;\r\n+-    on Haswell, aesenc as a latency of 7 and a througput of 1\r\n+-    so the sequence of aesenc should be bubble-free, if you\r\n+-    have at least 8 blocks. Let's build an arbitratry-sized\r\n+-    function */\r\n+-/* Step 1 : loading the nonce */\r\n+-/* load & increment the n vector (non-vectorized, unused for now) */\r\n+-#define NVx(a)                                                  \\\r\n+-  __m128i nv##a = _mm_shuffle_epi8(_mm_load_si128((const __m128i *)n), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7)); incle(n)\r\n+-/* load the incremented n vector (vectorized, probably buggy) */\r\n+-#define NVxV_DEC(a)                                                     \\\r\n+-  __m128i nv##a;\r\n+-#define NVxV_NOWRAP(a)                                                  \\\r\n+-  nv##a = _mm_shuffle_epi8(_mm_add_epi64(nv0i, _mm_set_epi64x(a,0)), _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-#define NVxV_WRAP(a)                                                    \\\r\n+-  __m128i ad##a = _mm_add_epi64(nv0i, _mm_set_epi64x(a,a>=wrapnumber?1:0)); \\\r\n+-  nv##a = _mm_shuffle_epi8(ad##a, _mm_set_epi8(8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7))\r\n+-\r\n+-/* Step 2 : define value in round one (xor with subkey #0, aka key) */\r\n+-#define TEMPx(a)                                        \\\r\n+-  __m128i temp##a = _mm_xor_si128(nv##a, rkeys[0])\r\n+-\r\n+-/* Step 3: one round of AES */\r\n+-#define AESENCx(a)                                      \\\r\n+-  temp##a =  _mm_aesenc_si128(temp##a, rkeys[i]);\r\n+-\r\n+-/* Step 4: last round of AES */\r\n+-#define AESENCLASTx(a)                                  \\\r\n+-  temp##a = _mm_aesenclast_si128(temp##a, rkeys[14]);\r\n+-\r\n+-/* Step 5: store result */\r\n+-#define STOREx(a)                                       \\\r\n+-  _mm_store_si128((__m128i*)(out+(a*16)), temp##a);\r\n+-\r\n+-/* all the MAKE* macros are for automatic explicit unrolling */\r\n+-#define MAKE4(X)                                \\\r\n+-  X(0);X(1);X(2);X(3)\r\n+-\r\n+-#define MAKE6(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5)\r\n+-\r\n+-#define MAKE7(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6)\r\n+-\r\n+-#define MAKE8(X)                                \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7)\r\n+-\r\n+-#define MAKE10(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9)\r\n+-\r\n+-#define MAKE12(X)                               \\\r\n+-  X(0);X(1);X(2);X(3);                          \\\r\n+-  X(4);X(5);X(6);X(7);                          \\\r\n+-  X(8);X(9);X(10);X(11)\r\n+-\r\n+-/* create a function of unrolling N ; the MAKEN is the unrolling\r\n+-   macro, defined above. The N in MAKEN must match N, obviously. */\r\n+-#define FUNC(N, MAKEN)                          \\\r\n+-  static inline void aesni_encrypt##N(unsigned char *out, unsigned char *n, __m128i rkeys[16]) { \\\r\n+-    __m128i nv0i = _mm_load_si128((const __m128i *)n);                  \\\r\n+-    long long nl = *(long long*)&n[8];                                  \\\r\n+-    MAKEN(NVxV_DEC);                                                    \\\r\n+-    /* check for nonce wraparound */                                    \\\r\n+-    if ((nl < 0) && (nl + (N-1)) >= 0) {                                \\\r\n+-      int wrapnumber = (int)(N - (nl+N));                               \\\r\n+-      MAKEN(NVxV_WRAP);                                                 \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,1))); \\\r\n+-    } else {                                                            \\\r\n+-      MAKEN(NVxV_NOWRAP);                                               \\\r\n+-      _mm_storeu_si128((__m128i*)n, _mm_add_epi64(nv0i, _mm_set_epi64x(N,0))); \\\r\n+-    }                                                                   \\\r\n+-    int i;                                                              \\\r\n+-    MAKEN(TEMPx);                                                       \\\r\n+-    for (i = 1 ; i < 14 ; i++) {                                        \\\r\n+-      MAKEN(AESENCx);                                                   \\\r\n+-    }                                                                   \\\r\n+-    MAKEN(AESENCLASTx);                                                 \\\r\n+-    MAKEN(STOREx);                                                      \\\r\n+-  }\r\n+-\r\n+-/* and now building our unrolled function is trivial */\r\n+-FUNC(4, MAKE4)\r\n+-FUNC(6, MAKE6)\r\n+-FUNC(7, MAKE7)\r\n+-FUNC(8, MAKE8)\r\n+-FUNC(10, MAKE10)\r\n+-FUNC(12, MAKE12)\r\n+-\r\n+-int crypto_stream_aes256ctr(\r\n+-unsigned char *out,\r\n+-unsigned long long outlen,\r\n+-const unsigned char *n,\r\n+-const unsigned char *k\r\n+-)\r\n+-{\r\n+-  __m128 rkeys[16];\r\n+-  ALIGN16 unsigned char n2[16];\r\n+-  unsigned long long i, j;\r\n+-  aesni_key256_expand(k, rkeys);\r\n+-  /* n2 is in byte-reversed (i.e., native little endian)\r\n+-     order to make increment/testing easier */\r\n+-  (*(unsigned long long*)&n2[8]) = _bswap64((*(unsigned long long*)&n[8]));\r\n+-  (*(unsigned long long*)&n2[0]) = _bswap64((*(unsigned long long*)&n[0]));\r\n+-  \r\n+-#define LOOP(iter)                                       \\\r\n+-  int lb = iter * 16;                                    \\\r\n+-  for (i = 0 ; i < outlen ; i+= lb) {                    \\\r\n+-    ALIGN16 unsigned char outni[lb];       \\\r\n+-    aesni_encrypt##iter(outni, n2, (__m128i*)rkeys);     \\\r\n+-    unsigned long long mj = lb;                          \\\r\n+-    if ((i+mj)>=outlen)                                  \\\r\n+-      mj = outlen-i;                                     \\\r\n+-    for (j = 0 ; j < mj ; j++)                           \\\r\n+-      out[i+j] = outni[j];                               \\\r\n+-  }\r\n+-  \r\n+-  LOOP(8);\r\n+-\r\n+-  return 0;\r\n+-}\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+index 9be2881..f694dc9 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.h\n+@@ -1,6 +1,6 @@\n+ #ifndef CRYPTO_STREAM_AES256CTR_H\r\n+ #define CRYPTO_STREAM_AES256CTR_H\r\n+ \r\n+-int crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n++int OQS_crypto_stream_aes256ctr(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+index 0b56a2b..0c0b1db 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_aes256ctr.s\n+@@ -4,9 +4,9 @@\n+ \t.text\n+ .LHOTB11:\n+ \t.p2align 4,,15\n+-\t.globl\tcrypto_stream_aes256ctr\n+-\t.type\tcrypto_stream_aes256ctr, @function\n+-crypto_stream_aes256ctr:\n++\t.globl\tOQS_crypto_stream_aes256ctr\n++\t.type\tOQS_crypto_stream_aes256ctr, @function\n++OQS_crypto_stream_aes256ctr:\n+ .LFB2248:\n+ \t.cfi_startproc\n+ \tpushq\t%rbp\n+@@ -328,7 +328,7 @@ crypto_stream_aes256ctr:\n+ \tret\n+ \t.cfi_endproc\n+ .LFE2248:\n+-\t.size\tcrypto_stream_aes256ctr, .-crypto_stream_aes256ctr\n++\t.size\tOQS_crypto_stream_aes256ctr, .-OQS_crypto_stream_aes256ctr\n+ \t.section\t.text.unlikely\n+ .LCOLDE11:\n+ \t.text\n+diff --git a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+index a3ffee1..d4e511b 100644\n+--- a/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n++++ b/src/kex_rlwe_newhope/avx2/crypto_stream_chacha20.c\n+@@ -1,10 +1,10 @@\n+ #include \"crypto_stream_chacha20.h\"\n+ #include <stddef.h>\n+ \n+-extern void chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n++extern void OQS_chacha_avx2(const unsigned char *k, const unsigned char *n, const unsigned char *in, unsigned char *out, size_t inlen, size_t rounds);\n+ \n+-int crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k) \n++int OQS_crypto_stream_chacha20(unsigned char *out, unsigned long long outlen, const unsigned char *n, const unsigned char *k)\n+ {\n+-\tchacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n++\tOQS_chacha_avx2(k, n, NULL, out, (size_t)outlen, 20);\n+ \treturn 0;\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.c b/src/kex_rlwe_newhope/avx2/error_correction.c\n+index 0970e6f..eaf2952 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.c\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.c\n+@@ -3,7 +3,7 @@\n+ \n+ //See paper for details on the error reconciliation\n+ \n+-extern void hr(poly *c, const poly *v, unsigned char rand[32]);\n++extern void OQS_hr(poly *c, const poly *v, unsigned char rand[32]);\n+ \n+ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce)\n+ {\n+@@ -17,5 +17,5 @@ void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char no\n+ \n+   crypto_stream(rand,32,n,seed);\n+ \n+-  hr(c, v, rand);\n++  OQS_hr(c, v, rand);\n+ }\n+diff --git a/src/kex_rlwe_newhope/avx2/error_correction.h b/src/kex_rlwe_newhope/avx2/error_correction.h\n+index 488c105..c0e913d 100644\n+--- a/src/kex_rlwe_newhope/avx2/error_correction.h\n++++ b/src/kex_rlwe_newhope/avx2/error_correction.h\n+@@ -9,7 +9,7 @@\n+ #include \"poly.h\"\n+ #include <stdio.h>\n+ \n+-void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n+-void rec(unsigned char *key, const poly *v, const poly *c);\n++static void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);\n++void OQS_rec(unsigned char *key, const poly *v, const poly *c);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.c b/src/kex_rlwe_newhope/avx2/fips202.c\n+index f649a7d..b83029c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.c\n++++ b/src/kex_rlwe_newhope/avx2/fips202.c\n+@@ -60,7 +60,7 @@ static const uint64_t KeccakF_RoundConstants[NROUNDS] =\n+     (uint64_t)0x8000000080008008ULL\n+ };\n+ \n+-void KeccakF1600_StatePermute(uint64_t * state)\n++static void KeccakF1600_StatePermute(uint64_t * state)\n+ {\n+   int round;\n+ \n+@@ -381,19 +381,19 @@ static void keccak_squeezeblocks(unsigned char *h, unsigned long long int nblock\n+ }\n+ \n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   keccak_absorb(s, SHAKE128_RATE, input, inputByteLen, 0x1F);\n+ }\n+ \n+ \n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)\n+ {\n+   keccak_squeezeblocks(output, nblocks, s, SHAKE128_RATE);\n+ }\n+ \n+ \n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   assert(!(outputByteLen%SHAKE128_RATE));\n+@@ -402,7 +402,7 @@ void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned\n+ }\n+ \n+ \n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)\n+ {\n+   uint64_t s[25];\n+   unsigned char t[SHA3_256_RATE];\n+diff --git a/src/kex_rlwe_newhope/avx2/fips202.h b/src/kex_rlwe_newhope/avx2/fips202.h\n+index b564434..d02ec7c 100644\n+--- a/src/kex_rlwe_newhope/avx2/fips202.h\n++++ b/src/kex_rlwe_newhope/avx2/fips202.h\n+@@ -4,9 +4,9 @@\n+ #define SHAKE128_RATE 168\n+ #define SHA3_256_RATE 136\n+ \n+-void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n+-void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n+-void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n+-void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);\n++static void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);\n++static void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);\n++static void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);\n+ \n+ #endif\n+diff --git a/src/kex_rlwe_newhope/avx2/hr.s b/src/kex_rlwe_newhope/avx2/hr.s\n+index beb93fe..7eac399 100644\n+--- a/src/kex_rlwe_newhope/avx2/hr.s\n++++ b/src/kex_rlwe_newhope/avx2/hr.s\n+@@ -81,10 +81,10 @@\n+ \n+ # qhasm: enter hr\n+ .p2align 5\n+-.global _hr\n+-.global hr\n+-_hr:\n+-hr:\n++.global OQS_hr\n++.global OQS_hr\n++OQS_hr:\n++OQS_hr:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/newhope.c b/src/kex_rlwe_newhope/avx2/newhope.c\n+index b9f7a6c..f0c5ad9 100644\n+--- a/src/kex_rlwe_newhope/avx2/newhope.c\n++++ b/src/kex_rlwe_newhope/avx2/newhope.c\n+@@ -1,7 +1,5 @@\n+-#include \"poly.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"error_correction.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"poly.c\"\r\n++#include \"error_correction.c\"\r\n+ \r\n+ static void encode_a(unsigned char *r, const poly *pk, const unsigned char *seed)\r\n+ {\r\n+@@ -48,7 +46,7 @@ static void gen_a(poly *a, const unsigned char *seed)\n+ \r\n+ // API FUNCTIONS \r\n+ \r\n+-void newhope_keygen(unsigned char *send, poly *sk)\r\n++static void newhope_keygen(unsigned char *send, poly *sk)\r\n+ {\r\n+   poly a, e, r, pk;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -66,14 +64,14 @@ void newhope_keygen(unsigned char *send, poly *sk)\n+   poly_getnoise(&e,noiseseed,1);\r\n+   poly_ntt(&e);\r\n+ \r\n+-  poly_pointwise(&r,sk,&a);\r\n++  OQS_poly_pointwise(&r,sk,&a);\r\n+   poly_add(&pk,&e,&r);\r\n+ \r\n+   encode_a(send, &pk, seed);\r\n+ }\r\n+ \r\n+ \r\n+-void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n++static void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received)\r\n+ {\r\n+   poly sp, ep, v, a, pka, c, epp, bp;\r\n+   unsigned char seed[NEWHOPE_SEEDBYTES];\r\n+@@ -89,10 +87,10 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+   poly_getnoise(&ep,noiseseed,1);\r\n+   poly_ntt(&ep);\r\n+ \r\n+-  poly_pointwise(&bp, &a, &sp);\r\n++  OQS_poly_pointwise(&bp, &a, &sp);\r\n+   poly_add(&bp, &bp, &ep);\r\n+   \r\n+-  poly_pointwise(&v, &pka, &sp);\r\n++  OQS_poly_pointwise(&v, &pka, &sp);\r\n+   poly_invntt(&v);\r\n+ \r\n+   poly_getnoise(&epp,noiseseed,2);\r\n+@@ -102,7 +100,7 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ \r\n+   encode_b(send, &bp, &c);\r\n+   \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32);\r\n+@@ -110,16 +108,16 @@ void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsign\n+ }\r\n+ \r\n+ \r\n+-void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n++static void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)\r\n+ {\r\n+   poly v,bp, c;\r\n+ \r\n+   decode_b(&bp, &c, received);\r\n+ \r\n+-  poly_pointwise(&v,sk,&bp);\r\n++  OQS_poly_pointwise(&v,sk,&bp);\r\n+   poly_invntt(&v);\r\n+  \r\n+-  rec(sharedkey, &v, &c);\r\n++  OQS_rec(sharedkey, &v, &c);\r\n+ \r\n+ #ifndef STATISTICAL_TEST \r\n+   sha3256(sharedkey, sharedkey, 32); \r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt.h b/src/kex_rlwe_newhope/avx2/ntt.h\n+index c24b137..1cb540a 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt.h\n++++ b/src/kex_rlwe_newhope/avx2/ntt.h\n+@@ -8,8 +8,8 @@ extern int32_t psis_inv[];\n+ extern double omegas_double[];\r\n+ extern double omegas_inv_double[];\r\n+ \r\n+-void bitrev_vector(int32_t* poly);\r\n+-void pwmul_double(int32_t* poly, const int32_t* factors);\r\n+-void ntt_double(int32_t*,const double*,const double*);\r\n++void OQS_bitrev_vector(int32_t* poly);\r\n++void OQS_pwmul_double(int32_t* poly, const int32_t* factors);\r\n++void OQS_ntt_double(int32_t*,const double*,const double*);\r\n+ \r\n+ #endif\r\n+diff --git a/src/kex_rlwe_newhope/avx2/ntt_double.s b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+index 1ec429f..d876550 100644\n+--- a/src/kex_rlwe_newhope/avx2/ntt_double.s\n++++ b/src/kex_rlwe_newhope/avx2/ntt_double.s\n+@@ -76,9 +76,9 @@\n+ # qhasm: enter ntt_double\n+ .p2align 5\n+ .global _ntt_double\n+-.global ntt_double\n++.global OQS_ntt_double\n+ _ntt_double:\n+-ntt_double:\n++OQS_ntt_double:\n+ mov %rsp,%r11\n+ and $31,%r11\n+ add $0,%r11\n+diff --git a/src/kex_rlwe_newhope/avx2/poly.c b/src/kex_rlwe_newhope/avx2/poly.c\n+index 43c0df2..44b0956 100644\n+--- a/src/kex_rlwe_newhope/avx2/poly.c\n++++ b/src/kex_rlwe_newhope/avx2/poly.c\n+@@ -1,7 +1,7 @@\n+ #include \"poly.h\"\r\n+ #include \"ntt.h\"\r\n+-#include \"randombytes.h\"\r\n+-#include \"fips202.h\"\r\n++#include \"randombytes.c\"\r\n++#include \"fips202.c\"\r\n+ #include \"crypto_stream.h\"\r\n+ \r\n+ static uint16_t barrett_reduce(uint16_t a)\r\n+@@ -14,7 +14,7 @@ static uint16_t barrett_reduce(uint16_t a)\n+   return a;\r\n+ }\r\n+ \r\n+-void poly_frombytes(poly *r, const unsigned char *a)\r\n++static void poly_frombytes(poly *r, const unsigned char *a)\r\n+ {\r\n+   int i;\r\n+   for(i=0;i<PARAM_N/4;i++)\r\n+@@ -26,7 +26,7 @@ void poly_frombytes(poly *r, const unsigned char *a)\n+   }\r\n+ }\r\n+ \r\n+-void poly_tobytes(unsigned char *r, const poly *p)\r\n++static void poly_tobytes(unsigned char *r, const poly *p)\r\n+ {\r\n+   int i;\r\n+   uint16_t t0,t1,t2,t3,m;\r\n+@@ -70,7 +70,7 @@ void poly_tobytes(unsigned char *r, const poly *p)\n+ \r\n+ \r\n+ \r\n+-void poly_uniform(poly *a, const unsigned char *seed)\r\n++static void poly_uniform(poly *a, const unsigned char *seed)\r\n+ {\r\n+   unsigned int pos=0, ctr=0;\r\n+   uint16_t val;\r\n+@@ -99,9 +99,9 @@ void poly_uniform(poly *a, const unsigned char *seed)\n+ }\r\n+ \r\n+ \r\n+-extern void cbd(poly *r, unsigned char *b);\r\n++extern void OQS_cbd(poly *r, unsigned char *b);\r","path":"patches/kex_rlwe_newhope_avx2/patch1.patch","position":940,"original_position":940,"commit_id":"206d69c26fd34855adb111b05c2d9c27290aae80","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"s24mishra","id":32465481,"avatar_url":"https://avatars3.githubusercontent.com/u/32465481?v=4","gravatar_id":"","url":"https://api.github.com/users/s24mishra","html_url":"https://github.com/s24mishra","followers_url":"https://api.github.com/users/s24mishra/followers","following_url":"https://api.github.com/users/s24mishra/following{/other_user}","gists_url":"https://api.github.com/users/s24mishra/gists{/gist_id}","starred_url":"https://api.github.com/users/s24mishra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s24mishra/subscriptions","organizations_url":"https://api.github.com/users/s24mishra/orgs","repos_url":"https://api.github.com/users/s24mishra/repos","events_url":"https://api.github.com/users/s24mishra/events{/privacy}","received_events_url":"https://api.github.com/users/s24mishra/received_events","type":"User","site_admin":false},"body":"Yes.","created_at":"2017-10-16T16:17:59Z","updated_at":"2017-10-16T16:17:59Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895171","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895171"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895171"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144841854},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T16:17:59Z","closed_at":null,"merged_at":null,"merge_commit_sha":"60ca9f2a04acb7ac59560a4e1d1d0cf5c638d841","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"206d69c26fd34855adb111b05c2d9c27290aae80","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T16:17:59Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6722813263","type":"PullRequestReviewCommentEvent","actor":{"id":32465481,"login":"s24mishra","display_login":"s24mishra","gravatar_id":"","url":"https://api.github.com/users/s24mishra","avatar_url":"https://avatars.githubusercontent.com/u/32465481?"},"repo":{"id":65514205,"name":"open-quantum-safe/liboqs","url":"https://api.github.com/repos/open-quantum-safe/liboqs"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895368","pull_request_review_id":69616432,"id":144895368,"diff_hunk":"@@ -0,0 +1,18 @@\n+diff --git a/src/kex_rlwe_newhope/avx2/Makefile.am b/src/kex_rlwe_newhope/avx2/Makefile.am\n+new file mode 100644\n+index 0000000..baced33\n+--- /dev/null\n++++ b/src/kex_rlwe_newhope/avx2/Makefile.am","path":"patches/kex_rlwe_newhope_avx2/patch0.patch","position":5,"original_position":5,"commit_id":"206d69c26fd34855adb111b05c2d9c27290aae80","original_commit_id":"e351f52c441344abb465b4303dc1bb06bc622423","user":{"login":"s24mishra","id":32465481,"avatar_url":"https://avatars3.githubusercontent.com/u/32465481?v=4","gravatar_id":"","url":"https://api.github.com/users/s24mishra","html_url":"https://github.com/s24mishra","followers_url":"https://api.github.com/users/s24mishra/followers","following_url":"https://api.github.com/users/s24mishra/following{/other_user}","gists_url":"https://api.github.com/users/s24mishra/gists{/gist_id}","starred_url":"https://api.github.com/users/s24mishra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s24mishra/subscriptions","organizations_url":"https://api.github.com/users/s24mishra/orgs","repos_url":"https://api.github.com/users/s24mishra/repos","events_url":"https://api.github.com/users/s24mishra/events{/privacy}","received_events_url":"https://api.github.com/users/s24mishra/received_events","type":"User","site_admin":false},"body":"Yes, because autoconf requires the presence of Makefile.am whether or not the algorithm is enabled or not.","created_at":"2017-10-16T16:18:48Z","updated_at":"2017-10-16T16:18:48Z","html_url":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895368","pull_request_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments/144895368"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176#discussion_r144895368"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"}},"in_reply_to_id":144842649},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176","id":142762954,"html_url":"https://github.com/open-quantum-safe/liboqs/pull/176","diff_url":"https://github.com/open-quantum-safe/liboqs/pull/176.diff","patch_url":"https://github.com/open-quantum-safe/liboqs/pull/176.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176","number":176,"state":"open","locked":false,"title":"Patch-based approach for adding NewHope AVX2","user":{"login":"smashra","id":14256579,"avatar_url":"https://avatars2.githubusercontent.com/u/14256579?v=4","gravatar_id":"","url":"https://api.github.com/users/smashra","html_url":"https://github.com/smashra","followers_url":"https://api.github.com/users/smashra/followers","following_url":"https://api.github.com/users/smashra/following{/other_user}","gists_url":"https://api.github.com/users/smashra/gists{/gist_id}","starred_url":"https://api.github.com/users/smashra/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/smashra/subscriptions","organizations_url":"https://api.github.com/users/smashra/orgs","repos_url":"https://api.github.com/users/smashra/repos","events_url":"https://api.github.com/users/smashra/events{/privacy}","received_events_url":"https://api.github.com/users/smashra/received_events","type":"User","site_admin":false},"body":"AVX2 build by applying git patch for taking care of travis tests.","created_at":"2017-09-24T17:34:41Z","updated_at":"2017-10-16T16:18:48Z","closed_at":null,"merged_at":null,"merge_commit_sha":"60ca9f2a04acb7ac59560a4e1d1d0cf5c638d841","assignee":null,"assignees":[],"requested_reviewers":[{"login":"dstebila","id":8843219,"avatar_url":"https://avatars0.githubusercontent.com/u/8843219?v=4","gravatar_id":"","url":"https://api.github.com/users/dstebila","html_url":"https://github.com/dstebila","followers_url":"https://api.github.com/users/dstebila/followers","following_url":"https://api.github.com/users/dstebila/following{/other_user}","gists_url":"https://api.github.com/users/dstebila/gists{/gist_id}","starred_url":"https://api.github.com/users/dstebila/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dstebila/subscriptions","organizations_url":"https://api.github.com/users/dstebila/orgs","repos_url":"https://api.github.com/users/dstebila/repos","events_url":"https://api.github.com/users/dstebila/events{/privacy}","received_events_url":"https://api.github.com/users/dstebila/received_events","type":"User","site_admin":false}],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80","head":{"label":"open-quantum-safe:issue30_patch_based","ref":"issue30_patch_based","sha":"206d69c26fd34855adb111b05c2d9c27290aae80","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"base":{"label":"open-quantum-safe:master","ref":"master","sha":"fcbd0f35b857df3dd769fe2ebf7e7727bfacf779","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":65514205,"name":"liboqs","full_name":"open-quantum-safe/liboqs","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/liboqs","description":"C library for quantum-resistant cryptographic algorithms.","fork":false,"url":"https://api.github.com/repos/open-quantum-safe/liboqs","forks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/liboqs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/liboqs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/liboqs/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/liboqs/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/liboqs/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/liboqs/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/liboqs/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/liboqs/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/liboqs/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/liboqs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/liboqs/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/liboqs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/liboqs/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/liboqs/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/liboqs/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/liboqs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/liboqs/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/liboqs/deployments","created_at":"2016-08-12T01:46:12Z","updated_at":"2017-10-16T10:15:06Z","pushed_at":"2017-10-16T16:12:15Z","git_url":"git://github.com/open-quantum-safe/liboqs.git","ssh_url":"git@github.com:open-quantum-safe/liboqs.git","clone_url":"https://github.com/open-quantum-safe/liboqs.git","svn_url":"https://github.com/open-quantum-safe/liboqs","homepage":"https://openquantumsafe.org/","size":9168,"stargazers_count":170,"watchers_count":170,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":31,"mirror_url":null,"open_issues_count":17,"forks":31,"open_issues":17,"watchers":170,"default_branch":"master"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176"},"html":{"href":"https://github.com/open-quantum-safe/liboqs/pull/176"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/issues/176/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/pulls/176/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/liboqs/statuses/206d69c26fd34855adb111b05c2d9c27290aae80"}},"author_association":"MEMBER"}},"public":true,"created_at":"2017-10-16T16:18:48Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
