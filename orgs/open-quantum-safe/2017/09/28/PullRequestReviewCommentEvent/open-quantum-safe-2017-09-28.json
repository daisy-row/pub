{"id":"6651421406","type":"PullRequestReviewCommentEvent","actor":{"id":16247285,"login":"christianpaquin","display_login":"christianpaquin","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","avatar_url":"https://avatars.githubusercontent.com/u/16247285?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments/141720994","pull_request_review_id":65981417,"id":141720994,"diff_hunk":"@@ -0,0 +1,593 @@\n+#define UNUSED __attribute__((unused))\n+\n+#include <openssl/asn1t.h>\n+#include <openssl/cms.h>\n+#include <openssl/err.h>\n+#include <openssl/pem.h>\n+#include <openssl/ssl.h>\n+\n+#include <oqs/rand.h>\n+#include <oqs/common.h>\n+#include <oqs/sig.h>\n+\n+#include \"oqs.h\"\n+\n+/* \n+ * FIXMEOQS (remove this)\n+ * OQS note: the content of this file should be distributed in the OpenSSL\n+ * code base to avoid a manual registration of the OQS algs, but this makes\n+ * it simple to develop and test. \n+ *\n+ * Error codes should be reviewed and functions defined for the OQSerr macro. \n+ *\n+ * The code needs to be generalized to support more than one sig alg.\n+ */\n+\n+/*\n+ * This file contains OQS-related code. This could be distributed in various\n+ * files like the other OpenSSL algs, but we keep them in one file for simplicity.\n+ */\n+\n+static int g_initialized = 0;\n+\n+int OQS_up_ref(OQS_PKEY_CTX *key)\n+{\n+  int i = CRYPTO_add(&key->references, 1, CRYPTO_LOCK_OQS);\n+  return ((i > 1) ? 1 : 0);\n+}\n+\n+int EVP_PKEY_set1_OQS(EVP_PKEY *pkey, OQS_PKEY_CTX *key)\n+{             \n+  int ret = EVP_PKEY_assign(pkey, EVP_PKEY_OQS, key);\n+  if(ret) OQS_up_ref(key);\n+  return ret;\n+}             \n+\n+int pkey_oqs_init(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs  = OPENSSL_malloc(sizeof(OQS_PKEY_CTX));\n+  if (!oqs) {\n+    return 0;\n+  }\n+  oqs->s = 0;\n+  oqs->sk = 0;\n+  oqs->pk = 0;\n+  oqs->references = 0;\n+  oqs->md = 0;\n+  ctx->data = oqs;\n+  return 1;\n+}\n+\n+int pkey_oqs_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\n+\n+{\n+  OQS_PKEY_CTX *dctx, *sctx;\n+  if (!pkey_oqs_init(dst)) {\n+    return 0;\n+  }\n+  // FIXMEOQS: are these copies safe? should I call OQS_up_ref?\n+\n+  sctx = src->data;\n+  dctx = dst->data;\n+  dctx->s = sctx->s;\n+  dctx->sk = sctx->sk;\n+  dctx->pk = sctx->pk;\n+  dctx->references = sctx->references;\n+  dctx->md = sctx->md;\n+  return 1;\t\n+}\n+\n+void pkey_oqs_cleanup(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = ctx->data;\n+  if (oqs) {\n+    OPENSSL_free(oqs);\n+  }\n+}\n+\n+int pkey_oqs_sign_init(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs->sk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+int pkey_oqs_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\n+\t\t  const unsigned char *tbs, size_t tbslen)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs_ctx || !oqs_ctx->s || !oqs_ctx->sk ) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  if (*siglen != oqs_ctx->s->max_sig_len) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  if (OQS_SIG_sign(oqs_ctx->s, oqs_ctx->sk, tbs, tbslen, sig, siglen) != 1) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+int pkey_oqs_verify(EVP_PKEY_CTX *ctx,\n+\t\t    const unsigned char *sig, size_t siglen,\n+\t\t    const unsigned char *tbs, size_t tbslen)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs_ctx || !oqs_ctx->s  || !oqs_ctx->pk || sig == NULL || tbs == NULL) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  if (OQS_SIG_verify(oqs_ctx->s, oqs_ctx->pk, tbs, tbslen, sig, siglen) != 1) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+int oqs_pkey_ctx_init(OQS_PKEY_CTX* ctx, enum OQS_SIG_algid algid) {\n+  if (ctx == NULL) {\n+    goto err;\n+  }\n+\n+  OQS_RAND *rand = NULL;\n+  OQS_SIG *s;\n+  uint8_t *priv = NULL;\n+  uint8_t *pub = NULL;\n+\n+  rand = OQS_RAND_new(OQS_RAND_alg_default); // TODO: don't hardcode\n+  if (rand == NULL) {\n+    goto err;\n+  }\n+  s = OQS_SIG_new(rand, algid);\n+  if (s == NULL) {\n+    goto err;\n+  }\n+  priv = OPENSSL_malloc(s->priv_key_len);\n+  if (priv == NULL) {\n+    goto err;\n+  }\n+  pub = OPENSSL_malloc(s->pub_key_len);\n+  if (pub == NULL) {\n+    goto err;\n+  }\n+  ctx->s = s;\n+  ctx->sk = priv;\n+  ctx->pk = pub;\n+\n+  return 1;\n+\n+ err:\n+  if (rand) { OQS_RAND_free(rand); }\n+  if (s) { OQS_SIG_free(s); }\n+  if (priv) { OPENSSL_free(priv); }\n+  if (pub) { OPENSSL_free(pub); }\n+  return 0;\n+}\n+\n+void oqs_pkey_ctx_free(OQS_PKEY_CTX* ctx) {\n+  if (ctx == NULL) {\n+    return;\n+  }\n+  if (ctx->s->rand) { OQS_RAND_free(ctx->s->rand); }\n+  if (ctx->s) { OQS_SIG_free(ctx->s); }\n+  if (ctx->sk) { OPENSSL_free(ctx->sk); }\n+  if (ctx->pk) { OPENSSL_free(ctx->pk); }\n+  return;\n+}\n+\n+int pkey_oqs_keygen_init(EVP_PKEY_CTX *ctx)\n+{\n+  if (ctx == NULL) {\n+    return 0;\n+  }\n+  OQS_PKEY_CTX *oqs_ctx = ctx->data;\n+  return oqs_pkey_ctx_init(oqs_ctx, OQS_SIG_picnic_default); // TODO: don't hardcode\n+}\n+\n+int pkey_oqs_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->data;\n+  if (!oqs_ctx || !oqs_ctx->s || !oqs_ctx->sk || !oqs_ctx->pk ) {\n+    goto err;\n+  }\n+  if (OQS_SIG_keygen(oqs_ctx->s, oqs_ctx->sk, oqs_ctx->pk) != 1) {\n+    goto err;\n+  }\n+  \n+  pkey->pkey.ptr = (void*) oqs_ctx;\n+  EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+  return 1;\n+\n+ err:\n+  return 0;\n+}\n+\n+static int pkey_oqs_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\n+{\n+  OQS_PKEY_CTX *oqs = ctx->data;\n+  switch(type)\n+    {\n+    case EVP_PKEY_CTRL_MD:\n+      if (EVP_MD_type((const EVP_MD *)p2) != NID_sha256 &&\n+\t  EVP_MD_type((const EVP_MD *)p2) != NID_sha384 &&\n+\t  EVP_MD_type((const EVP_MD *)p2) != NID_sha512)\n+\t{\n+\t  OQSerr(0, ERR_R_FATAL);\n+\t  return 0;\n+\t}\n+      oqs->md = (EVP_MD *) p2;\n+      return 1;\n+    case EVP_PKEY_CTRL_DIGESTINIT:\n+    case EVP_PKEY_CTRL_PKCS7_SIGN:\n+    case EVP_PKEY_CTRL_CMS_SIGN:\n+      return 1; \n+    case EVP_PKEY_CTRL_PEER_KEY:\n+\t  OQSerr(0, ERR_R_FATAL);\n+\t  return -2; // error code returned by calling function in p_lib.c\n+    default:\n+      return -2;\n+    }\n+  return 0;\n+}\n+\n+// The EVP OQS methods; 0s are unused\n+static EVP_PKEY_METHOD oqs_pkey_meth =\n+    {\n+      NID_oqs_picnic_default,\n+      EVP_PKEY_FLAG_AUTOARGLEN,\n+      pkey_oqs_init,\n+      pkey_oqs_copy,\n+      pkey_oqs_cleanup,\n+      0, // paramgen_init\n+      0, //paramgen\n+      pkey_oqs_keygen_init,\n+      pkey_oqs_keygen,\n+      pkey_oqs_sign_init,\n+      pkey_oqs_sign,\n+      0, //verify_init\n+      pkey_oqs_verify,\n+      0, //verify_recover_init\n+      0, //verify_recover\n+      0, //signctx_init\n+      0, //signctx\n+      0, //verifyctx_init\n+      0, //verifyctx\n+      0, //encrypt_init\n+      0, //encrypt\n+      0, //decrypt_init\n+      0, //decrypt\n+      0, //derive_init\n+      0, //derive\n+      pkey_oqs_ctrl,\n+      0 // pkey_oqs_ctrl_str\n+    };\n+\n+/////////////////////////////////////////////////////////\n+// ASN.1 artifacts\n+/////////////////////////////////////////////////////////\n+\n+// Secret key\n+typedef struct {\n+  long algid;\n+  ASN1_OCTET_STRING *sk;\n+  ASN1_OCTET_STRING *pk;\n+} oqsasn1sk;\n+// Public key\n+typedef struct {\n+  long algid;\n+  ASN1_OCTET_STRING *pk;\t\n+} oqsasn1pk;\n+\n+ASN1_SEQUENCE(oqsasn1sk) ={\n+  ASN1_SIMPLE(oqsasn1sk,algid,LONG),\n+  ASN1_SIMPLE(oqsasn1sk,sk,ASN1_OCTET_STRING),\n+  ASN1_SIMPLE(oqsasn1sk,pk,ASN1_OCTET_STRING)\n+}  ASN1_SEQUENCE_END(oqsasn1sk)\n+DECLARE_ASN1_FUNCTIONS(oqsasn1sk)\n+\n+ASN1_SEQUENCE(oqsasn1pk) ={\n+  ASN1_SIMPLE(oqsasn1pk,algid,LONG),\n+  ASN1_SIMPLE(oqsasn1pk,pk,ASN1_OCTET_STRING)\n+}  ASN1_SEQUENCE_END(oqsasn1pk)\n+DECLARE_ASN1_FUNCTIONS(oqsasn1pk)\n+\n+IMPLEMENT_ASN1_FUNCTIONS(oqsasn1sk)\n+IMPLEMENT_ASN1_FUNCTIONS(oqsasn1pk)\n+\n+ASN1_OCTET_STRING *asn1_octet_string_from( unsigned char *d, int len)\n+{\n+  ASN1_OCTET_STRING *a = ASN1_OCTET_STRING_new();\n+  if (!ASN1_OCTET_STRING_set(a, d, len)) {\n+    return 0;\n+  }\n+  return a;\n+}\n+\n+static int oqs_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*) pkey->pkey.ptr;\n+  void *pval = NULL;\n+  int ptype = V_ASN1_UNDEF;\n+  ASN1_STRING *penc = ASN1_STRING_new(); // FIXMEOQS: leaks! can't free it otherwise fails later\n+  if (!oqs->pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  oqsasn1pk asn1;\n+  asn1.algid = OQS_SIG_picnic_default; // FIXMEOQS: don't hardcode\n+  asn1.pk = asn1_octet_string_from(oqs->pk, oqs->s->pub_key_len);\n+  if (!asn1.pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  // i2d_TYPE converts an ASN.1 object in an internal standardized form\n+  // to its DER encoding and stuffs it into a character string\n+  penc->length = i2d_oqsasn1pk(&asn1,&penc->data);\n+  return X509_PUBKEY_set0_param(pk, OBJ_nid2obj(NID_oqs_picnic_default),\n+\t\t\t\tptype, pval, penc->data, penc->length);\n+}\n+\n+static int oqs_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n+{\n+  int rc;\n+  const unsigned char *p=NULL;\n+  int plen;\n+  PKCS8_pkey_get0(NULL, &p, &plen, NULL, p8);\n+\n+  oqsasn1sk a;\n+  oqsasn1sk *asn1=&a;\n+  a.sk = ASN1_OCTET_STRING_new();\n+  a.pk = ASN1_OCTET_STRING_new();\n+\n+  // d2i_TYPE converts an ASN.1 object from its DER encoded form to its\n+  // internal standardized form. \n+  d2i_oqsasn1sk(&asn1,(const unsigned char**)&p, plen);\n+\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) OPENSSL_malloc(sizeof(OQS_PKEY_CTX)); // FIXMEOQS: leaks\n+  oqs_pkey_ctx_init(oqs_ctx, asn1->algid);\n+  memcpy(oqs_ctx->sk, asn1->sk->data, oqs_ctx->s->priv_key_len); // FIXMEOQS: should the len come from the asn1 struct\n+  memcpy(oqs_ctx->pk, asn1->pk->data, oqs_ctx->s->pub_key_len);\n+  rc = EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+\n+  // cleanup:\n+  if (a.sk) { ASN1_OCTET_STRING_free(a.sk); }\n+  if (a.pk) { ASN1_OCTET_STRING_free(a.pk); }\n+\n+  return rc;\n+}\n+\n+static int oqs_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n+{\n+  unsigned char *p;\n+  int pklen;\n+  X509_ALGOR *palg;\n+\n+  if (!X509_PUBKEY_get0_param(NULL,(const unsigned char**) &p, &pklen, &palg, pubkey))\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      return 0;\n+    }\n+\n+  oqsasn1pk a;\n+  oqsasn1pk *asn1=&a;\n+  a.pk = ASN1_OCTET_STRING_new();\n+  d2i_oqsasn1pk(&asn1,(const unsigned char **)&p, pklen);\n+  OQS_PKEY_CTX *oqs_ctx = OPENSSL_malloc(sizeof(OQS_PKEY_CTX)); // FIXMEOQS: leaks\n+  oqs_pkey_ctx_init(oqs_ctx, asn1->algid);\n+  memcpy(oqs_ctx->pk, asn1->pk->data, oqs_ctx->s->pub_key_len);\n+  return EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+}\n+\n+static int oqs_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n+{\n+  int rc;\n+  ASN1_INTEGER *params = NULL;\n+  ASN1_STRING *prkey  = NULL;\n+\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  if (!oqs || !oqs->sk)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+  oqsasn1sk asn1;\n+  asn1.algid = OQS_SIG_picnic_default; // FIXMEOQS: don't hardcode\n+  asn1.sk = asn1_octet_string_from(oqs->sk, oqs->s->priv_key_len);\n+  if (!asn1.sk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    goto err;\n+  }\n+  asn1.pk = asn1_octet_string_from(oqs->pk, oqs->s->pub_key_len);\n+  if (!asn1.pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    goto err;\n+  }\n+  prkey = ASN1_STRING_new(); // FIXMEOQS: leaks! can't free it here otherwise fails later (in apps/genoqs.c)\n+  prkey->length = i2d_oqsasn1sk(&asn1,&prkey->data);\n+  if (prkey->length <= 0)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+  params=ASN1_INTEGER_new();\n+  ASN1_INTEGER_set(params,NID_oqs_picnic_default);\n+  if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_oqs_picnic_default), 0,\n+\t\t       V_ASN1_NULL,0, prkey->data, prkey->length))\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+    rc =1;\n+    goto cleanup;\n+\n+ err:\n+  rc = 0;\n+\n+ cleanup:\n+  if (asn1.sk) { ASN1_OCTET_STRING_free(asn1.sk); }\n+  if (asn1.pk) { ASN1_OCTET_STRING_free(asn1.pk); }\n+  if (params) { ASN1_INTEGER_free(params); }\n+  return rc;\n+}\n+\n+// Returns number of bytes per signatures as per the reference implementation\n+// FIXMEOQS: this seems wrong. Should return oqs->s->pub_key_len, but SSL code\n+// depends on this; should fix it so it doesn't call this function.\n+static int oqs_pkey_size(const EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  int siglen = oqs->s->max_sig_len;\n+  return siglen;\n+}\n+\n+static void oqs_pkey_free(EVP_PKEY *pkey)\n+{\n+  if (pkey == NULL) return;\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  oqs_pkey_ctx_free(oqs);\n+  return;\n+}\n+\n+// This function is called from the X509 context and prints the public key\n+// as we know them from x509 certs xx:xx:xx:xx...\n+static int oqs_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,\n+\t\t\t UNUSED ASN1_PCTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  unsigned char *pk = oqs->pk;\n+  int i;\n+  for (i = 0; i < oqs->s->pub_key_len; i++){\n+    if (i % 16 == 0) {\n+      if (i) BIO_write(bp, \"\\n\", 1);\n+      int j;\n+      for (j=0; j < indent; j++)\n+\tBIO_write(bp, \" \", 1);\n+    }\n+    char buf[10];\n+    sprintf(buf, \"%02x:\", pk[i]);\n+    BIO_write(bp, buf, 3);\n+  }\n+  BIO_write(bp,\"\\n\",1);\n+  return 1;\t\n+}\n+\n+// Prints the signature for the X.509 certificate as in openssl x509 -text\n+static int oqs_sig_print(BIO *bp, UNUSED const X509_ALGOR *sigalg,\n+\t\t\t const ASN1_STRING *sig, int indent, UNUSED ASN1_PCTX *pctx)\n+{\n+  if (!sig)\n+    {\n+      if (BIO_puts(bp, \"\\n\") <= 0) return 0; else return 1;\n+    }\n+\n+  ASN1_STRING *ssig = (ASN1_STRING*) sig;\n+\n+  if (BIO_write(bp, \"\\n\", 1) != 1)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      return 0;\n+    }\n+  int i = 0;\n+  for (i = 0; (i < ssig->length); i++) {\n+    if (i % 32 == 0) {\n+      if (i) BIO_write(bp, \"\\n\", 1);\n+      int j = 0;\n+      for (j = 0; j < indent; j++)\n+\tBIO_write(bp, \" \", 1);\n+    }\n+    char buf[4];\n+    sprintf(buf, \"%02x:\", ssig->data[i]);\n+    BIO_write(bp, buf, 3);\n+  }\n+  BIO_write(bp,\"\\n\",1);\n+  return 1;\n+}\n+\n+int oqs_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\n+{\n+  OQS_PKEY_CTX *oqsa = (OQS_PKEY_CTX*)a->pkey.ptr;\n+  OQS_PKEY_CTX *oqsb = (OQS_PKEY_CTX*)b->pkey.ptr;\n+  return memcmp(oqsa->pk,oqsb->pk,oqsa->s->pub_key_len) == 0;\n+}\n+\n+// The EVP ASN1 OQS methods; 0s are unused\n+static EVP_PKEY_ASN1_METHOD oqs_asn1_meth =\n+  {\n+      NID_oqs_picnic_default, // pkey_id\n+      NID_oqs_picnic_default, // pkey_base_id\n+      0, // pkey_flags\n+      \"PicnicWithSHA256\", // pem_str\n+      \"OpenSSL OQS method\", // info\n+      oqs_pub_decode, // pub_decode\n+      oqs_pub_encode, // pub_encode\n+      oqs_pub_cmp, // pub_cmp\n+      oqs_pub_print, // pub_print\n+      oqs_priv_decode, // priv_decode\n+      oqs_priv_encode, // priv_encode\n+      0, // priv_print\n+      oqs_pkey_size, // pkey_size\n+      0, // pkey_bits\n+      0, // param_decode\n+      0, // param_encode\n+      0, // param_missing\n+      0, // param_copy\n+      0, // param_cmp\n+      0, // param_print\n+      oqs_sig_print, // sig_print\n+      oqs_pkey_free, // pkey_free\n+      0, // pkey_ctrl\n+      /* Legacy functions for old PEM */\n+      0, // old_priv_decode\n+      0, // old_priv_encode\n+      /* Custom ASN1 signature verification */\n+      0, // item_verify\n+      0 // item_sign\n+  };\n+\n+void OQS_add_all_algorithms()\n+{\n+  // Only initialize once (Not threadsafe FIXMEOQS)\n+  if (!g_initialized) {\n+\n+    // add the OQS methods\n+    EVP_PKEY_asn1_add0(&oqs_asn1_meth);\n+    EVP_PKEY_meth_add0(&oqs_pkey_meth);\n+    if (!OBJ_create(\"1 3 6 1 4 1 8301 3 1 3 3 1\", \"PicnicWithSHA256\", \"PicnicWithSHA256\")) {","path":"crypto/oqs/oqs.c","position":null,"original_position":568,"commit_id":"25d2c95373a4560290b6be6db3b2fb4b6eef1146","original_commit_id":"8c0e461be24d70cfce3e69474e7845ff41be273c","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"body":"I replaced it with a temporary placeholder value, under the Microsoft hierarchy. These will need to be updated with real values once they are assigned. I clarified the code.","created_at":"2017-09-28T20:00:12Z","updated_at":"2017-09-28T20:00:12Z","html_url":"https://github.com/open-quantum-safe/openssl/pull/11#discussion_r141720994","pull_request_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments/141720994"},"html":{"href":"https://github.com/open-quantum-safe/openssl/pull/11#discussion_r141720994"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11"}},"in_reply_to_id":137960165},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11","id":138798488,"html_url":"https://github.com/open-quantum-safe/openssl/pull/11","diff_url":"https://github.com/open-quantum-safe/openssl/pull/11.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/11.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11","number":11,"state":"open","locked":false,"title":"Add quantum-safe TLS auth (using OQS - Picnic)","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"body":"*** NOT READY FOR MERGE ***\r\n*** Pushing out to request feedback and start the discussion ***\r\nAdds quantum-safe authentication using the Picnic scheme. See README.OQS for details.\r\n\r\nSupersedes PR#9 (created a new one using the latest OQS version, now integrating the new sig API). ","created_at":"2017-09-01T01:22:58Z","updated_at":"2017-09-28T20:00:12Z","closed_at":null,"merged_at":null,"merge_commit_sha":"fd7530ec9f3fb824b2f2770ae18e7542d1caba32","assignee":null,"assignees":[],"requested_reviewers":[],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/25d2c95373a4560290b6be6db3b2fb4b6eef1146","head":{"label":"christianpaquin:add_oqs_sig_with_picnic","ref":"add_oqs_sig_with_picnic","sha":"25d2c95373a4560290b6be6db3b2fb4b6eef1146","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"repo":{"id":76978505,"name":"openssl","full_name":"christianpaquin/openssl","owner":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"private":false,"html_url":"https://github.com/christianpaquin/openssl","description":"Fork of OpenSSL that includes quantum-resistant algorithms and ciphersuites based on liboqs.","fork":true,"url":"https://api.github.com/repos/christianpaquin/openssl","forks_url":"https://api.github.com/repos/christianpaquin/openssl/forks","keys_url":"https://api.github.com/repos/christianpaquin/openssl/keys{/key_id}","collaborators_url":"https://api.github.com/repos/christianpaquin/openssl/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/christianpaquin/openssl/teams","hooks_url":"https://api.github.com/repos/christianpaquin/openssl/hooks","issue_events_url":"https://api.github.com/repos/christianpaquin/openssl/issues/events{/number}","events_url":"https://api.github.com/repos/christianpaquin/openssl/events","assignees_url":"https://api.github.com/repos/christianpaquin/openssl/assignees{/user}","branches_url":"https://api.github.com/repos/christianpaquin/openssl/branches{/branch}","tags_url":"https://api.github.com/repos/christianpaquin/openssl/tags","blobs_url":"https://api.github.com/repos/christianpaquin/openssl/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/christianpaquin/openssl/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/christianpaquin/openssl/git/refs{/sha}","trees_url":"https://api.github.com/repos/christianpaquin/openssl/git/trees{/sha}","statuses_url":"https://api.github.com/repos/christianpaquin/openssl/statuses/{sha}","languages_url":"https://api.github.com/repos/christianpaquin/openssl/languages","stargazers_url":"https://api.github.com/repos/christianpaquin/openssl/stargazers","contributors_url":"https://api.github.com/repos/christianpaquin/openssl/contributors","subscribers_url":"https://api.github.com/repos/christianpaquin/openssl/subscribers","subscription_url":"https://api.github.com/repos/christianpaquin/openssl/subscription","commits_url":"https://api.github.com/repos/christianpaquin/openssl/commits{/sha}","git_commits_url":"https://api.github.com/repos/christianpaquin/openssl/git/commits{/sha}","comments_url":"https://api.github.com/repos/christianpaquin/openssl/comments{/number}","issue_comment_url":"https://api.github.com/repos/christianpaquin/openssl/issues/comments{/number}","contents_url":"https://api.github.com/repos/christianpaquin/openssl/contents/{+path}","compare_url":"https://api.github.com/repos/christianpaquin/openssl/compare/{base}...{head}","merges_url":"https://api.github.com/repos/christianpaquin/openssl/merges","archive_url":"https://api.github.com/repos/christianpaquin/openssl/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/christianpaquin/openssl/downloads","issues_url":"https://api.github.com/repos/christianpaquin/openssl/issues{/number}","pulls_url":"https://api.github.com/repos/christianpaquin/openssl/pulls{/number}","milestones_url":"https://api.github.com/repos/christianpaquin/openssl/milestones{/number}","notifications_url":"https://api.github.com/repos/christianpaquin/openssl/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/christianpaquin/openssl/labels{/name}","releases_url":"https://api.github.com/repos/christianpaquin/openssl/releases{/id}","deployments_url":"https://api.github.com/repos/christianpaquin/openssl/deployments","created_at":"2016-12-20T17:41:49Z","updated_at":"2017-09-12T05:52:51Z","pushed_at":"2017-09-28T19:58:41Z","git_url":"git://github.com/christianpaquin/openssl.git","ssh_url":"git@github.com:christianpaquin/openssl.git","clone_url":"https://github.com/christianpaquin/openssl.git","svn_url":"https://github.com/christianpaquin/openssl","homepage":"https://openquantumsafe.org/","size":95082,"stargazers_count":1,"watchers_count":1,"language":"C","has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":0,"mirror_url":null,"open_issues_count":0,"forks":0,"open_issues":0,"watchers":1,"default_branch":"OpenSSL_1_0_2-stable"}},"base":{"label":"open-quantum-safe:OpenSSL_1_0_2-stable","ref":"OpenSSL_1_0_2-stable","sha":"4ff09753dd6afd26f04c456d691ec3ba803a912a","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":66578799,"name":"openssl","full_name":"open-quantum-safe/openssl","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/openssl","description":"Fork of OpenSSL that includes quantum-resistant algorithms and ciphersuites based on liboqs.","fork":true,"url":"https://api.github.com/repos/open-quantum-safe/openssl","forks_url":"https://api.github.com/repos/open-quantum-safe/openssl/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/openssl/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/openssl/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/openssl/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/openssl/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/openssl/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/openssl/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/openssl/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/openssl/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/openssl/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/openssl/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/openssl/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/openssl/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/openssl/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/openssl/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/openssl/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/openssl/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/openssl/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/openssl/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/openssl/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/openssl/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/openssl/deployments","created_at":"2016-08-25T17:25:43Z","updated_at":"2017-09-22T18:25:39Z","pushed_at":"2017-09-28T19:58:42Z","git_url":"git://github.com/open-quantum-safe/openssl.git","ssh_url":"git@github.com:open-quantum-safe/openssl.git","clone_url":"https://github.com/open-quantum-safe/openssl.git","svn_url":"https://github.com/open-quantum-safe/openssl","homepage":"https://openquantumsafe.org/","size":98010,"stargazers_count":22,"watchers_count":22,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":6,"mirror_url":null,"open_issues_count":6,"forks":6,"open_issues":6,"watchers":22,"default_branch":"OpenSSL_1_0_2-stable"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11"},"html":{"href":"https://github.com/open-quantum-safe/openssl/pull/11"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/25d2c95373a4560290b6be6db3b2fb4b6eef1146"}},"author_association":"NONE"}},"public":true,"created_at":"2017-09-28T20:00:12Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
{"id":"6651428039","type":"PullRequestReviewCommentEvent","actor":{"id":16247285,"login":"christianpaquin","display_login":"christianpaquin","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","avatar_url":"https://avatars.githubusercontent.com/u/16247285?"},"repo":{"id":66578799,"name":"open-quantum-safe/openssl","url":"https://api.github.com/repos/open-quantum-safe/openssl"},"payload":{"action":"created","comment":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments/141721312","pull_request_review_id":65981817,"id":141721312,"diff_hunk":"@@ -0,0 +1,593 @@\n+#define UNUSED __attribute__((unused))\n+\n+#include <openssl/asn1t.h>\n+#include <openssl/cms.h>\n+#include <openssl/err.h>\n+#include <openssl/pem.h>\n+#include <openssl/ssl.h>\n+\n+#include <oqs/rand.h>\n+#include <oqs/common.h>\n+#include <oqs/sig.h>\n+\n+#include \"oqs.h\"\n+\n+/* \n+ * FIXMEOQS (remove this)\n+ * OQS note: the content of this file should be distributed in the OpenSSL\n+ * code base to avoid a manual registration of the OQS algs, but this makes\n+ * it simple to develop and test. \n+ *\n+ * Error codes should be reviewed and functions defined for the OQSerr macro. \n+ *\n+ * The code needs to be generalized to support more than one sig alg.\n+ */\n+\n+/*\n+ * This file contains OQS-related code. This could be distributed in various\n+ * files like the other OpenSSL algs, but we keep them in one file for simplicity.\n+ */\n+\n+static int g_initialized = 0;\n+\n+int OQS_up_ref(OQS_PKEY_CTX *key)\n+{\n+  int i = CRYPTO_add(&key->references, 1, CRYPTO_LOCK_OQS);\n+  return ((i > 1) ? 1 : 0);\n+}\n+\n+int EVP_PKEY_set1_OQS(EVP_PKEY *pkey, OQS_PKEY_CTX *key)\n+{             \n+  int ret = EVP_PKEY_assign(pkey, EVP_PKEY_OQS, key);\n+  if(ret) OQS_up_ref(key);\n+  return ret;\n+}             \n+\n+int pkey_oqs_init(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs  = OPENSSL_malloc(sizeof(OQS_PKEY_CTX));\n+  if (!oqs) {\n+    return 0;\n+  }\n+  oqs->s = 0;\n+  oqs->sk = 0;\n+  oqs->pk = 0;\n+  oqs->references = 0;\n+  oqs->md = 0;\n+  ctx->data = oqs;\n+  return 1;\n+}\n+\n+int pkey_oqs_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\n+\n+{\n+  OQS_PKEY_CTX *dctx, *sctx;\n+  if (!pkey_oqs_init(dst)) {\n+    return 0;\n+  }\n+  // FIXMEOQS: are these copies safe? should I call OQS_up_ref?\n+\n+  sctx = src->data;\n+  dctx = dst->data;\n+  dctx->s = sctx->s;\n+  dctx->sk = sctx->sk;\n+  dctx->pk = sctx->pk;\n+  dctx->references = sctx->references;\n+  dctx->md = sctx->md;\n+  return 1;\t\n+}\n+\n+void pkey_oqs_cleanup(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = ctx->data;\n+  if (oqs) {\n+    OPENSSL_free(oqs);\n+  }\n+}\n+\n+int pkey_oqs_sign_init(EVP_PKEY_CTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs->sk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+int pkey_oqs_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\n+\t\t  const unsigned char *tbs, size_t tbslen)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs_ctx || !oqs_ctx->s || !oqs_ctx->sk ) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  if (*siglen != oqs_ctx->s->max_sig_len) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  if (OQS_SIG_sign(oqs_ctx->s, oqs_ctx->sk, tbs, tbslen, sig, siglen) != 1) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+int pkey_oqs_verify(EVP_PKEY_CTX *ctx,\n+\t\t    const unsigned char *sig, size_t siglen,\n+\t\t    const unsigned char *tbs, size_t tbslen)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->pkey->pkey.ptr;\n+  if (!oqs_ctx || !oqs_ctx->s  || !oqs_ctx->pk || sig == NULL || tbs == NULL) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  if (OQS_SIG_verify(oqs_ctx->s, oqs_ctx->pk, tbs, tbslen, sig, siglen) != 1) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+int oqs_pkey_ctx_init(OQS_PKEY_CTX* ctx, enum OQS_SIG_algid algid) {\n+  if (ctx == NULL) {\n+    goto err;\n+  }\n+\n+  OQS_RAND *rand = NULL;\n+  OQS_SIG *s;\n+  uint8_t *priv = NULL;\n+  uint8_t *pub = NULL;\n+\n+  rand = OQS_RAND_new(OQS_RAND_alg_default); // TODO: don't hardcode\n+  if (rand == NULL) {\n+    goto err;\n+  }\n+  s = OQS_SIG_new(rand, algid);\n+  if (s == NULL) {\n+    goto err;\n+  }\n+  priv = OPENSSL_malloc(s->priv_key_len);\n+  if (priv == NULL) {\n+    goto err;\n+  }\n+  pub = OPENSSL_malloc(s->pub_key_len);\n+  if (pub == NULL) {\n+    goto err;\n+  }\n+  ctx->s = s;\n+  ctx->sk = priv;\n+  ctx->pk = pub;\n+\n+  return 1;\n+\n+ err:\n+  if (rand) { OQS_RAND_free(rand); }\n+  if (s) { OQS_SIG_free(s); }\n+  if (priv) { OPENSSL_free(priv); }\n+  if (pub) { OPENSSL_free(pub); }\n+  return 0;\n+}\n+\n+void oqs_pkey_ctx_free(OQS_PKEY_CTX* ctx) {\n+  if (ctx == NULL) {\n+    return;\n+  }\n+  if (ctx->s->rand) { OQS_RAND_free(ctx->s->rand); }\n+  if (ctx->s) { OQS_SIG_free(ctx->s); }\n+  if (ctx->sk) { OPENSSL_free(ctx->sk); }\n+  if (ctx->pk) { OPENSSL_free(ctx->pk); }\n+  return;\n+}\n+\n+int pkey_oqs_keygen_init(EVP_PKEY_CTX *ctx)\n+{\n+  if (ctx == NULL) {\n+    return 0;\n+  }\n+  OQS_PKEY_CTX *oqs_ctx = ctx->data;\n+  return oqs_pkey_ctx_init(oqs_ctx, OQS_SIG_picnic_default); // TODO: don't hardcode\n+}\n+\n+int pkey_oqs_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) ctx->data;\n+  if (!oqs_ctx || !oqs_ctx->s || !oqs_ctx->sk || !oqs_ctx->pk ) {\n+    goto err;\n+  }\n+  if (OQS_SIG_keygen(oqs_ctx->s, oqs_ctx->sk, oqs_ctx->pk) != 1) {\n+    goto err;\n+  }\n+  \n+  pkey->pkey.ptr = (void*) oqs_ctx;\n+  EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+  return 1;\n+\n+ err:\n+  return 0;\n+}\n+\n+static int pkey_oqs_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\n+{\n+  OQS_PKEY_CTX *oqs = ctx->data;\n+  switch(type)\n+    {\n+    case EVP_PKEY_CTRL_MD:\n+      if (EVP_MD_type((const EVP_MD *)p2) != NID_sha256 &&\n+\t  EVP_MD_type((const EVP_MD *)p2) != NID_sha384 &&\n+\t  EVP_MD_type((const EVP_MD *)p2) != NID_sha512)\n+\t{\n+\t  OQSerr(0, ERR_R_FATAL);\n+\t  return 0;\n+\t}\n+      oqs->md = (EVP_MD *) p2;\n+      return 1;\n+    case EVP_PKEY_CTRL_DIGESTINIT:\n+    case EVP_PKEY_CTRL_PKCS7_SIGN:\n+    case EVP_PKEY_CTRL_CMS_SIGN:\n+      return 1; \n+    case EVP_PKEY_CTRL_PEER_KEY:\n+\t  OQSerr(0, ERR_R_FATAL);\n+\t  return -2; // error code returned by calling function in p_lib.c\n+    default:\n+      return -2;\n+    }\n+  return 0;\n+}\n+\n+// The EVP OQS methods; 0s are unused\n+static EVP_PKEY_METHOD oqs_pkey_meth =\n+    {\n+      NID_oqs_picnic_default,\n+      EVP_PKEY_FLAG_AUTOARGLEN,\n+      pkey_oqs_init,\n+      pkey_oqs_copy,\n+      pkey_oqs_cleanup,\n+      0, // paramgen_init\n+      0, //paramgen\n+      pkey_oqs_keygen_init,\n+      pkey_oqs_keygen,\n+      pkey_oqs_sign_init,\n+      pkey_oqs_sign,\n+      0, //verify_init\n+      pkey_oqs_verify,\n+      0, //verify_recover_init\n+      0, //verify_recover\n+      0, //signctx_init\n+      0, //signctx\n+      0, //verifyctx_init\n+      0, //verifyctx\n+      0, //encrypt_init\n+      0, //encrypt\n+      0, //decrypt_init\n+      0, //decrypt\n+      0, //derive_init\n+      0, //derive\n+      pkey_oqs_ctrl,\n+      0 // pkey_oqs_ctrl_str\n+    };\n+\n+/////////////////////////////////////////////////////////\n+// ASN.1 artifacts\n+/////////////////////////////////////////////////////////\n+\n+// Secret key\n+typedef struct {\n+  long algid;\n+  ASN1_OCTET_STRING *sk;\n+  ASN1_OCTET_STRING *pk;\n+} oqsasn1sk;\n+// Public key\n+typedef struct {\n+  long algid;\n+  ASN1_OCTET_STRING *pk;\t\n+} oqsasn1pk;\n+\n+ASN1_SEQUENCE(oqsasn1sk) ={\n+  ASN1_SIMPLE(oqsasn1sk,algid,LONG),\n+  ASN1_SIMPLE(oqsasn1sk,sk,ASN1_OCTET_STRING),\n+  ASN1_SIMPLE(oqsasn1sk,pk,ASN1_OCTET_STRING)\n+}  ASN1_SEQUENCE_END(oqsasn1sk)\n+DECLARE_ASN1_FUNCTIONS(oqsasn1sk)\n+\n+ASN1_SEQUENCE(oqsasn1pk) ={\n+  ASN1_SIMPLE(oqsasn1pk,algid,LONG),\n+  ASN1_SIMPLE(oqsasn1pk,pk,ASN1_OCTET_STRING)\n+}  ASN1_SEQUENCE_END(oqsasn1pk)\n+DECLARE_ASN1_FUNCTIONS(oqsasn1pk)\n+\n+IMPLEMENT_ASN1_FUNCTIONS(oqsasn1sk)\n+IMPLEMENT_ASN1_FUNCTIONS(oqsasn1pk)\n+\n+ASN1_OCTET_STRING *asn1_octet_string_from( unsigned char *d, int len)\n+{\n+  ASN1_OCTET_STRING *a = ASN1_OCTET_STRING_new();\n+  if (!ASN1_OCTET_STRING_set(a, d, len)) {\n+    return 0;\n+  }\n+  return a;\n+}\n+\n+static int oqs_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*) pkey->pkey.ptr;\n+  void *pval = NULL;\n+  int ptype = V_ASN1_UNDEF;\n+  ASN1_STRING *penc = ASN1_STRING_new(); // FIXMEOQS: leaks! can't free it otherwise fails later\n+  if (!oqs->pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  oqsasn1pk asn1;\n+  asn1.algid = OQS_SIG_picnic_default; // FIXMEOQS: don't hardcode\n+  asn1.pk = asn1_octet_string_from(oqs->pk, oqs->s->pub_key_len);\n+  if (!asn1.pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    return 0;\n+  }\n+  // i2d_TYPE converts an ASN.1 object in an internal standardized form\n+  // to its DER encoding and stuffs it into a character string\n+  penc->length = i2d_oqsasn1pk(&asn1,&penc->data);\n+  return X509_PUBKEY_set0_param(pk, OBJ_nid2obj(NID_oqs_picnic_default),\n+\t\t\t\tptype, pval, penc->data, penc->length);\n+}\n+\n+static int oqs_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n+{\n+  int rc;\n+  const unsigned char *p=NULL;\n+  int plen;\n+  PKCS8_pkey_get0(NULL, &p, &plen, NULL, p8);\n+\n+  oqsasn1sk a;\n+  oqsasn1sk *asn1=&a;\n+  a.sk = ASN1_OCTET_STRING_new();\n+  a.pk = ASN1_OCTET_STRING_new();\n+\n+  // d2i_TYPE converts an ASN.1 object from its DER encoded form to its\n+  // internal standardized form. \n+  d2i_oqsasn1sk(&asn1,(const unsigned char**)&p, plen);\n+\n+  OQS_PKEY_CTX *oqs_ctx = (OQS_PKEY_CTX*) OPENSSL_malloc(sizeof(OQS_PKEY_CTX)); // FIXMEOQS: leaks\n+  oqs_pkey_ctx_init(oqs_ctx, asn1->algid);\n+  memcpy(oqs_ctx->sk, asn1->sk->data, oqs_ctx->s->priv_key_len); // FIXMEOQS: should the len come from the asn1 struct\n+  memcpy(oqs_ctx->pk, asn1->pk->data, oqs_ctx->s->pub_key_len);\n+  rc = EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+\n+  // cleanup:\n+  if (a.sk) { ASN1_OCTET_STRING_free(a.sk); }\n+  if (a.pk) { ASN1_OCTET_STRING_free(a.pk); }\n+\n+  return rc;\n+}\n+\n+static int oqs_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n+{\n+  unsigned char *p;\n+  int pklen;\n+  X509_ALGOR *palg;\n+\n+  if (!X509_PUBKEY_get0_param(NULL,(const unsigned char**) &p, &pklen, &palg, pubkey))\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      return 0;\n+    }\n+\n+  oqsasn1pk a;\n+  oqsasn1pk *asn1=&a;\n+  a.pk = ASN1_OCTET_STRING_new();\n+  d2i_oqsasn1pk(&asn1,(const unsigned char **)&p, pklen);\n+  OQS_PKEY_CTX *oqs_ctx = OPENSSL_malloc(sizeof(OQS_PKEY_CTX)); // FIXMEOQS: leaks\n+  oqs_pkey_ctx_init(oqs_ctx, asn1->algid);\n+  memcpy(oqs_ctx->pk, asn1->pk->data, oqs_ctx->s->pub_key_len);\n+  return EVP_PKEY_set1_OQS(pkey, oqs_ctx);\n+}\n+\n+static int oqs_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n+{\n+  int rc;\n+  ASN1_INTEGER *params = NULL;\n+  ASN1_STRING *prkey  = NULL;\n+\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  if (!oqs || !oqs->sk)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+  oqsasn1sk asn1;\n+  asn1.algid = OQS_SIG_picnic_default; // FIXMEOQS: don't hardcode\n+  asn1.sk = asn1_octet_string_from(oqs->sk, oqs->s->priv_key_len);\n+  if (!asn1.sk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    goto err;\n+  }\n+  asn1.pk = asn1_octet_string_from(oqs->pk, oqs->s->pub_key_len);\n+  if (!asn1.pk) {\n+    OQSerr(0, ERR_R_FATAL);\n+    goto err;\n+  }\n+  prkey = ASN1_STRING_new(); // FIXMEOQS: leaks! can't free it here otherwise fails later (in apps/genoqs.c)\n+  prkey->length = i2d_oqsasn1sk(&asn1,&prkey->data);\n+  if (prkey->length <= 0)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+  params=ASN1_INTEGER_new();\n+  ASN1_INTEGER_set(params,NID_oqs_picnic_default);\n+  if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_oqs_picnic_default), 0,\n+\t\t       V_ASN1_NULL,0, prkey->data, prkey->length))\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      goto err;\n+    }\n+\n+    rc =1;\n+    goto cleanup;\n+\n+ err:\n+  rc = 0;\n+\n+ cleanup:\n+  if (asn1.sk) { ASN1_OCTET_STRING_free(asn1.sk); }\n+  if (asn1.pk) { ASN1_OCTET_STRING_free(asn1.pk); }\n+  if (params) { ASN1_INTEGER_free(params); }\n+  return rc;\n+}\n+\n+// Returns number of bytes per signatures as per the reference implementation\n+// FIXMEOQS: this seems wrong. Should return oqs->s->pub_key_len, but SSL code\n+// depends on this; should fix it so it doesn't call this function.\n+static int oqs_pkey_size(const EVP_PKEY *pkey)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  int siglen = oqs->s->max_sig_len;\n+  return siglen;\n+}\n+\n+static void oqs_pkey_free(EVP_PKEY *pkey)\n+{\n+  if (pkey == NULL) return;\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  oqs_pkey_ctx_free(oqs);\n+  return;\n+}\n+\n+// This function is called from the X509 context and prints the public key\n+// as we know them from x509 certs xx:xx:xx:xx...\n+static int oqs_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,\n+\t\t\t UNUSED ASN1_PCTX *ctx)\n+{\n+  OQS_PKEY_CTX *oqs = (OQS_PKEY_CTX*)pkey->pkey.ptr;\n+  unsigned char *pk = oqs->pk;\n+  int i;\n+  for (i = 0; i < oqs->s->pub_key_len; i++){\n+    if (i % 16 == 0) {\n+      if (i) BIO_write(bp, \"\\n\", 1);\n+      int j;\n+      for (j=0; j < indent; j++)\n+\tBIO_write(bp, \" \", 1);\n+    }\n+    char buf[10];\n+    sprintf(buf, \"%02x:\", pk[i]);\n+    BIO_write(bp, buf, 3);\n+  }\n+  BIO_write(bp,\"\\n\",1);\n+  return 1;\t\n+}\n+\n+// Prints the signature for the X.509 certificate as in openssl x509 -text\n+static int oqs_sig_print(BIO *bp, UNUSED const X509_ALGOR *sigalg,\n+\t\t\t const ASN1_STRING *sig, int indent, UNUSED ASN1_PCTX *pctx)\n+{\n+  if (!sig)\n+    {\n+      if (BIO_puts(bp, \"\\n\") <= 0) return 0; else return 1;\n+    }\n+\n+  ASN1_STRING *ssig = (ASN1_STRING*) sig;\n+\n+  if (BIO_write(bp, \"\\n\", 1) != 1)\n+    {\n+      OQSerr(0, ERR_R_FATAL);\n+      return 0;\n+    }\n+  int i = 0;\n+  for (i = 0; (i < ssig->length); i++) {\n+    if (i % 32 == 0) {\n+      if (i) BIO_write(bp, \"\\n\", 1);\n+      int j = 0;\n+      for (j = 0; j < indent; j++)\n+\tBIO_write(bp, \" \", 1);\n+    }\n+    char buf[4];\n+    sprintf(buf, \"%02x:\", ssig->data[i]);\n+    BIO_write(bp, buf, 3);\n+  }\n+  BIO_write(bp,\"\\n\",1);\n+  return 1;\n+}\n+\n+int oqs_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\n+{\n+  OQS_PKEY_CTX *oqsa = (OQS_PKEY_CTX*)a->pkey.ptr;\n+  OQS_PKEY_CTX *oqsb = (OQS_PKEY_CTX*)b->pkey.ptr;\n+  return memcmp(oqsa->pk,oqsb->pk,oqsa->s->pub_key_len) == 0;\n+}\n+\n+// The EVP ASN1 OQS methods; 0s are unused\n+static EVP_PKEY_ASN1_METHOD oqs_asn1_meth =\n+  {\n+      NID_oqs_picnic_default, // pkey_id\n+      NID_oqs_picnic_default, // pkey_base_id\n+      0, // pkey_flags\n+      \"PicnicWithSHA256\", // pem_str\n+      \"OpenSSL OQS method\", // info\n+      oqs_pub_decode, // pub_decode\n+      oqs_pub_encode, // pub_encode\n+      oqs_pub_cmp, // pub_cmp\n+      oqs_pub_print, // pub_print\n+      oqs_priv_decode, // priv_decode\n+      oqs_priv_encode, // priv_encode\n+      0, // priv_print\n+      oqs_pkey_size, // pkey_size\n+      0, // pkey_bits\n+      0, // param_decode\n+      0, // param_encode\n+      0, // param_missing\n+      0, // param_copy\n+      0, // param_cmp\n+      0, // param_print\n+      oqs_sig_print, // sig_print\n+      oqs_pkey_free, // pkey_free\n+      0, // pkey_ctrl\n+      /* Legacy functions for old PEM */\n+      0, // old_priv_decode\n+      0, // old_priv_encode\n+      /* Custom ASN1 signature verification */\n+      0, // item_verify\n+      0 // item_sign\n+  };\n+\n+void OQS_add_all_algorithms()\n+{\n+  // Only initialize once (Not threadsafe FIXMEOQS)\n+  if (!g_initialized) {\n+\n+    // add the OQS methods\n+    EVP_PKEY_asn1_add0(&oqs_asn1_meth);\n+    EVP_PKEY_meth_add0(&oqs_pkey_meth);\n+    if (!OBJ_create(\"1 3 6 1 4 1 8301 3 1 3 3 1\", \"PicnicWithSHA256\", \"PicnicWithSHA256\")) {","path":"crypto/oqs/oqs.c","position":null,"original_position":568,"commit_id":"25d2c95373a4560290b6be6db3b2fb4b6eef1146","original_commit_id":"8c0e461be24d70cfce3e69474e7845ff41be273c","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"body":"I defined it in a macro. I kept the definition local; we can integrate in the crypto/objects files later once the code is more stable.","created_at":"2017-09-28T20:01:42Z","updated_at":"2017-09-28T20:01:42Z","html_url":"https://github.com/open-quantum-safe/openssl/pull/11#discussion_r141721312","pull_request_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments/141721312"},"html":{"href":"https://github.com/open-quantum-safe/openssl/pull/11#discussion_r141721312"},"pull_request":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11"}},"in_reply_to_id":137960157},"pull_request":{"url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11","id":138798488,"html_url":"https://github.com/open-quantum-safe/openssl/pull/11","diff_url":"https://github.com/open-quantum-safe/openssl/pull/11.diff","patch_url":"https://github.com/open-quantum-safe/openssl/pull/11.patch","issue_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11","number":11,"state":"open","locked":false,"title":"Add quantum-safe TLS auth (using OQS - Picnic)","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"body":"*** NOT READY FOR MERGE ***\r\n*** Pushing out to request feedback and start the discussion ***\r\nAdds quantum-safe authentication using the Picnic scheme. See README.OQS for details.\r\n\r\nSupersedes PR#9 (created a new one using the latest OQS version, now integrating the new sig API). ","created_at":"2017-09-01T01:22:58Z","updated_at":"2017-09-28T20:01:42Z","closed_at":null,"merged_at":null,"merge_commit_sha":"fd7530ec9f3fb824b2f2770ae18e7542d1caba32","assignee":null,"assignees":[],"requested_reviewers":[],"milestone":null,"commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/commits","review_comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/comments","review_comment_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments{/number}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11/comments","statuses_url":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/25d2c95373a4560290b6be6db3b2fb4b6eef1146","head":{"label":"christianpaquin:add_oqs_sig_with_picnic","ref":"add_oqs_sig_with_picnic","sha":"25d2c95373a4560290b6be6db3b2fb4b6eef1146","user":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"repo":{"id":76978505,"name":"openssl","full_name":"christianpaquin/openssl","owner":{"login":"christianpaquin","id":16247285,"avatar_url":"https://avatars0.githubusercontent.com/u/16247285?v=4","gravatar_id":"","url":"https://api.github.com/users/christianpaquin","html_url":"https://github.com/christianpaquin","followers_url":"https://api.github.com/users/christianpaquin/followers","following_url":"https://api.github.com/users/christianpaquin/following{/other_user}","gists_url":"https://api.github.com/users/christianpaquin/gists{/gist_id}","starred_url":"https://api.github.com/users/christianpaquin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/christianpaquin/subscriptions","organizations_url":"https://api.github.com/users/christianpaquin/orgs","repos_url":"https://api.github.com/users/christianpaquin/repos","events_url":"https://api.github.com/users/christianpaquin/events{/privacy}","received_events_url":"https://api.github.com/users/christianpaquin/received_events","type":"User","site_admin":false},"private":false,"html_url":"https://github.com/christianpaquin/openssl","description":"Fork of OpenSSL that includes quantum-resistant algorithms and ciphersuites based on liboqs.","fork":true,"url":"https://api.github.com/repos/christianpaquin/openssl","forks_url":"https://api.github.com/repos/christianpaquin/openssl/forks","keys_url":"https://api.github.com/repos/christianpaquin/openssl/keys{/key_id}","collaborators_url":"https://api.github.com/repos/christianpaquin/openssl/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/christianpaquin/openssl/teams","hooks_url":"https://api.github.com/repos/christianpaquin/openssl/hooks","issue_events_url":"https://api.github.com/repos/christianpaquin/openssl/issues/events{/number}","events_url":"https://api.github.com/repos/christianpaquin/openssl/events","assignees_url":"https://api.github.com/repos/christianpaquin/openssl/assignees{/user}","branches_url":"https://api.github.com/repos/christianpaquin/openssl/branches{/branch}","tags_url":"https://api.github.com/repos/christianpaquin/openssl/tags","blobs_url":"https://api.github.com/repos/christianpaquin/openssl/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/christianpaquin/openssl/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/christianpaquin/openssl/git/refs{/sha}","trees_url":"https://api.github.com/repos/christianpaquin/openssl/git/trees{/sha}","statuses_url":"https://api.github.com/repos/christianpaquin/openssl/statuses/{sha}","languages_url":"https://api.github.com/repos/christianpaquin/openssl/languages","stargazers_url":"https://api.github.com/repos/christianpaquin/openssl/stargazers","contributors_url":"https://api.github.com/repos/christianpaquin/openssl/contributors","subscribers_url":"https://api.github.com/repos/christianpaquin/openssl/subscribers","subscription_url":"https://api.github.com/repos/christianpaquin/openssl/subscription","commits_url":"https://api.github.com/repos/christianpaquin/openssl/commits{/sha}","git_commits_url":"https://api.github.com/repos/christianpaquin/openssl/git/commits{/sha}","comments_url":"https://api.github.com/repos/christianpaquin/openssl/comments{/number}","issue_comment_url":"https://api.github.com/repos/christianpaquin/openssl/issues/comments{/number}","contents_url":"https://api.github.com/repos/christianpaquin/openssl/contents/{+path}","compare_url":"https://api.github.com/repos/christianpaquin/openssl/compare/{base}...{head}","merges_url":"https://api.github.com/repos/christianpaquin/openssl/merges","archive_url":"https://api.github.com/repos/christianpaquin/openssl/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/christianpaquin/openssl/downloads","issues_url":"https://api.github.com/repos/christianpaquin/openssl/issues{/number}","pulls_url":"https://api.github.com/repos/christianpaquin/openssl/pulls{/number}","milestones_url":"https://api.github.com/repos/christianpaquin/openssl/milestones{/number}","notifications_url":"https://api.github.com/repos/christianpaquin/openssl/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/christianpaquin/openssl/labels{/name}","releases_url":"https://api.github.com/repos/christianpaquin/openssl/releases{/id}","deployments_url":"https://api.github.com/repos/christianpaquin/openssl/deployments","created_at":"2016-12-20T17:41:49Z","updated_at":"2017-09-12T05:52:51Z","pushed_at":"2017-09-28T19:58:41Z","git_url":"git://github.com/christianpaquin/openssl.git","ssh_url":"git@github.com:christianpaquin/openssl.git","clone_url":"https://github.com/christianpaquin/openssl.git","svn_url":"https://github.com/christianpaquin/openssl","homepage":"https://openquantumsafe.org/","size":95082,"stargazers_count":1,"watchers_count":1,"language":"C","has_issues":false,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":0,"mirror_url":null,"open_issues_count":0,"forks":0,"open_issues":0,"watchers":1,"default_branch":"OpenSSL_1_0_2-stable"}},"base":{"label":"open-quantum-safe:OpenSSL_1_0_2-stable","ref":"OpenSSL_1_0_2-stable","sha":"4ff09753dd6afd26f04c456d691ec3ba803a912a","user":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"repo":{"id":66578799,"name":"openssl","full_name":"open-quantum-safe/openssl","owner":{"login":"open-quantum-safe","id":20689385,"avatar_url":"https://avatars3.githubusercontent.com/u/20689385?v=4","gravatar_id":"","url":"https://api.github.com/users/open-quantum-safe","html_url":"https://github.com/open-quantum-safe","followers_url":"https://api.github.com/users/open-quantum-safe/followers","following_url":"https://api.github.com/users/open-quantum-safe/following{/other_user}","gists_url":"https://api.github.com/users/open-quantum-safe/gists{/gist_id}","starred_url":"https://api.github.com/users/open-quantum-safe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/open-quantum-safe/subscriptions","organizations_url":"https://api.github.com/users/open-quantum-safe/orgs","repos_url":"https://api.github.com/users/open-quantum-safe/repos","events_url":"https://api.github.com/users/open-quantum-safe/events{/privacy}","received_events_url":"https://api.github.com/users/open-quantum-safe/received_events","type":"Organization","site_admin":false},"private":false,"html_url":"https://github.com/open-quantum-safe/openssl","description":"Fork of OpenSSL that includes quantum-resistant algorithms and ciphersuites based on liboqs.","fork":true,"url":"https://api.github.com/repos/open-quantum-safe/openssl","forks_url":"https://api.github.com/repos/open-quantum-safe/openssl/forks","keys_url":"https://api.github.com/repos/open-quantum-safe/openssl/keys{/key_id}","collaborators_url":"https://api.github.com/repos/open-quantum-safe/openssl/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/open-quantum-safe/openssl/teams","hooks_url":"https://api.github.com/repos/open-quantum-safe/openssl/hooks","issue_events_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/events{/number}","events_url":"https://api.github.com/repos/open-quantum-safe/openssl/events","assignees_url":"https://api.github.com/repos/open-quantum-safe/openssl/assignees{/user}","branches_url":"https://api.github.com/repos/open-quantum-safe/openssl/branches{/branch}","tags_url":"https://api.github.com/repos/open-quantum-safe/openssl/tags","blobs_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/refs{/sha}","trees_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/trees{/sha}","statuses_url":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/{sha}","languages_url":"https://api.github.com/repos/open-quantum-safe/openssl/languages","stargazers_url":"https://api.github.com/repos/open-quantum-safe/openssl/stargazers","contributors_url":"https://api.github.com/repos/open-quantum-safe/openssl/contributors","subscribers_url":"https://api.github.com/repos/open-quantum-safe/openssl/subscribers","subscription_url":"https://api.github.com/repos/open-quantum-safe/openssl/subscription","commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/commits{/sha}","git_commits_url":"https://api.github.com/repos/open-quantum-safe/openssl/git/commits{/sha}","comments_url":"https://api.github.com/repos/open-quantum-safe/openssl/comments{/number}","issue_comment_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues/comments{/number}","contents_url":"https://api.github.com/repos/open-quantum-safe/openssl/contents/{+path}","compare_url":"https://api.github.com/repos/open-quantum-safe/openssl/compare/{base}...{head}","merges_url":"https://api.github.com/repos/open-quantum-safe/openssl/merges","archive_url":"https://api.github.com/repos/open-quantum-safe/openssl/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/open-quantum-safe/openssl/downloads","issues_url":"https://api.github.com/repos/open-quantum-safe/openssl/issues{/number}","pulls_url":"https://api.github.com/repos/open-quantum-safe/openssl/pulls{/number}","milestones_url":"https://api.github.com/repos/open-quantum-safe/openssl/milestones{/number}","notifications_url":"https://api.github.com/repos/open-quantum-safe/openssl/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/open-quantum-safe/openssl/labels{/name}","releases_url":"https://api.github.com/repos/open-quantum-safe/openssl/releases{/id}","deployments_url":"https://api.github.com/repos/open-quantum-safe/openssl/deployments","created_at":"2016-08-25T17:25:43Z","updated_at":"2017-09-22T18:25:39Z","pushed_at":"2017-09-28T19:58:42Z","git_url":"git://github.com/open-quantum-safe/openssl.git","ssh_url":"git@github.com:open-quantum-safe/openssl.git","clone_url":"https://github.com/open-quantum-safe/openssl.git","svn_url":"https://github.com/open-quantum-safe/openssl","homepage":"https://openquantumsafe.org/","size":98010,"stargazers_count":22,"watchers_count":22,"language":"C","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":6,"mirror_url":null,"open_issues_count":6,"forks":6,"open_issues":6,"watchers":22,"default_branch":"OpenSSL_1_0_2-stable"}},"_links":{"self":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11"},"html":{"href":"https://github.com/open-quantum-safe/openssl/pull/11"},"issue":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11"},"comments":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/issues/11/comments"},"review_comments":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/comments"},"review_comment":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/comments{/number}"},"commits":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/pulls/11/commits"},"statuses":{"href":"https://api.github.com/repos/open-quantum-safe/openssl/statuses/25d2c95373a4560290b6be6db3b2fb4b6eef1146"}},"author_association":"NONE"}},"public":true,"created_at":"2017-09-28T20:01:42Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
