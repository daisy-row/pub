{"id":"14273023952","type":"IssueCommentEvent","actor":{"id":37668804,"login":"taimoorgit","display_login":"taimoorgit","gravatar_id":"","url":"https://api.github.com/users/taimoorgit","avatar_url":"https://avatars.githubusercontent.com/u/37668804?"},"repo":{"id":215630242,"name":"open-quantum-safe/liboqs-go","url":"https://api.github.com/repos/open-quantum-safe/liboqs-go"},"payload":{"action":"created","issue":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/6","repository_url":"https://api.github.com/repos/open-quantum-safe/liboqs-go","labels_url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/6/labels{/name}","comments_url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/6/comments","events_url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/6/events","html_url":"https://github.com/open-quantum-safe/liboqs-go/issues/6","id":748085819,"node_id":"MDU6SXNzdWU3NDgwODU4MTk=","number":6,"title":"ExportSecretKey() is always 0?","user":{"login":"taimoorgit","id":37668804,"node_id":"MDQ6VXNlcjM3NjY4ODA0","avatar_url":"https://avatars0.githubusercontent.com/u/37668804?v=4","gravatar_id":"","url":"https://api.github.com/users/taimoorgit","html_url":"https://github.com/taimoorgit","followers_url":"https://api.github.com/users/taimoorgit/followers","following_url":"https://api.github.com/users/taimoorgit/following{/other_user}","gists_url":"https://api.github.com/users/taimoorgit/gists{/gist_id}","starred_url":"https://api.github.com/users/taimoorgit/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/taimoorgit/subscriptions","organizations_url":"https://api.github.com/users/taimoorgit/orgs","repos_url":"https://api.github.com/users/taimoorgit/repos","events_url":"https://api.github.com/users/taimoorgit/events{/privacy}","received_events_url":"https://api.github.com/users/taimoorgit/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-11-21T19:21:26Z","updated_at":"2020-11-21T19:38:13Z","closed_at":"2020-11-21T19:38:13Z","author_association":"NONE","active_lock_reason":null,"body":"Dear OQS team,\r\n\r\nI have the following code:\r\n```\r\n\tsigner := oqs.Signature{}\r\n\tdefer signer.Clean()\r\n\tif err := signer.Init(sigName, nil); err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tpublicKey, err := signer.GenerateKeyPair()\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tsecretKey := signer.ExportSecretKey()\r\n\r\n\tfmt.Printf(\"\\nSecret key:\\n% X ... % X\\n\", secretKey[0:8], secretKey[len(secretKey)-8:])\r\n\tfmt.Printf(\"\\nPublic key:\\n% X ... % X\\n\", publicKey[0:8], publicKey[len(publicKey)-8:])\r\n```\r\n\r\nI am confused as to why the output the value of `secretKey` is always `00 00 00 ...` whereas the `publicKey` variable is always randomly generated, e.g. `09 19 5D ...` It seems that providing a `[]byte` to `signer.Init()` as the second argument makes no difference in this case. \r\n\r\nI thought that `GenerateKeyPair()` would generate both a private key and a public key. Am I wrong about this? Sorry if this is an obvious mistake, I am new to Go and cryptography in general. \r\n\r\nUsing Windows 10 64-bit and 1.15.2 64-bit. \r\n\r\n- Taimoor","performed_via_github_app":null},"comment":{"url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/comments/731626406","html_url":"https://github.com/open-quantum-safe/liboqs-go/issues/6#issuecomment-731626406","issue_url":"https://api.github.com/repos/open-quantum-safe/liboqs-go/issues/6","id":731626406,"node_id":"MDEyOklzc3VlQ29tbWVudDczMTYyNjQwNg==","user":{"login":"taimoorgit","id":37668804,"node_id":"MDQ6VXNlcjM3NjY4ODA0","avatar_url":"https://avatars0.githubusercontent.com/u/37668804?v=4","gravatar_id":"","url":"https://api.github.com/users/taimoorgit","html_url":"https://github.com/taimoorgit","followers_url":"https://api.github.com/users/taimoorgit/followers","following_url":"https://api.github.com/users/taimoorgit/following{/other_user}","gists_url":"https://api.github.com/users/taimoorgit/gists{/gist_id}","starred_url":"https://api.github.com/users/taimoorgit/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/taimoorgit/subscriptions","organizations_url":"https://api.github.com/users/taimoorgit/orgs","repos_url":"https://api.github.com/users/taimoorgit/repos","events_url":"https://api.github.com/users/taimoorgit/events{/privacy}","received_events_url":"https://api.github.com/users/taimoorgit/received_events","type":"User","site_admin":false},"created_at":"2020-11-21T19:38:13Z","updated_at":"2020-11-21T19:38:13Z","author_association":"NONE","body":"Closing this issue - later in my program I called `signer.Clean()` unnecessarily (in a different object, nonetheless!), which would wipe the secret key from memory. Relevant code from `oqs.go`:\r\n\r\n```\r\n// Clean zeroes-in the stored secret key and resets the sig receiver. One can\r\n// reuse the signature by re-initializing it with the Signature.Init method.\r\nfunc (sig *Signature) Clean() {\r\n\tif len(sig.secretKey) > 0 {\r\n\t\tMemCleanse(sig.secretKey)\r\n\t}\r\n\tC.OQS_SIG_free(sig.sig)\r\n\t*sig = Signature{}\r\n}\r\n```\r\n\r\n","performed_via_github_app":null}},"public":true,"created_at":"2020-11-21T19:38:13Z","org":{"id":20689385,"login":"open-quantum-safe","gravatar_id":"","url":"https://api.github.com/orgs/open-quantum-safe","avatar_url":"https://avatars.githubusercontent.com/u/20689385?"}}
